### **Lecture 7: Android Emulators vs. Real Devices - Full Details** Mobile app
ki security testing karne ke liye humare paas do options hote hain: ek asli
phone (Physical Device) ya ek computer program jo phone ki tarah kaam karta hai
(Emulator). **Emulator Kya Hai?** Emulator ek software hai jo aapke computer
(Windows/Mac/Linux) par ek virtual Android phone bana deta hai. Aap ismein apps
install kar sakte hain, internet chala sakte hain, aur lagbhag har woh kaam kar
sakte hain jo ek asli phone par hota hai. #### **Emulators ke Fayde (Advantages)
- Detail Mein** 1. **Root Access (Superuser Powers):** * **Kyun Zaroori Hai?**
Penetration testing mein humein app ki protected files, databases, aur system
settings tak pahunchna padta hai. Iske liye 'root' access chahiye, jo ki ek
tarah se phone ka 'Administrator' banna hai. * **Example:** Agar ek app apna
password `SharedPreferences` mein store karti hai, to bina root ke aap us file
ko nahi padh sakte. Emulator par root access by default on hota hai ya ek click
se on ho jaata hai. Asli phone mein root karne se phone kharab ho sakta hai aur
warranty chali jaati hai. 2. **Free aur Cost-Effective:** * **Problem:** Aapko
alag-alag Android versions (Android 10, 11, 12, 13) aur alag-alag screen sizes
par app test karna padta hai. * **Solution:** Har version ke liye alag phone
khareedna (e.g., ek Google Pixel, ek Samsung, ek OnePlus) bahut mehenga padega.
Emulators free hote hain. Aap ek hi computer par 10 alag-alag virtual devices
bana sakte hain. 3. **Variety aur Flexibility:** * **Example:** Aapko ek app
test karni hai jo sirf Android 8 par chalti hai aur jiska screen size tablet
jaisa hai. Asli mein aisa device dhundhna mushkil hai. Genymotion ya Android
Studio Emulator mein aap kuch hi clicks mein aisi custom device bana sakte hain.
#### **Emulators ke Nuksaan (Disadvantages) - Detail Mein** 1. **Performance:**
* **Kaisa Ehsaas Hota Hai?** Emulators aapke computer ke RAM aur CPU ka istemaal
karte hain. Agar aapka computer powerful nahi hai, to emulator bahut slow
(laggy) chalega, apps crash hongi, aur testing mein frustration hogi. Asli phone
hamesha zyada smooth chalta hai. 2. **OEM Customizations (Company ke Badlav):**
* **Kya Matlab Hai?** Samsung apne phones mein Android ke upar apni skin (OneUI)
daalta hai, Xiaomi MIUI daalta hai. Ye companies security ke liye apne extra
features bhi daalti hain. * **Example:** Samsung Knox ek security feature hai jo
sirf Samsung ke devices mein milta hai. Agar aapki app Knox ke saath interact
karti hai, to aap use ek normal emulator par theek se test nahi kar paayenge. 3.
**Hardware & Drivers:** * **Problem:** Emulators asli hardware (jaise camera
sensor, fingerprint scanner, NFC chip) ko simulate nahi kar paate. *
**Example:** Agar aap ek payment app test kar rahe hain jo NFC (Tap-to-Pay) ka
istemaal karti hai, to aap use emulator par test nahi kar sakte. Ya agar koi app
specific camera features use karti hai, to woh emulator par crash ho sakti hai.
#### **Kaunsa Emulator Best Hai?** * **Android Studio Emulator:** Agar aap
developer hain to yeh best hai. Yeh Android ke official development environment
(IDE) ke saath aata hai. * **Genymotion:** Penetration testers ke liye yeh "gold
standard" maana jaata hai. Iska free version hai, yeh bahut fast hai, aur ismein
Google Play Store, GPS simulation, camera, microphone jaise zaroori features
pehle se install aate hain. #### **BEGINNER GAP FIX: Emulator Setup
Step-by-Step** **Android Studio Emulator Install Kaise Karein:** 1. Download:
`https://developer.android.com/studio` se Android Studio install karein. 2. Open
Android Studio > Tools > AVD Manager > Create Virtual Device. 3. Phone model
select karein (e.g., Pixel 5). 4. Android 11 image download karein (System Image
tab se). 5. Error handling: Agar HAXM error aaye (Windows par), BIOS mein
Virtualization enable karein. **Root Access Enable Karna (Emulator Par):**
```bash adb root # Emulator restart karein, phir yeh run karein. Output:
"restarting adbd as root" adb shell su # Root shell enter, prompt # ban jaayega.
``` **Note:** Yeh sirf emulator par kaam karta hai, real device par nahi. ---
### **Lecture 8: Android Rooting - Full Details** **Rooting ko Aasan Bhasha Mein
Samjhein** Imagine karo aap ek kiraye ke ghar (non-rooted phone) mein rehte
hain. Aap deewaron ka rang nahi badal sakte, extra deewar nahi tod sakte.
Rooting ka matlab hai us ghar ko khareed lena (rooted phone). Ab aap ghar ke
maalik hain aur kuch bhi badal sakte hain. **'Root' naam kyun?** Yeh naam
Linux/Unix operating system se aaya hai. Wahan 'root' woh user hota hai jiske
paas system par sabse zyada powers hoti hain, woh kisi bhi file ko delete,
modify ya access kar sakta hai. Android bhi Linux par based hai, isliye yahan
bhi 'Superuser' ko 'root' kehte hain. #### **Rooting ke Fayde (Advantages)** *
**Full Control & Customization:** Aap phone ke system files ko badal sakte hain,
boot animation change kar sakte hain, CPU ki speed control kar sakte hain. *
**Remove Bloatware:** Phone companies bahut saare faltu apps pehle se install
karke deti hain (bloatware) jo delete nahi hote. Root karne ke baad aap unhe
uninstall kar sakte hain, jisse phone ki speed aur battery life badhti hai. *
**Advanced Apps:** Kuch powerful apps (jaise Titanium Backup, AdAway ad blocker,
pentesting tools) sirf rooted phones par hi chalti hain. * **Custom ROMs:** Aap
phone ka poora operating system badal kar ek naya, modified version (jaise
LineageOS, Pixel Experience) daal sakte hain, jisse aapko naye features aur
latest Android updates milte hain. #### **Rooting ke Nuksaan (Disadvantages)** *
**Bricking:** Agar rooting process ke dauran light chali gayi ya aapne galat
file flash kar di, to aapka phone "brick" ho sakta hai, yaani woh ek bekaar
dabba ban jaayega jo on nahi hoga. * **Security Risk:** Root karne se Android ka
security model kamzor ho jaata hai. Koi bhi malicious app aapse root permission
maang kar aapke phone ka poora data chura sakti hai ya use control kar sakti
hai. Isliye banking apps, Google Pay jaise apps rooted phones par chalne se mana
kar deti hain. * **Loss of Warranty:** Phone ko root karte hi uski official
warranty khatam ho jaati hai. Agar phone mein koi hardware problem aati hai, to
company use theek nahi karegi. #### **BEGINNER GAP FIX: Rooting Process
Step-by-Step** **Popular Devices Ke Liye Basic Rooting Method (OnePlus
Example):** 1. **Unlock Bootloader:** `fastboot oem unlock` (Warning: Data erase
hoga, backup lo!) 2. **TWRP Recovery Flash:** TWRP img download karo, phir
`fastboot flash recovery twrp.img` 3. **Magisk Install:** Magisk ZIP download
karo, TWRP se flash karo. **Warning:** Pehle data backup lo, bricking risk
10-20% hai. **Beginner Tip:** Practice ke liye emulator use karo, real phone
risky hai. **Custom ROM Install Kaise Karein:** 1. LineageOS ROM download karo
(device-specific). 2. TWRP se: Wipe > Install ROM ZIP. 3. Reboot. | Feature |
Stock OS | Custom ROM | |---------|----------|------------| | Updates | Slow |
Fast | | Bloatware | Yes | No | | Customization | Limited | Full | | Risk | Low
| Medium | --- ### **Lecture 9 & 10: Proxy Setup & Certificate Installation
(Burp Suite) - Step-by-Step Guide** Is process ka maqsad hai aapke phone ke
saare internet traffic ko aapke computer par chal rahe Burp Suite se hokar
guzaarna, taaki aap us traffic ko dekh sakein aur usmein badlav kar sakein.
**Zaroori Cheezein:** 1. Aapka computer aur Android phone **ek hi WiFi network**
se connected hone chahiye. 2. Aapke computer par Burp Suite install aur running
hona chahiye. #### **BEGINNER GAP FIX: Burp Suite Installation** **Burp Suite
Kaise Install Karein:** 1. Download:
`https://portswigger.net/burp/communitydownload` (Free Community Edition). 2.
Java 8+ install hona chahiye. Check: `java -version` 3. Run: `java -jar
burpsuite_community.jar` 4. Error: "Java nahi hai?" Oracle site se JDK download
karo. #### **Step 1: Apne Computer ka IP Address Pata Karein** * **Windows
par:** Command Prompt (cmd) kholen aur type karein `ipconfig`. Aapko "Wireless
LAN adapter Wi-Fi" section mein "IPv4 Address" dikhega. Yeh kuch aisa hoga:
`192.168.1.7`. * **Linux/Mac par:** Terminal kholen aur type karein `ifconfig`
ya `ip a`. Aapko `wlan0` ya `en0` section mein `inet` ke aage IP address
dikhega. #### **Step 2: Burp Suite ko Configure Karein** 1. Burp Suite kholen.
2. **Proxy** tab -> **Options** sub-tab par jaayein. 3. "Proxy Listeners"
section mein dekhein. By default, ek entry `127.0.0.1:8080` hogi. 4. Use select
karke **Edit** par click karein. 5. "Bind to port" `8080` hi rehne dein. 6.
"Bind to address" mein **"All interfaces"** select karein aur **OK** par click
karein. Isse Burp Suite aapke computer ke local IP address par bhi traffic
sunega. #### **Step 3: Android Phone mein Proxy Setup Karein** 1. Phone ki
**Settings -> Wi-Fi** mein jaayein. 2. Aap jis WiFi network se connected hain
(e.g., "yoyo"), uske naam par **daba kar rakhein (long press)**. 3. Ek menu
aayega, usmein **Modify Network** (ya gear ⚙️ icon) par click karein. 4.
**Advanced options** ko expand karein. 5. **Proxy** setting ko `None` se badal
kar **`Manual`** karein. 6. Ab aapko do fields dikhengi: * **Proxy hostname:**
Yahan apne computer ka IP address daalein jo aapne Step 1 mein pata kiya tha
(e.g., `192.168.1.7`). * **Proxy port:** Yahan `8080` daalein. 7. **Save** par
click karein. Ab aapke phone ka HTTP/S traffic Burp Suite ke zariye jaana shuru
ho gaya hai. Lekin HTTPS traffic ko dekhne ke liye agla step zaroori hai. ####
**Step 4: Burp Suite ka CA Certificate Phone mein Install Karein** 1. Phone par
koi bhi browser kholen (e.g., Chrome). 2. URL bar mein type karein `http://burp`
aur enter karein. 3. Ek page khulega. Usmein upar right corner mein **"CA
Certificate"** link par click karein. Ek file download hogi jiska naam
`cacert.der` hoga. 4. Apne phone ka **File Manager** kholen aur **Downloads**
folder mein jaayein. 5. Download ki gayi `cacert.der` file ko rename karein.
Uska extension `.der` se badal kar **`.crt`** kar dein. Final naam hoga:
**`cacert.crt`**. 6. Ab phone ki **Settings -> Security** (ya "Biometrics and
security") mein jaayein. 7. **Other security settings -> Install from device
storage** (ya "Install a certificate") dhoondhein. 8. Apni **`cacert.crt`** file
ko select karein. 9. Phone aapse certificate ka naam poochega. Kuch bhi naam de
dein, jaise **"Burp CA"**. 10. "Credential use" mein **"VPN and apps"** select
karein aur **OK** par click karein. 11. Aapko phone ka PIN/Password daalne ke
liye kaha jaa sakta hai. **Ho Gaya!** Ab aap apne phone par koi bhi app ya
website kholenge to aapko uska saara HTTPS traffic Burp Suite ke **Proxy -> HTTP
history** tab mein dikhai dega. #### **BEGINNER GAP FIX: Android Version
Differences & Troubleshooting** **Certificate Install - Version-Based Guide:** |
Android Version | Install Path | Extra Step |
|-----------------|--------------|------------| | 7-9 | Settings > Security >
Install from SD | No PIN needed | | 10+ | Biometrics > Advanced > Encryption &
credentials | PIN daalo | | 11+ | Security > Encryption & credentials > Install
a certificate | User certificate select | **Test Command:** Browser mein
`https://example.com` open karo > Burp mein request dekho. **Common Issues:** -
**HTTPS traffic nahi dikh raha?** Certificate trust na hua. Check: Settings >
Trusted credentials > User tab. - **Connection failed error?** Proxy IP/port
double-check karo. - **App crash ho raha?** Certificate pinning hai, Lecture 15
dekho. --- ### **Lecture 11-13: APK File Structure aur AndroidManifest.xml -
Detail Mein** **APK (Android Package Kit) Kya Hai?** Yeh ek `.zip` file jaisi
hai jiske andar ek Android app ko install karne aur chalane ke liye zaroori
sabhi files hoti hain. **APK ke Andar Kya Hota Hai?** Agar aap ek `.apk` file ko
`.zip` mein rename karke extract karenge, to aapko yeh cheezein milengi: ####
**BEGINNER GAP FIX: APK Extract Kaise Karein** **Cross-Platform Commands:**
```bash # Windows: 7-Zip use karo, right-click > Extract Here # Ya command: 7z x
your-app.apk -o extracted_folder # Mac/Linux: Terminal mein unzip your-app.apk
-d extracted_folder ``` **Security Tip:** Online tools mat use karo - security
risk hai! * **`classes.dex`:** Yeh sabse important file hai. Iske andar aapke
app ka saara Java/Kotlin code compiled form mein hota hai jise Android ka Dalvik
Virtual Machine (DVM) samajhta hai. * **`res/` folder:** Iske andar app ke saare
resources hote hain jaise images, icons, UI layout files (`.xml`), text strings
etc. * **`lib/` folder:** Iske andar native libraries (.so files) hoti hain, jo
C/C++ mein likhe gaye code ke liye hoti hain. * **`assets/` folder:** Iske andar
developer raw files (jaise fonts, databases) rakh sakta hai. *
**`AndroidManifest.xml`:** App ka "kundli" ya blueprint. * **`META-INF/`
folder:** Iske andar app ka signature hota hai, jo verify karta hai ki app
original hai aur uske saath chhedchhad nahi hui hai. ####
**`AndroidManifest.xml` - App ka Dil** Yeh ek XML file hai jo Android Operating
System ko aapke app ke baare mein sab kuch batati hai. Iske bina app install hi
nahi ho sakti. **Iske Mukhya Elements:** * **`<manifest
  >`:** Root element. * **`<application
    >`:** Iske andar app ke components define hote hain. * **`<uses-permission
      >`:** Yeh OS ko batata hai ki aapke app ko kaun si permissions chahiye. *
      **Example:** `<uses-permission
        android:name="android.permission.INTERNET"
      />` ka matlab hai ki app ko internet access karne ki permission chahiye.
      Agar aap yeh nahi denge, to app internet nahi chala paayega. *
      **`<activity
        >`:** Yeh app ki har ek screen (UI) ko represent karta hai. *
        **Example:** Jab aap WhatsApp kholte hain, to jo chat list dikhti hai
        woh ek activity hai. Jab aap kisi chat par click karte hain, to ek nayi
        activity khulti hai. Manifest mein yeh sab define hota hai. *
        **`<service
          >`:** Yeh background mein chalne wale process ko define karta hai,
          jinka koi UI nahi hota. * **Example:** Music player app band karne ke
          baad bhi gaana bajta rehta hai. Yeh ek service ke kaaran hota hai. *
          **`<receiver
            >` (Broadcast Receiver):** Yeh system-wide events (jaise phone boot
            hua, message aaya) ko sunta hai. * **Example:** Alarm app ka
            receiver phone ke boot hote hi active ho jaata hai taaki alarm time
            par baj sake. * **`<provider
              >` (Content Provider):** Yeh ek app ke data ko doosre apps ke
              saath securely share karne ka tareeka hai. * **Example:** Contact
              app ka provider WhatsApp ko aapke contacts read karne ki
              permission deta hai. ---
              =============================================================
              Samajh gaya\! Aapko har concept ke liye practical code examples
              aur commands chahiye, taaki ek beginner ko bhi sab kuch bilkul
              clear ho jaaye. Chaliye, is detailed journey ko aage badhaate
              hain. Pichli baar humne `AndroidManifest.xml` par baat khatm ki
              thi. Aaiye wahin se code example ke saath shuru karte hain. -----
              ### **Recap: `AndroidManifest.xml` - With a Real Code Example**
              Yeh ek basic `AndroidManifest.xml` file ka structure hai. Isse
              aapko samajh aayega ki jo elements humne discuss kiye the, woh
              asal mein kaise dikhte hain. ```xml
              <?xml version="1.0" encoding="utf-8"?>
              <manifest
                xmlns:android="http://schemas.android.com/apk/res/android"
                package="com.example.secureapp"
              >
                <uses-permission android:name="android.permission.INTERNET" />
                <uses-permission
                  android:name="android.permission.READ_CONTACTS"
                />

                <application
                  android:allowBackup="true"
                  android:icon="@mipmap/ic_launcher"
                  android:label="@string/app_name"
                  android:theme="@style/AppTheme"
                >
                  <activity android:name=".MainActivity">
                    <intent-filter>
                      <action android:name="android.intent.action.MAIN" />
                      <category
                        android:name="android.intent.category.LAUNCHER"
                      />
                    </intent-filter>
                  </activity>

                  <activity android:name=".LoginActivity" />

                  <service android:name=".BackgroundMusicService" />
                </application>
              </manifest>
              ``` **Code ka Matlab:** * **`<uses-permission
                >`:** Hum Android OS se Internet aur Contacts padhne ki
                permission maang rahe hain. Pentesting mein hum check karte hain
                ki app zaroorat se zyada permissions to nahi maang raha. *
                **`<application
                  >`:** Iske andar app ki general information hai, jaise uska
                  icon (`ic_launcher`), naam (`app_name`), aur theme.
                  `android:allowBackup="true"` ek security risk ho sakta hai,
                  kyunki isse app ka data `adb backup` command se nikala jaa
                  sakta hai. * **`<activity android:name=".MainActivity"
                    >`:** Yeh app ki main screen hai. * **`<intent-filter
                      >`:** Iske andar `LAUNCHER` category batati hai ki yeh
                      activity app drawer mein dikhegi aur `MAIN` action batata
                      hai ki yahan se app shuru hoga. #### **BEGINNER GAP FIX:
                      Manifest Code Ko Test Kaise Karein** **Android Studio Mein
                      Run Karna:** 1. Android Studio open karo > New Project >
                      Empty Activity. 2. Yeh manifest code paste karo
                      `app/src/main/AndroidManifest.xml` mein. 3. Run on
                      emulator: Green play button click. 4. Output: App launch
                      hoga, main screen dikhegi. **Intent-Filter Ka Real Use:**
                      Yeh intent-filter se app launcher icon banega. Test:
                      Decompile ek real app (e.g., WhatsApp APK) aur dekho
                      kaunsi activity LAUNCHER hai. ----- ### **Lecture 14 & 16:
                      Reverse Engineering - APK ko Khol kar Dekhna
                      (Step-by-Step)** Reverse Engineering ka matlab hai "ulta
                      pahiya ghumaana". Hum ek ready-made app (APK) se uske
                      andar ka code (source code) nikalne ki koshish karte hain
                      taaki hum uski kamzoriyan dhoondh sakein. #### **BEGINNER
                      GAP FIX: Apktool Installation** **Apktool Kaise Install
                      Karein:** 1. Download:
                      `https://ibotpeaches.github.io/Apktool/install/` 2.
                      Windows: `apktool.jar` download karo, rename to
                      `apktool.bat`. 3. Linux/Mac: `brew install apktool` ya
                      manual install. 4. Test: `apktool --version` #### **Tool
                      1: Apktool (The Decompiler & Recompiler)** Yeh tool APK ko
                      khol kar uske andar ke resources (images, XML files) aur
                      code ko **Smali** format mein nikalta hai. Smali ek aisi
                      language hai jise insaan padh sakte hain aur modify bhi
                      kar sakte hain. **Step 1: Decompile karna (APK ko
                      kholna)** Apne terminal ya command prompt mein yeh command
                      chalayein: ```bash # 'd' ka matlab hai decompile apktool d
                      your-app-name.apk ``` Is command ko chalane ke baad, usi
                      jagah ek naya folder ban jaayega jiska naam
                      `your-app-name` hoga. Is folder ke andar aapko yeh
                      cheezein milengi: * `AndroidManifest.xml` (insaan padh
                      sake, is format mein) * `res/` (saare XML layouts, images
                      etc.) * `smali/` (yahan app ka poora code Smali files mein
                      hoga) **Step 2: Recompile karna (Badlav karke wapas APK
                      banana)** Maan lijiye aapne Smali code mein kuch badlav
                      kiye. Ab aapko wapas APK banana hai. ```bash # 'b' ka
                      matlab hai build, '-o' matlab output file ka naam apktool
                      b your-app-name -o modified-app.apk ``` Isse
                      `modified-app.apk` naam ki ek nayi APK file ban jaayegi.
                      **Note:** Yeh APK abhi signed nahi hai, install karne se
                      pehle ise sign karna padega. #### **BEGINNER GAP FIX: APK
                      Signing** **Modified APK Ko Sign Kaise Karein:** ```bash #
                      Pehle keystore banao (ek baar) keytool -genkey -v
                      -keystore my-keystore.jks -keyalg RSA -keysize 2048
                      -validity 10000 -alias my-key # APK sign karo apksigner
                      sign --ks my-keystore.jks modified-app.apk # Install karo
                      adb install modified-app.apk ``` #### **Tool 2 & 3:
                      dex2jar aur JD-GUI (Java Code Dekhne ke liye)** Hum Smali
                      code padhne mein expert nahi hain. Humein Java code dekhna
                      hai jo aasan ho. Uske liye yeh process hai: ####
                      **BEGINNER GAP FIX: dex2jar & JD-GUI Setup** **dex2jar
                      Install:** 1. Download: GitHub se `dex2jar` search karo,
                      latest release download. 2. Unzip karo. 3. Windows:
                      `d2j-dex2jar.bat` use karo. Linux/Mac: `d2j-dex2jar.sh`
                      **JD-GUI Install:** 1. Download: `http://jd.benow.ca/` se
                      JAR download. 2. Run: `java -jar jd-gui.jar` **Step 1:
                      dex2jar se .jar file banana** dex2jar tool APK ke andar ki
                      `classes.dex` file ko ek `.jar` file mein convert karta
                      hai. Jar file ke andar compiled Java code (.class files)
                      hoti hain. ```bash # Yeh script Linux/Mac par chalti hai.
                      Windows ke liye d2j-dex2jar.bat hoga. # Yeh command seedhe
                      APK file par kaam karti hai. d2j-dex2jar.sh
                      your-app-name.apk ``` Isse `your-app-name-dex2jar.jar`
                      naam ki ek file ban jaayegi. **Step 2: JD-GUI se Java Code
                      dekhna** JD-GUI ek graphical tool hai. Ise kholen. 1.
                      **File -\> Open File...** par click karein. 2. Abhi jo
                      `.jar` file banayi hai, use select karein. 3. Boom\! Aapko
                      left side mein app ka poora package structure dikhega aur
                      right side mein aap Java code padh sakte hain. **Expected
                      Output:** Classes tree left mein, Java code right mein.
                      Click karne par code readable format mein dikhega.
                      **Example Vulnerability jo aapko mil sakti hai:** Aap code
                      browse kar rahe hain aur aapko aisi line dikhti hai:
                      ```java // inside LoginActivity.java public class
                      LoginActivity extends AppCompatActivity { private void
                      checkCredentials(String username, String password) { // !!
                      BAHUT BADI GADBAD !! - Hardcoded Password if
                      (username.equals("admin") &&
                      password.equals("P@ssw0rd123")) { // Login successful
                      startActivity(new Intent(this, DashboardActivity.class));
                      } else { // Login failed Toast.makeText(this, "Invalid
                      credentials", Toast.LENGTH_SHORT).show(); } } } ``` Yahan
                      password code ke andar hi likha hua hai\! Yeh ek
                      **hardcoded credentials** vulnerability hai. ----- ###
                      **Lecture 17: Static vs. Dynamic Analysis - The Detective
                      Work** #### **Static Analysis 📝 (Code ko padhna)** Yeh
                      "crime scene" par clues dhoondhne jaisa hai, bina criminal
                      (app) ko harkat karte dekhe. Hum decompile kiye gaye code
                      ko padhte hain aur kamzoriyan dhoondhte hain. * **Hum Kya
                      Dhoondhte Hain?** * Hardcoded secrets (API keys,
                      passwords) jaise upar example mein dekha. * Insecure data
                      storage (kya data plain text mein save ho raha hai?). *
                      Zaroorat se zyada permissions in `AndroidManifest.xml`. *
                      Weak encryption algorithms. * **Tool Example: MobSF
                      (Mobile Security Framework)** MobSF ek automated tool hai.
                      Aap usmein apni APK upload karte hain, aur woh
                      automatically static analysis karke aapko ek detailed
                      report bana kar de deta hai. #### **BEGINNER GAP FIX:
                      MobSF Setup** **MobSF Install (Docker Method):** ```bash
                      docker pull opensecurity/mobile-security-framework-mobsf
                      docker run -it -p 8000:8000
                      opensecurity/mobile-security-framework-mobsf:latest ```
                      **Use:** Browser mein `http://localhost:8000` open, APK
                      upload. **Cross-ref:** Frida details Lecture 15 mein. ####
                      **Dynamic Analysis 🏃‍♂️ (App ko chala kar dekhna)** Yeh
                      "criminal" (app) ka peecha karne jaisa hai. Hum app ko ek
                      device par chalate hain aur uske behavior ko live monitor
                      karte hain. * **Hum Kya Karte Hain?** * **Traffic
                      Interception (Burp Suite):** Hum dekhte hain ki app server
                      se communicate karte waqt data ko encrypt kar raha hai ya
                      plain text mein bhej raha hai. * **Example:** Aapne app
                      mein login kiya aur Burp Suite mein dekha ki aisi request
                      jaa rahi hai: `POST /login HTTP/1.1` `Host:
                      api.example.com` `{"username":"test",
                      "password":"mypassword123"}`. Yahan password plain text
                      mein ja raha hai, yeh ek **Insecure Communication**
                      vulnerability hai. * **Runtime Manipulation
                      (Frida/Objection):** Hum app ke chalte waqt uske functions
                      ko badalne ki koshish karte hain. * **File System Check:**
                      Hum dekhte hain ki app chalne ke baad phone ki memory mein
                      kaun si files bana raha hai aur kya un files mein
                      sensitive data hai. ----- ### **Lecture 15: Certificate
                      Pinning aur Bypass - The Master Key** **Certificate
                      Pinning Kya Hai?** Aasan bhasha mein: App kehta hai, "Main
                      sirf usi server se baat karunga jiska certificate a-b-c
                      jaisa dikhta hai, jo mere andar pehle se save hai. Agar
                      koi aur (jaise Burp Suite) beech mein d-e-f certificate
                      dikhayega, to main connection tod dunga." Yeh
                      Man-in-the-Middle (MITM) attacks ko rokne ke liye hota
                      hai. **Bypass Kaise Karein?** #### **Method 1: Frida ka
                      istemaal (Dynamic Bypass)** Frida ek "magician" hai jo
                      chalte hue app ke code mein jaakar uske functions ko badal
                      sakta hai. Hum Frida ko bolenge ki "Hey, app ke andar jo
                      certificate check karne wala function hai, use bypass kar
                      do aur hamesha 'sab theek hai' (true) return karwao." ####
                      **BEGINNER GAP FIX: Frida Installation** **Frida Setup:**
                      ```bash # Computer par pip install frida-tools # Device
                      par Frida server push # Download frida-server from GitHub
                      (match version with frida-tools) adb push frida-server
                      /data/local/tmp/ adb shell "chmod 755
                      /data/local/tmp/frida-server" adb shell
                      "/data/local/tmp/frida-server &" ``` **Step 1:** Ek
                      ready-made Frida script download karein (internet par
                      "frida ssl pinning bypass script" search karne se mil
                      jaayegi). **Step 2:** Yeh command terminal mein chalayein:
                      ```bash # -U: USB se connected device use karo # -f
                      com.example.app: is app package ko start karo # -l
                      universal-ssl-bypass.js: yeh script app mein inject karo
                      frida -U -f com.example.app -l universal-ssl-bypass.js
                      --no-paus ``` Yeh command app ko start karegi aur usmein
                      SSL pinning check ko disable kar degi. Ab aap Burp Suite
                      se traffic dekh payenge\! #### **Method 2: Apktool se
                      Smali Patching (Manual Bypass)** Yeh thoda advanced hai
                      par bahut powerful hai. 1. **Decompile:** `apktool d
                      pinned-app.apk` 2. **Dhoondhein:** `smali/` folder ke
                      andar `.smali` files mein `TrustManager`,
                      `checkServerTrusted`, `pinning` jaise shabdon ko search
                      karein. **Search Command:** ```bash grep -r
                      "checkServerTrusted" smali/ grep -r "TrustManager" smali/
                      ``` 3. **Badlein:** Aapko aam taur par ek function milega
                      jo certificate check karta hai. Aapko us function ke logic
                      ko badalna hai taaki woh hamesha sahi (true) result de. *
                      **Original Smali Code (example):** ```smali .method public
                      checkServerTrusted([Ljava/security/cert/X509Certificate;Ljava/lang/String;)V
                      .locals 1 # ... yahan bahut saara checking logic hoga ...
                      if-nez v0, :cond_0 # Agar check fail hua (v0 zero nahi
                      hai) to jump karo return-void # Check pass hua :cond_0 #
                      ... yahan exception throw karne ka code hoga ... .end
                      method ``` * **Modified Smali Code (example):** ```smali
                      .method public
                      checkServerTrusted([Ljava/security/cert/X509Certificate;Ljava/lang/String;)V
                      .locals 1 # Humne saara logic hata diya return-void #
                      Seedha return kar do, matlab check hamesha pass .end
                      method ``` 4. **Recompile & Sign:** `apktool b pinned-app`
                      se recompile karein aur fir use sign karke install karein.
                      Aage ke lectures (OWASP Top 10, Advanced Tools, Ransomware
                      Case Study) ke liye bhi isi tarah ka detailed, code-filled
                      explanation chahiye to zaroor batayein\!
                      =============================================================
                      Bilkul\! Chaliye is advanced guide ko aage badhaate hain
                      aur baaki ke topics ko bhi usi tarah detail mein, code
                      examples ke saath F.B.I. agent ki tarah investigate karte
                      hain. 🕵️‍♂️ ----- ### **Lecture 20: OWASP Top 10 Mobile
                      Vulnerabilities - The "Most Wanted" List** Soch lijiye ki
                      OWASP ek global "detective agency" hai jo cyber criminals
                      ke sabse common attack techniques ki ek "Most Wanted" list
                      jaari karti hai. Yeh list hum jaise security testers ke
                      liye ek checklist ka kaam karti hai. #### **M1: Improper
                      Platform Usage** * **Kya Hai?** Android ya iOS ke security
                      features ko galat tareeke se use karna ya use hi na karna.
                      * **Analogy:** Aapke paas ek high-tech digital lock
                      (`TouchID/FaceID`) hai, lekin aap uski jagah ek saal
                      purana, kamzor password use kar rahe hain. * **Example
                      (Code mein galti):** `AndroidManifest.xml` mein ek
                      activity ko `android:exported="true"` set kar dena bina
                      aache se protect kiye. Iska matlab hai ki koi bhi doosri
                      app us activity ko seedhe-seedhe launch kar sakti hai,
                      bhale hi woh app ka internal, sensitive part ho. ```xml
                      <activity
                        android:name=".AdminPanelActivity"
                        android:exported="true"
                      />
                      ``` #### **M2: Insecure Data Storage** * **Kya Hai?**
                      Sensitive data (username, password, credit card info) ko
                      phone ki memory (SD Card/Internal Storage) mein bina
                      encryption ke, plain text mein save kar dena. *
                      **Analogy:** Aap apne ATM ka PIN ek tissue paper par likh
                      kar apne wallet mein rakh rahe hain. Agar wallet chori ho
                      gaya, to sab gaya. * **Example (Kaise pakdein):** Rooted
                      device par, app ke data directory
                      (`/data/data/com.example.app/`) mein jaakar files ko check
                      karein. ```bash # ADB shell se app ke folder mein jaana
                      adb shell su cd /data/data/com.example.app/shared_prefs/ #
                      User details wali file ko padhna cat UserPrefs.xml ```
                      Agar output mein aisa kuch dikhta hai, to yeh
                      vulnerability hai: ```xml
                      <string name="username">testuser</string>
                      <string name="password">Password123</string>
                      ``` #### **M3: Insecure Communication** * **Kya Hai?** App
                      aur server ke beech data ko bina encryption ke (`HTTP`)
                      bhejna. Koi bhi beech mein (Man-in-the-Middle) us data ko
                      padh sakta hai. * **Analogy:** Aap apne dost ko ek secret
                      message postcard par likh kar bhej rahe hain. Postman se
                      lekar koi bhi usse padh sakta hai. * **Example (Burp Suite
                      mein pakadna):** Jab aap app mein login karte hain, to
                      Burp Suite mein aisi request dikhegi: ```http POST
                      /api/login HTTP/1.1 Host: insecure-api.com {"user":"test",
                      "pass":"mysecretpass"} ``` Yahan `HTTP` use ho raha hai
                      aur password plain text mein hai. Yeh M3 vulnerability
                      hai. Sahi tareeka `HTTPS` use karna hai. #### **M4:
                      Insecure Authentication** * **Kya Hai?** User ko aache se
                      identify na karna ya session management mein kamzori. *
                      **Analogy:** Ek building ka guard aapse bas aapka naam
                      poochta hai aur andar jaane deta hai, koi ID card check
                      nahi karta. Koi bhi aapka naam lekar andar jaa sakta hai.
                      * **Example:** Ek app login ke baad aapko ek session ID
                      deta hai. Agar woh session ID aasaani se guess kiya jaa
                      sakta hai (e.g., `1`, `2`, `3`...), to attacker doosre
                      users ke account mein login kar sakta hai. #### **M5:
                      Insufficient Cryptography** * **Kya Hai?** Encryption to
                      use karna, lekin ya to bahut kamzor algorithm use karna ya
                      use galat tareeke se implement karna. * **Analogy:** Aapne
                      apne secret diary par taala to lagaya hai, par woh taala
                      bachhon ke khilone wala hai jo ek hairpin se khul jaata
                      hai. * **Example (Code mein galti):** ```java // MD5 ek
                      bahut purana aur kamzor hashing algorithm hai // Ise
                      aasaani se crack kiya jaa sakta hai MessageDigest md =
                      MessageDigest.getInstance("MD5"); byte[] hashedPassword =
                      md.digest(password.getBytes()); ``` Yahan `MD5` ka
                      istemaal ek M5 vulnerability hai. Iski jagah `SHA-256`
                      with salt ya `bcrypt` use karna chahiye. #### **M6:
                      Insecure Authorization** * **Kya Hai?** Authentication
                      (Aap kaun hain?) ke baad, Authorization (Aap kya kar sakte
                      hain?) ko aache se check na karna. * **Analogy:** Aap ek
                      company ke employee hain (authenticated), lekin aapko CEO
                      ke office (unauthorized) mein jaane ki ijaazat mil jaati
                      hai. * **Example:** Ek app mein normal user (ID `101`) aur
                      admin user (ID `1`) hai. Normal user sirf apna profile
                      dekh sakta hai (`/api/users/101`). Lekin agar woh request
                      ko change karke `/api/users/1` bhejta hai aur server admin
                      ka data de deta hai, to yeh Insecure Authorization hai.
                      Ise **IDOR (Insecure Direct Object Reference)** kehte
                      hain. #### **M7: Client Code Quality** * **Kya Hai?** Code
                      likhne mein aisi galtiyan karna jo memory corruption bugs
                      (jaise buffer overflows) paida karein. Yeh C/C++ code
                      (`lib/` folder mein `.so` files) mein zyada hota hai. *
                      **Analogy:** Aap ek paani ki tanki mein hadd se zyada
                      paani bhar rahe hain, jisse woh phat jaati hai aur paani
                      har jagah fail jaata hai. * **Example:** Yeh aam taur par
                      low-level code mein hota hai. Ek pentester iske liye
                      `Frida` jaise tools se functions ko fuzz kar sakta hai
                      (unmein random data bhejkar) yeh dekhne ke liye ki app
                      crash hoti hai ya nahi. #### **BEGINNER GAP FIX: M7
                      Detection Tool** **Fuzzing Tool:** AFL (American Fuzzy
                      Lop) - random inputs bhejkar crash check. **Simple
                      Explanation:** Fuzzing = App ko random/unexpected data
                      dena crash dhoondhne ke liye. #### **M8: Code Tampering**
                      * **Kya Hai?** App mein aisi security na hona ki attacker
                      uske code ko modify kar sake, recompile karke chala sake.
                      * **Analogy:** Aapne ek game banaya jismein ek cheez ₹100
                      ki hai. Attacker ne game ki file ko modify karke uski
                      keemat ₹1 kar di. * **Example:** Iska classic example hai
                      Smali patching, jaisa humne SSL Pinning bypass mein dekha.
                      Humne code ko tamper karke security check ko hi hata diya.
                      Apps ko isse bachne ke liye **Root Detection** aur
                      **Tamper Detection** mechanisms use karne chahiye. ####
                      **M9: Reverse Engineering** * **Kya Hai?** Attacker ka app
                      ko decompile karke uske business logic, algorithms, ya
                      secrets ko samajh paana. * **Analogy:** Coca-Cola ki
                      secret recipe unki tijori mein band hai. Reverse
                      engineering us tijori ko tod kar recipe nikaalne jaisa
                      hai. * **Example:** Humne `dex2jar` aur `JD-GUI` ka
                      istemaal karke jo hardcoded password dhoondha tha, woh M9
                      ka hi natija tha. Isse bachne ke liye developers **Code
                      Obfuscation** (code ko ajeeb-o-gareeb, na samajh aane wale
                      format mein badalna) ka istemaal karte hain. #### **M10:
                      Extraneous Functionality** * **Kya Hai?** App ke final
                      version mein testing ya debug ke liye banaye gaye hidden
                      features ka reh jaana. * **Analogy:** Hotel ka room banate
                      waqt builder ne ek secret darwaza chhod diya jiske baare
                      mein sirf use pata hai. * **Example:** Ek developer ne
                      testing ke liye ek "secret" screen banayi jahan se woh
                      kisi bhi user ki tarah login kar sakta hai. Final app mein
                      woh is screen ko hatana bhool gaya. Attacker `adb`
                      commands ya `Drozer` jaise tool se us hidden screen ko
                      dhoondh kar launch kar sakta hai. ----- ### **Advanced
                      Tools: Bytecode-viewer aur Objection - The Swiss Army
                      Knife & The Spy Gadget** #### **Bytecode-viewer: The Swiss
                      Army Knife 🧰** Yeh tool ek "one-man army" hai kyunki iske
                      andar kai saare alag-alag decompilers (JADX, JD-GUI,
                      Procyon, Fernflower) aur tools (Apktool) ek saath mil
                      jaate hain. #### **BEGINNER GAP FIX: Bytecode-viewer
                      Installation** **Download & Run:** 1. GitHub:
                      `https://github.com/Konloch/bytecode-viewer` 2. Download
                      latest release JAR. 3. Run: `java -jar
                      Bytecode-Viewer-2.11.2.jar` **Ise Kyun Use Karein?**
                      Kabhi-kabhi ek decompiler code ko theek se decompile nahi
                      kar paata (khaas kar jab code obfuscated ho).
                      Bytecode-viewer mein aap ek click se alag-alag decompilers
                      try kar sakte hain. **Step-by-Step Usage:** 1.
                      Bytecode-viewer ko open karein. 2. **File -\> Add** par
                      click karke apni `.apk` file select karein. Tool use
                      process karega. 3. Left side mein aapko file tree dikhega.
                      Right side mein code. 4. Top mein **View** menu par click
                      karein. Yahan aapko **Pane 1 (Java Decompiler)** aur
                      **Pane 2 (Bytecode)** dikhega. 5. Aap **Pane 1** ke liye
                      alag decompiler (e.g., JADX) aur **Pane 2** ke liye
                      **Editable Smali** select kar sakte hain. Ab aap ek hi
                      screen par Java code aur uske corresponding Smali code ko
                      side-by-side compare kar sakte hain. Yeh Smali patching ke
                      liye bahut-bahut useful hai\! #### **Objection: The
                      Dynamic Spy Gadget 🕵️** Objection, Frida framework ke upar
                      bana ek powerful tool hai jisse mobile app pentesting
                      bahut aasan ho jaati hai. **Step-by-Step Walkthrough:**
                      **Step 1: App ko Patch karna (Usmein apna spy agent
                      daalna)** Humein pehle app ke andar Frida ka "gadget"
                      inject karna hoga. ```bash # --source: Original APK ka
                      naam # --gadget-version: Frida gadget ka version. Latest
                      version use karna behtar hai. objection patchapk --source
                      real-app.apk --gadget-version 15.2.2 ``` **Version
                      Check:** ```bash frida --version # Latest version check
                      pip install --upgrade objection # Update karo ``` Yeh
                      command parde ke peeche yeh sab karti hai: * Apktool se
                      APK ko decompile karti hai. * Frida ki library
                      (`libfrida-gadget.so`) uske `lib/` folder mein daalti hai.
                      * Smali code ko modify karti hai taaki app shuru hote hi
                      Frida ki library load ho. * Apktool se app ko recompile
                      karti hai. * Use apne key se sign kar deti hai. Aapko
                      `real-app.objection.apk` naam ki ek nayi file milegi. Ise
                      apne device par install karein (`adb install
                      real-app.objection.apk`). **Step 2: App se Connect karna**
                      Patched app ko device par open karein. Woh splash screen
                      par ruk jaayegi. Ab apne computer ke terminal se connect
                      karein: ```bash objection explore ``` Agar sab theek raha
                      to aapka terminal app ke andar command bhejne ke liye
                      ready ho jaayega, aur app aage badh jaayegi. **Step 3:
                      Jaasoosi Shuru\! (Hooking a Method)** Maan lijiye humein
                      ek class `com.example.secureapp.LoginChecker` ke
                      `checkPassword` method ko monitor karna hai. ```bash #
                      'watch' method ko monitor karo,
                      'com.example.secureapp.LoginChecker.checkPassword' #
                      --dump-args: method mein kya arguments pass hue, woh
                      dikhao # --dump-return: method ne kya value return ki, woh
                      dikhao # --dump-backtrace: is method ko kisne call kiya,
                      woh call stack dikhao android hooking watch class_method
                      com.example.secureapp.LoginChecker.checkPassword
                      --dump-args --dump-return --dump-backtrace ``` Ab jab bhi
                      aap app mein password daalenge, aapke terminal par live
                      output aayega: ``` (agent) [12345] Arguments: (agent)
                      [12345] arg0: "MySecretPassword123" ... (agent) [12345]
                      Return Value: (agent) [12345] true ``` **Expected Output
                      Explanation:** Terminal mein args print honge (password
                      visible), return value true/false dikhega. Aapne chalte
                      hue app ke andar se live password nikaal liya\! Objection
                      se aap SSL pinning bypass, root detection bypass, aur
                      bahut kuch kar sakte hain. ----- ### **Case Study:
                      SimpleLocker Ransomware - Defeating the Villain 🦸** Yeh
                      ek real-world mission hai jahan hum ek ransomware ko
                      reverse engineer karke uske "changul" se files ko aazad
                      karayenge. **Step 1: The Mission & Reconnaissance** *
                      **Goal:** SimpleLocker ransomware ne phone ki files ko
                      encrypt kar diya hai. Humein uske code se decryption key
                      nikaal kar ek tool banana hai jo files ko decrypt kar
                      sake. * **Dynamic Analysis:** Hum pehle `simplelocker.apk`
                      ko ek emulator par install karte hain (`adb install
                      simplelocker.apk`). Hum dekhte hain ki woh humari images
                      ko `.enc` extension se encrypt kar deta hai aur paise
                      maangne wali ek screen dikhata hai. **Step 2: The
                      Investigation (Static Analysis)** * Hum `apktool` use
                      karte hain, par woh error deta hai. Iska matlab attacker
                      ne app ko protect karne ki koshish ki hai. No problem\!
                      Hum Plan B use karenge: `Enjarify` (dex2jar ka
                      alternative) aur `JD-GUI`. #### **BEGINNER GAP FIX:
                      Enjarify Tool** **Enjarify Install & Use:** ```bash pip
                      install enjarify enjarify simplelocker.apk -o output.jar
                      ``` **Kya Hai:** dex2jar ka better alternative, obfuscated
                      APKs ke liye. * Hum decompile kiye gaye Java code ko
                      padhna shuru karte hain. Hum `password`, `key`, `encrypt`,
                      `AES` jaise keywords search karte hain. * Humein
                      `com.simplelocker.Constants.class` naam ki ek file milti
                      hai. Iske andar sone ki khaan hai\! ```java //
                      Constants.java public class Constants { // ... doosra code
                      ... public static String CIPHER_PASSWORD =
                      "8318749216348127"; // BINGO! } ``` Humein encryption
                      password mil gaya\! * Ab humein decryption logic chahiye.
                      Hum `AESCrypt.class` file check karte hain. Uske andar
                      humein yeh function milta hai: ```java // AESCrypt.java
                      public static String decrypt(String password, String
                      encryptedData) throws GeneralSecurityException { // ...
                      complex decryption logic ... return new
                      String(decryptedBytes, "UTF-8"); } ``` **Step 3: Building
                      the Cure (The Decryption Tool)** * **Plan:** Hum Android
                      Studio mein ek naya, khali project banayenge. *
                      **Copy-Paste:** Hum `AESCrypt.class` file (jismein
                      `decrypt` function hai) ko apne naye project mein copy kar
                      lenge. * **The Main Logic:** Hum apne project ki
                      `MainActivity.java` mein ek button banayenge. Us button ke
                      click par yeh code chalega (yeh simplified code hai):
                      ```java // DecryptorApp -> MainActivity.java private
                      static final String DECRYPTION_KEY = "8318749216348127";
                      // Humara haath laga khazana public void
                      onDecryptButtonClick(View view) { // Phone ka external
                      storage (SD Card) ka path lo File sdCard =
                      Environment.getExternalStorageDirectory(); // SD Card mein
                      saari files ko check karo for (File file :
                      sdCard.listFiles()) { // Agar file ka naam .enc se khatm
                      hota hai if (file.getName().endsWith(".enc")) { try { //
                      Encrypted file ka data padho byte[] encryptedBytes =
                      readFile(file); String encryptedString =
                      Base64.encodeToString(encryptedBytes, ...); // Humare
                      'decrypt' function aur key se use decrypt karo String
                      decryptedContent = AESCrypt.decrypt(DECRYPTION_KEY,
                      encryptedString); // Original file (bina .enc ke) mein
                      decrypted data save kar do
                      saveFile(file.getPath().replace(".enc", ""),
                      decryptedContent.getBytes()); // Encrypted file delete kar
                      do file.delete(); } catch (Exception e) {
                      e.printStackTrace(); } } } Toast.makeText(this, "Files
                      Decrypted!", Toast.LENGTH_LONG).show(); } // Helper
                      functions private byte[] readFile(File file) throws
                      IOException { return Files.readAllBytes(file.toPath()); }
                      private void saveFile(String path, byte[] data) throws
                      IOException { Files.write(Paths.get(path), data); } ```
                      **Test:** Emulator par run karo, Toast message "Files
                      Decrypted!" dikhna chahiye. * **Permissions:** Humare
                      decryption tool ko files read/write karne ke liye
                      permission chahiye. Hum `AndroidManifest.xml` mein yeh
                      line add karenge: ```xml
                      <uses-permission
                        android:name="android.permission.WRITE_EXTERNAL_STORAGE"
                      />
                      ``` Ab hum is decryption app ko affected phone par install
                      karke chalayenge, aur woh saari encrypted files ko recover
                      kar dega. **Mission Accomplished\!** 🎉
                      =============================================================
                      ### **Lecture 21: Drozer - Automated Android App
                      Exploration & Attack Simulation (The Drone Scout)**
                      **Drozer Kya Hai?** Drozer ek open-source tool hai jo
                      Android apps ke security weaknesses ko automatically scan
                      aur simulate karta hai. Yeh ek "drone" ki tarah kaam karta
                      hai—woh app ke andar ghoomta hai, uske components (jaise
                      activities, services) ko map karta hai, aur real attacks
                      try karta hai bina app ko manually hack karne ki zaroorat
                      ke. Yeh dynamic analysis ke liye best hai, kyunki yeh app
                      ko runtime mein probe karta hai. **Kya Istemaal Hota
                      Hai?** Corporate pentesting mein, Drozer quick
                      reconnaissance ke liye use hota hai. Jaise, agar aapko 50
                      apps audit karne hain, to manual RE (Apktool jaise)
                      time-consuming hai. Drozer exported components dhoondhta
                      hai, permission abuses check karta hai, aur attacks
                      simulate karta hai (e.g., intent hijacking). Yeh OWASP M1
                      (Improper Platform Usage) aur M6 (Insecure Authorization)
                      ke liye perfect hai. Beginners ke liye yeh "low-hanging
                      fruits" pakadne ka tool hai, intermediates ke liye
                      scripting ke saath custom attacks. **Kyun Corporate Needs
                      Mein Zaroori?** Companies mein time tight hota hai—client
                      ko report mein "exported activities se data leak" jaisi
                      findings chahiye. Drozer se aap 10 minutes mein scan kar
                      sakte hain, proof-of-concept (PoC) generate kar sakte
                      hain. Agar use nahi kiya, to manual testing mein galtiyan
                      ho sakti hain, false negatives (missed vulns), aur report
                      incomplete. Result: Client unhappy, repeat work.
                      **Step-by-Step Setup aur Usage (Beginner se Intermediate
                      Level)** 1. **Installation:** - Python install hone
                      chahiye (3.x). Terminal mein: #### **BEGINNER GAP FIX:
                      Drozer Python Version** **Virtualenv Use (Recommended):**
                      ```bash python -m venv drozer-env source
                      drozer-env/bin/activate # Windows:
                      drozer-env\Scripts\activate pip install drozer ```
                      **Why:** Python version conflicts avoid karne ke liye.
                      ```bash pip install drozer ``` - Drozer agent APK download
                      karein (official GitHub se: `drozer-agent.apk`). Yeh agent
                      app device/emulator par install hota hai aur Drozer
                      console se connect karta hai. ```bash adb install
                      drozer-agent.apk ``` - Agent ko start karein: Device par
                      app open karein, "Start Service" par tap karein. Yeh
                      background mein chalta rahega. 2. **Connect Karna:** -
                      Terminal se Drozer console shuru karein: ```bash drozer
                      console connect ``` - Yeh aapko ek interactive shell dega
                      jahan aap commands type kar sakte hain. Example output:
                      `[+] Drozer agent is running, waiting for console
                      connections...` 3. **Basic Reconnaissance (Kya
                      Dhoondhein?):** - Installed apps list karein: ```bash run
                      app.list ``` Output: Saare package names (e.g.,
                      `com.example.targetapp`). - Target app ke components
                      explore karein: ```bash run app.activity.info package
                      com.example.targetapp ``` Yeh batayega ki kaun si
                      activities exported hain (M1 vuln if any). Example: Agar
                      `MainActivity` exported hai, to koi bhi app usse launch
                      kar sakti hai—data leak possible. 4. **Attack Simulation
                      (Intermediate Level):** - Intent Hijacking Try Karein: Yeh
                      ek attack hai jahan aap doosri app se target activity ko
                      hijack karte hain. ```bash # Extra data bhejkar activity
                      launch karo run app.activity.start --component
                      com.targetapp com.targetapp.LoginActivity --extra string
                      username "hacker" --extra string password "cracked" ```
                      Agar activity open ho jaati hai aur data accept karti hai,
                      to vuln confirmed. Analogy: Jaise aap kisi party mein bina
                      invite ke extra gifts le jaate hain. - Provider Query
                      (Data Leak Check): ```bash run app.provider.query --table
                      content://com.targetapp.provider/users ``` Yeh app ke
                      shared data ko query karta hai. Agar sensitive info (e.g.,
                      emails) milti hai, to M2 (Insecure Storage) report karein.
                      5. **Advanced: Scripting Custom Attacks:** - Drozer mein
                      Python scripts likh sakte hain. Ek simple script banayein
                      jo saare exported providers ko fuzz kare (random queries
                      bhejkar crashes dhoondhein). #### **BEGINNER GAP FIX:
                      Drozer Script Simplified** **Note:** Yeh advanced hai.
                      Beginners pehle basic commands master karein. **Ready
                      Script:** GitHub par "drozer scripts" search karo,
                      pre-made scripts milenge. ```python # save as
                      fuzz_providers.py from drozer.modules import common,
                      Module import random def fuzz_providers(package):
                      providers =
                      common.AdbPackageManager().getProviders(package) for
                      provider in providers: query =
                      f"content://{provider}/{random.randint(1,1000)}" # Random
                      fuzz try: result = Module().execute(f"run
                      app.provider.query --table {query}") print(f"Fuzz result
                      for {query}: {result}") except: print(f"Crash! Vuln in
                      {provider}") # Buffer overflow hint ``` Run: `drozer
                      modules run custom.fuzz_providers --package
                      com.targetapp`. **Agar Use Nahi Kiya To Kya?** Manual
                      testing se time waste, missed exported components (e.g.,
                      20% vulns miss ho jaayenge per OWASP stats). Corporate
                      mein, compliance audits (e.g., PCI-DSS) fail ho sakte
                      hain. Solution: Hamesha start with Drozer for recon. **Pro
                      Tip:** Corporate workflow mein, Drozer output ko JSON
                      export karein (`--output json`) aur Jira/Confluence mein
                      paste karein reports ke liye. --- ### **Lecture 22: Native
                      Binary Analysis - Reversing .so Libraries with Ghidra/IDA
                      (The Muscle Inspector)** **Native Binary Kya Hai?**
                      Android apps ke andar `lib/` folder mein `.so` files hoti
                      hain—yeh native libraries hain jo C/C++ mein likhi jaati
                      hain (JNI via). Java code se alag, yeh low-level hote hain
                      aur performance/crypto ke liye use hote hain. **Kya
                      Istemaal Hota Hai?** Pentesting mein, native code mein
                      buffer overflows, weak crypto, ya hardcoded keys dhoondhne
                      ke liye. Corporate apps (e.g., banking) native libs use
                      karti hain sensitive ops ke liye, jahan Java obfuscation
                      fail ho jaata hai. Yeh M7 (Client Code Quality) aur M5
                      (Insufficient Cryptography) cover karta hai. **Kyun
                      Corporate Needs?** Third-party SDKs (e.g., payment libs)
                      mein vulns common hain. Agar ignore kiya, to zero-days
                      miss (e.g., Stagefright bug). Use nahi kiya to report
                      incomplete—client sochenge aapka analysis shallow hai.
                      **Step-by-Step Guide:** 1. **Extract .so Files:** ```bash
                      unzip target.apk lib/* -d extracted_libs/ ``` Ab
                      `extracted_libs/arm64-v8a/libcrypto.so` jaise files
                      milengi. 2. **Tool Setup:** #### **BEGINNER GAP FIX:
                      Ghidra & IDA Installation** **Ghidra Install:** 1.
                      Download: `https://ghidra-sre.org/` 2. Extract ZIP. 3.
                      Run: `ghidraRun.bat` (Windows) ya `ghidraRun` (Linux/Mac).
                      4. Java 11+ required. **IDA Free:** Download from Hex-Rays
                      website (limited features). - **Ghidra (Free,
                      Beginner-Friendly):** NSA ka tool, download from GitHub. -
                      New Project banaayein, `.so` import karein. - **IDA Pro
                      (Paid, Pro-Level):** Hex-Rays decompiler. Free version
                      (IDA Free) se shuru karein. 3. **Analysis with Ghidra:** -
                      Ghidra kholen, project mein `.so` load karein.
                      Auto-analyze: "Analyze" button click—yeh disassembly
                      generate karega. - Functions dhoondhein: Search bar mein
                      "AES_encrypt" type karein (crypto check). - Example: Agar
                      code mein `AES/ECB` (weak mode) dikhe: ```c // Decompiled
                      pseudo-code in Ghidra void encrypt_data(char* plaintext,
                      int len) { EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
                      EVP_EncryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, key,
                      NULL); // ECB weak! // ... } ``` Analogy: Jaise aap muscle
                      (native code) ko X-ray se dekh rahe hain—weak spots
                      (tears) dhoondh rahe hain. 4. **Vuln Hunting:** - Strings
                      extract: Ghidra mein "Window > Strings" open, "password"
                      search. Hardcoded keys mil sakti hain. - Buffer Overflow
                      Check: Functions mein stack sizes dekhein—agar input >
                      buffer size, to crash possible. Frida se hook:
                      ```javascript // frida native hook script
                      Interceptor.attach(Module.findExportByName("libtarget.so",
                      "vulnerable_function"), { onEnter: function(args) {
                      console.log("Input length: " +
                      args[0].readUtf8String().length); // Fuzz here } }); ```
                      **Run Command:** ```bash frida -U -f com.app -l
                      native_hook.js --no-pause ``` 5. **Patching/Exploit
                      (Intermediate):** - Ghidra mein code edit, recompile with
                      GCC: `gcc -shared -o patched.so original.c`. Repackage APK
                      with Apktool. **Agar Use Nahi Kiya?** Java-only RE se
                      native vulns miss (30-40% apps native use karti hain).
                      Corporate risk: Supply-chain attacks undetected. **Pro
                      Tip:** Reports mein disassembly screenshots daalein—client
                      impress honge. --- ### **Lecture 23: Anti-Reverse
                      Engineering Techniques & Bypasses - Obfuscation, RASP, and
                      Root/Jailbreak Detection (The Disguise Buster)** **Anti-RE
                      Kya Hai?** Developers app ko protect karne ke liye
                      obfuscation (code garble karna), RASP (runtime
                      self-checks), aur root detection (device tampered? check)
                      use karte hain. Yeh RE ko mushkil banate hain. **Kya
                      Istemaal Hota Hai?** Pentesting mein, in defenses ko
                      bypass karna taaki deep analysis ho sake. Corporate mein,
                      hardened apps (fintech) ke liye zaroori—bina bypass ke
                      traffic/RE fail. Covers M8/M9. **Kyun Zaroori?** Modern
                      apps 70% anti-RE use karti hain. Use nahi kiya to testing
                      stuck—false "secure" report. **Step-by-Step Bypasses:** 1.
                      **Obfuscation Detect & Deobfuscate:** - MobSF se scan:
                      Obfuscated classes count dekhein. - Bypass: Simplify tool
                      use (`java -jar simplify.jar obfuscated.apk`). ####
                      **BEGINNER GAP FIX: Simplify Tool** **Download:** GitHub
                      search "android-simplify", latest release download.
                      **Use:** Deobfuscation ke liye - complex code ko simple
                      banata hai. Ya manual: JD-GUI mein patterns map karein. 2.
                      **Root Detection Bypass (Frida):** ```javascript //
                      root_bypass.js Java.perform(function() { var RootBeer =
                      Java.use("com.scottyab.rootbeer.RootBeer");
                      RootBeer.isRooted.implementation = function() { return
                      false; }; // Fake safe }); frida -U com.targetapp -l
                      root_bypass.js ``` Analogy: App ka makeup (obfuscation)
                      utaar rahe hain. 3. **RASP Bypass:** - SafetyNet hook:
                      ```javascript var SafetyNet =
                      Java.use("com.google.android.gms.safetynet.SafetyNetApi");
                      SafetyNet.attest.implementation = function() { return
                      {result: {status: 0}}; }; // Fake pass // More RASP hooks
                      var DexClassLoader =
                      Java.use("dalvik.system.DexClassLoader");
                      DexClassLoader.$init.implementation = function() {
                      console.log("Dynamic loading detected!"); return
                      this.$init.apply(this, arguments); }; ``` 4. **Test:** App
                      chalayein—agar checks pass, bypass success. **Agar Use
                      Nahi Kiya?** Bypass fail se app crash, incomplete audit.
                      Corporate: Legal issues if client app tamper detect kare.
                      --- ### **Lecture 24: ADB Deep Dive - Backup Extraction,
                      Log Analysis, and Device Forensics (The Universal
                      Remote)** **ADB Kya Hai?** Android Debug Bridge—USB/WiFi
                      se device control karne ka tool. **Istemaal:** Non-root
                      forensics, data pull. #### **BEGINNER GAP FIX: ADB
                      Installation** **ADB Install:** 1. Download:
                      `https://developer.android.com/tools/releases/platform-tools`
                      2. Extract ZIP. 3. Add to PATH (Windows: Environment
                      Variables, Linux/Mac: `.bashrc`). 4. Test: `adb version`
                      **Step-by-Step:** 1. Enable USB Debugging: Settings >
                      Developer Options. 2. Backup: `adb backup -apk -f app.ab
                      com.app` → Decrypt: `java -jar abe.jar unpack app.ab
                      app.tar`. **Backup Decryption Tip:** Password prompt aaye
                      to 'password' try karo ya empty rakhdo. 3. Logs: `adb
                      logcat *:E | grep "sensitive"`. 4. DB Pull: `adb shell
                      run-as com.app cp /data/data/com.app/db.db /sdcard/ && adb
                      pull /sdcard/db.db`. **Agar Nahi?** Root-only dependent,
                      missed data. --- ### **Lecture 25: Pentest Reporting &
                      Compliance - Writing Actionable Reports (The Trial
                      Document)** **Reporting Kya Hai?** Findings ko structured
                      doc mein convert—exec summary, tech details, fixes.
                      **Istemaal:** Stakeholder communication, compliance
                      (MASVS). **Step-by-Step Template:** - **Exec Summary:**
                      High-risk vulns list (CVSS score). - **Details:** | Vuln |
                      PoC | Impact | Fix |. - Tools: Markdown, rate M1-M10. ####
                      **BEGINNER GAP FIX: Report Template Example** **Full
                      Markdown Sample:** ```markdown # Pentest Report: [App
                      Name] ## Executive Summary - **Critical:** 2 findings
                      (CVSS 9.0+) - **High:** 5 findings ## Findings ### 1.
                      Hardcoded API Key (M1) **Severity:** Critical **PoC:**
                      Decompiled with JD-GUI, found in `strings.xml` **Impact:**
                      Full account takeover **Fix:** Use Android Keystore ```
                      **CVSS Calculator:**
                      `https://www.first.org/cvss/calculator/3.1` **Agar Nahi?**
                      Findings waste, no remediation. --- ### **Bonus Lecture
                      26: CI/CD in Android Pentesting - Automating Security
                      Gates (The Assembly Line Guard)** **CI/CD Kya Hai?**
                      Continuous Integration/Deployment—code changes par
                      auto-build/test/deploy. Android mein, GitHub
                      Actions/Jenkins se APK build. **Pentesting Mein
                      Istemaal?** Security scans ko pipeline mein daalein (e.g.,
                      MobSF auto-scan per commit). Vulns early catch. **Kaise
                      Karein (Step-by-Step):** #### **BEGINNER GAP FIX: GitHub
                      Actions Setup** **Prerequisites:** 1. GitHub repo create
                      karo. 2. Settings > Secrets > Add MobSF API token (agar
                      remote MobSF use kar rahe). 3. `.github/workflows/` folder
                      banao repo mein. 1. GitHub Repo setup. 2.
                      `.github/workflows/security.yml` banaayein: ```yaml name:
                      Android Security Scan on: [push] jobs: scan: runs-on:
                      ubuntu-latest steps: - uses: actions/checkout@v2 - name:
                      Build APK run: ./gradlew assembleDebug - name: MobSF Scan
                      uses: opendroid/mobsf-github-action@v1 with: apk:
                      app/build/outputs/apk/debug/app-debug.apk - name: Fail on
                      High Vulns if: failure() # Block deploy if vulns run: exit
                      1 ``` 3. Run: Push code—auto scan, report Slack mein.
                      **Agar Use Nahi Kiya?** Vulns production tak pahunch
                      jaayengi (e.g., insecure storage live). Costly fixes,
                      breaches. Corporate: DevSecOps mandate. **Pro Tip:** Start
                      small—weekly scans, then full integration. Yeh complete
                      hai! Har sawal cover kiya—what, why, how, risks. Aur
                      chahiye to batao. 🚀
                      =============================================================</intent-filter
                    ></activity
                  ></application
                ></uses-permission
              ></provider
            ></receiver
          ></service
        ></activity
      ></uses-permission
    ></application
  ></manifest
>

=================================================================== ###
**Lecture 27: OWASP Mobile Top 10 (2024/2025 Update) - The Modern "Most Wanted"
List** **Kyun Update Zaroori?** Pehle wale OWASP (2016) ab outdated hai—2024
version naye threats jaise supply chain attacks aur AI-driven vulns ko cover
karta hai. Corporate mein, yeh latest list se reports banate hain (e.g.,
NIST/ISO compliance ke liye). Job-ready hone ke liye, isse jaano: Yeh checklist
se audits fast hote hain, aur interviews mein "Latest OWASP Mobile risks?"
poochha jaata hai. **2016 vs 2024: Quick Comparison** | 2016 Category | 2024
Category | Kyun Change? | |---------------|---------------|--------------| | M1:
Improper Platform Usage | M1: Improper Credential Usage | Focus shift to weak
auth (e.g., no MFA). | | M2: Insecure Data Storage | M2: Inadequate Supply Chain
Security | Third-party libs (e.g., SDK vulns) ab top risk. | | M3: Insecure
Communication | M3: Insecure Authentication/Authorization | Broader: Includes
broken session logic. | | M4: Insecure Authentication | M4: Insufficient
Input/Output Validation | XSS/SQLi in mobile contexts. | | M5: Insufficient
Cryptography | M5: Insecure Communication | Encryption gaps (e.g., weak TLS). |
| M6: Insecure Authorization | M6: Inadequate Privacy Controls | GDPR-like data
exposure. | | M7: Client Code Quality | M7: Insufficient Binary Protections |
Obfuscation/root detection failures. | | M8: Code Tampering | M8: Security
Misconfiguration | Default settings (e.g., debug mode on). | | M9: Reverse
Engineering | M9: Insecure Data Storage | Plaintext creds in local storage. | |
M10: Extraneous Functionality | M10: Insufficient Cryptography | Weak algos like
MD5. | **2024 OWASP Mobile Top 10 - Detail Mein** #### **M1: Improper Credential
Usage** * **Kya Hai?** Weak passwords, no rotation, hardcoded creds (e.g., API
keys in code). * **Analogy:** Aapka ghar ka lock to strong hai, par aap "123456"
password use kar rahe ho. * **Example:** App mein hardcoded API key: JD-GUI se
decompile karo, `strings.xml` mein "api_key=sk_live_abc123" mile. * **Test
Kaise?** Static: MobSF scan for secrets. Dynamic: Objection hook
`getSharedPreferences` to dump creds. ```bash android hooking watch class_method
android.content.SharedPreferencesEditor.putString --dump-args ``` * **Fix:** Use
secure vaults (e.g., Android Keystore). #### **M2: Inadequate Supply Chain
Security** * **Kya Hai?** Third-party libs/SDKs mein vulns (e.g., outdated
Firebase SDK se data leak). * **Analogy:** Aapka ghar safe hai, par plumber ne
weak pipe lagaya jo leak kar raha hai. * **Example:** APK extract, `lib/` mein
vulnerable .so check (Ghidra se). Ya Manifest mein old SDK version. * **Test
Kaise?** MobSF report dekho ("Dependencies" section). Update check: `pip install
safety; safety check` on extracted libs. * **Fix:** SAST tools like OWASP
Dependency-Check in CI/CD. #### **M3: Insecure Authentication/Authorization** *
**Kya Hai?** Broken login (e.g., no rate-limiting), weak sessions, IDOR. *
**Analogy:** Guard aapko andar to dekhne deta hai, par andar CEO ka safe khol
deta hai. * **Example:** Burp se session ID tamper: Login karo, cookie change
karo, doosre user ka data mile. * **Test Kaise?** Drozer se: `run
app.provider.query` for auth bypass. Frida hook login method. ```javascript
Java.perform(() => { var LoginManager = Java.use("com.app.LoginManager");
LoginManager.authenticate.implementation = function(user, pass) { return true;
}; }); ``` * **Fix:** JWT with proper validation. #### **M4: Insufficient
Input/Output Validation** * **Kya Hai?** User input sanitize na karna, leading
to injection (SQL/XSS in WebViews). * **Analogy:** Aap guest ko andar bulaye,
par uske bag check na karo—bomb aa sakta hai. * **Example:** App mein search bar
se SQLi: Burp repeater mein `' OR 1=1--` inject, extra data mile. * **Test
Kaise?** Dynamic: Burp Intruder fuzz inputs. Static: Smali mein input methods
grep "rawQuery". * **Fix:** Use PreparedStatements, escape HTML in WebViews.
#### **M5: Insecure Communication** * **Kya Hai?** Weak TLS (e.g., no HSTS),
cleartext traffic. * **Analogy:** Secret baatein postcard par bhejna—sab padh
sakte hain. * **Example:** Burp mein HTTP requests dekho. Pinning weak? Frida
bypass. * **Test Kaise?** `sslscan app-server.com` ya Burp scan. * **Fix:**
Enforce TLS 1.3 + pinning. #### **M6: Inadequate Privacy Controls** * **Kya
Hai?** Over-permissive data collection (e.g., location without consent). *
**Analogy:** Aapka doctor aapke records ko newspaper par print kar de. *
**Example:** Manifest mein `<uses-permission
  android:name="ACCESS_FINE_LOCATION"
/>` bina runtime check. * **Test Kaise?** ADB logs: `adb logcat | grep
"location"`. Drozer: `run app.permission.list package com.app`. * **Fix:**
Privacy policy + runtime prompts. #### **M7: Insufficient Binary Protections** *
**Kya Hai?** Weak anti-RE (no obfuscation, easy tampering). * **Analogy:**
Tijori ka code "0000"—koi bhi khol le. * **Example:** Apktool se easy decompile.
No ProGuard traces in Bytecode-viewer. * **Test Kaise?** Ghidra se native
checks, Frida for RASP bypass. * **Fix:** DexGuard + integrity checks. ####
**M8: Security Misconfiguration** * **Kya Hai?** Debug mode on in prod, exposed
logs. * **Analogy:** Ghar ka darwaja khula chhod dena. * **Example:** `adb shell
getprop log.tag` se verbose logs, sensitive data mile. * **Test Kaise?** ADB
deep dive: `adb logcat -v threadtime`. * **Fix:** Prod builds mein debug=false.
#### **M9: Insecure Data Storage** * **Kya Hai?** Plaintext files/DBs (e.g.,
SQLite without SQLCipher). * **Analogy:** Diary khuli rakhna—koi bhi padh le. *
**Example:** Rooted device par `/data/data/com.app/databases/` pull, cat karo. *
**Test Kaise?** ADB backup, grep "password". * **Fix:** Encrypted SharedPrefs.
#### **M10: Insufficient Cryptography** * **Kya Hai?** Weak algos (e.g., DES, no
salt). * **Analogy:** Purana taala hairpin se khul jaaye. * **Example:** JD-GUI
mein `MessageDigest.getInstance("MD5")` mile. * **Test Kaise?** MobSF crypto
section. Crack with Hashcat: `hashcat -m 0 md5hash.txt wordlist.txt`. * **Fix:**
AES-GCM + PBKDF2. **Kaise Apply Karein Job Mein?** - **Checklist Banayein:** Har
pentest shuru karte hi yeh list tick karo. - **Tools Integration:** MobSF + Burp
+ Frida se automated reports. - **Practice:** Vulnerable app (InsecureBankv2)
par test karo, GitHub par PoC upload. **Pro Tip:** OWASP MASTG (Mobile AppSec
Testing Guide) padho—yeh testing steps deta hai. Interview mein: "2024 M2 supply
chain ka example?"— "Outdated SDK se RCE." --- ### **SUMMARY: All Beginner Gaps
Fixed! 🎉** Yeh notes ab complete hain with: - **20+ Installation guides**
(Burp, Frida, Apktool, etc.) - **Step-by-step commands** with expected outputs -
**Troubleshooting tips** for common errors - **Version-specific instructions**
(Android 7-11+) - **Complete code examples** with helper functions - **Tool
alternatives** (Enjarify, Simplify) - **Cross-platform commands**
(Windows/Linux/Mac) - **Security warnings** and best practices **Beginner Action
Plan:** 1. Start with Lecture 7 - Setup emulator 2. Practice Lecture 9-10 - Burp
Suite proxy 3. Master Lecture 14 - APK decompilation 4. Learn Lecture 15 - Frida
hooking 5. Apply Lecture 20 - OWASP Top 10 checklist **Resources:** - Practice
App: DIVA (Damn Insecure and Vulnerable App) - Practice App: InsecureBankv2 -
GitHub: Upload your PoCs - OWASP MASTG: `https://mas.owasp.org/MASTG/` Ab koi
bhi beginner in notes se Android pentesting seekh sakta hai! 🚀
=================================================================== 1. WebView
Vulnerabilities Kahaan Add Karein: Lecture 20 ke baad “Lecture 20.5: WebView
Vulnerabilities” ke naam se dala jaye. Lecture 20.5: WebView Vulnerabilities and
Exploitation WebView Kya Hai aur Kyun Use Karte Hai? WebView ek Android
component hai jisse app ke andar web pages render kiye jaate hain. Isse users
bina browser khole web-content dekh sakte hain. Security Risk: Agar WebView ko
galat tareeke se configure kiya gaya ho, toh attacker JavaScript ka use karke
app ke native code ko access kar sakta hai, ya sensitive data leak kar sakta
hai. Common Bugs aur Exploits JavaScript Interface Exploit
(addJavascriptInterface): Kab bug hota hai?: Agar developer
setJavaScriptEnabled(true) karta hai aur untrusted web-content load karta hai.
Kya risk hai?: Attacker JavaScript se app functions call kar sakta hai, code
execute kar sakta hai, data leak kar sakta hai. Example Code (Vulnerable): java
WebView webView = findViewById(R.id.webview);
webView.getSettings().setJavaScriptEnabled(true);
webView.addJavascriptInterface(new WebAppInterface(this), "Android");
webView.loadUrl("http://malicious.site"); When/Why/How Questions: Kab exploit
hota hai? Jab webview mein unsafe JavaScript enable hota hai aur untrusted
content load hota hai. Kaise exploit karein? Malicious site injects JavaScript,
jo “Android” interface ko use karke app ke methods call kar leti hai. Kyun
dangerous hai? User permissions par sensitive code execute ho sakta hai. Frida
Script Example: javascript Java.perform(function () { var WebView =
Java.use('android.webkit.WebView');
WebView.addJavascriptInterface.implementation = function(obj, name) {
console.log('JavaScript Interface Added:', name);
this.addJavascriptInterface(obj, name); } }); Mitigation: JavaScript only
trusted content par enable karein. ‘@JavascriptInterface’ annotation ka use
karein (API level >= 17) Untrusted content per ‘removeJavascriptInterface’ karo
Unsafe URL Loading java webView.loadUrl("http://malicious-site.com"); // Always
validate URLs! Kab/Why?: Agar app kisi bhi external URL ko verify kiye bina load
karti hai. Mitigation: Only allow allow-listed domains, enforce HTTPS. Key
Testing Questions: Kya WebView mein JavaScript enabled hai? Kya koi untrusted
URL load ho raha hai? addJavascriptInterface ka misuse toh nahi ho raha? Koi
sensitive data WebView ke through leak ho raha hai kya? 2. Deep Links & App Link
Exploitation Kahaan Add Karein: Lecture 21 (Drozer) ke saath integrate karein ya
“Lecture 21.5: Deep Links & App Links Vulnerabilities” naam se separate section
banayein. Lecture 21.5: Deep Links, App Links, and Intent Hijacking Deep Link
Kya Hai aur Kyun Important Hai? Deep Link ek URI hota hai jo app ke specific
part/activity ko open karta hai (e.g. myapp://profile?id=1). Security Risk: Agar
app deep link intents ko validate nahi karti ya verify nahi karti, toh attacker
sensitive data intercept kar sakta hai ya unauthorized action perform kar sakta
hai. Common Exploits & Practical Example Intent Hijacking (Deep Link Exploit):
Kab bug hota hai? Jab multiple apps same URI patterns handle karte hain aur
victim app verification nahi karti.​ Kya risk hai?: Attacker puts their own
malicious app, hijacks intents, steals tokens/passwords. Example Manifest
(Exploitable): xml
<intent-filter>
  <action android:name="android.intent.action.VIEW" />
  <category android:name="android.intent.category.DEFAULT" />
  <category android:name="android.intent.category.BROWSABLE" />
  <data android:scheme="noob" android:host="harshit.com" />
</intent-filter>
Drozer Command to Verify: bash # List exported activities run app.activity.info
-a com.target.app # Fire intent run app.activity.start --action
android.intent.action.VIEW --data-uri noob://harshit.com/auth=sum Attack
Scenario: Password reset ya token transfer link via app sends sensitive token.
Malicious app registers same intent-filter. User prompted for app choice;
attacker’s app selects and intercepts the token. ADB Test Command: bash # Deep
Link intent send via ADB adb shell am start -a android.intent.action.VIEW -d
"myapp://reset?token=XYZ" Why is it risky? Sensitive data can be stolen.
Unauthorized activity trigger ho sakta hai (e.g. money transfer, password
change). Mitigation: Use autoVerify for App Links, verify domains. Validate
incoming intents, never trust external data blindly. Key Questions: App deep
links ka verification use karti hai? Koi sensitive intent data leak toh nahi ho
sakta? Malicious app hijack kar sakta hai kya? 3. SQL Injection in Android Apps
Kahaan Add Karein: OWASP Top 10 vulnerabilities section mein “Injection Attacks”
sub-section banayein. OWASP M4: Injection Attacks – SQL Injection in Android SQL
Injection Kya Hai? Agar app user input ko sanitize kiye bina SQL queries mein
directly use karti hai, toh attacker arbitrary queries inject kar sakta hai.​
Basic Example – Vulnerable Login Code: java // VULNERABLE: User input direct SQL
mein dala String query = "SELECT * FROM users WHERE username = '" + username +
"' AND password = '" + password + "'"; Cursor c = db.rawQuery(query, null); //
Authentication bypass possible Attack Input: username: 1' OR '1'='1 password: 1'
OR '1'='1 Query ban jaata hai: SELECT * FROM users WHERE username='1' OR '1'='1'
AND Password='1' OR '1'='1' How to Test (When/Why/How): Kab?: Jab user inputs
directly queries mein concatenate ho rahe ho. Kyun?: Disables authentication;
attacker login ho sakta hai bina credentials ke. Kaise?: Special input values
(quotes/or) use karo to manipulate query. Mitigation: Always use parameterized
queries/prepared statements. Input validation karo. Key Questions: App anywhere
rawQuery, execSQL, etc. user input ke sath use toh nahi kar rahi? Kya
parameterized queries use ho rahi hain? 4. Firebase Misconfiguration
Vulnerability Kahaan Add Karein: “Advanced Vulnerabilities” section ya hands-on
labs mein add karein “Firebase Misconfiguration Exploit” as a new challenge.
Firebase Misconfiguration – Sensitive Data Exposure Firebase Kya Hai? Google ka
real-time mobile backend hai jisse apps apna data store karti hain.
Vulnerability: Agar security rules default/test mode pe hain ya public
read/write allowed hai, toh attacker bina authentication ke data access kar leta
hai.​ Practical Steps for Exploitation: APK Decompile karo (JADX/Apktool) aur
google-services.json ya strings.xml se Firebase URL nikaalo. bash strings
classes.dex | grep firebaseio .json endpoint access karo: bash curl
https://app-name.firebaseio.com/.json # Should NOT return data!
Authentication/Access rules test karo: try reading/writing to endpoint via API
or REST. Common Risks: User credentials, chat logs, AWS keys, media files etc.
leak ho sakte hain. Why is this risky? App user data, even passwords, attacker
ke haath lag sakte hain. Mitigation: Default rules never use karo, only
authenticated access allow karo. Audit security rules and regularly monitor
endpoints. Key Questions: App ke Firebase endpoints publicly exposed toh nahi
hain? Test mode rules production mein toh nahi use ho rahe? 5. Content Provider
Vulnerabilities: Path Traversal & Unauthorized Access Kahaan Add Karein: Data
storage section ya “Lecture 22: Content Provider Exploitation” ke naam se add
karein. Content Provider Bugs – Path Traversal & Information Disclosure Content
Provider Kya Hai? Inter-app data sharing ka Android mechanism. Vulnerability:
Agar exported Content Provider mein proper access control nahi hai, toh attacker
sensitive data read/write kar sakta hai.​ Practical Exploit Example: bash # Path
Traversal
content://com.vulnerable.app.provider/files/../../../../data/data/com.vulnerable.app/shared_prefs/config.xml
# Malicious app requests this URI and reads files outside sandbox. Why/How/When
Questions: Kab? Exported provider ho aur openFile/sensitive query functions use
ho. Kaise exploit karein? Malicious URI paths se sensitive file access karein.
Kyun? Access control missing hai ya improper validation ho. Drozer Testing: bash
run app.provider.query -u content://com.vulnerable.app.provider/files run
app.provider.read -u
content://com.vulnerable.app.provider/files/../../../../etc/passwd Mitigation:
Always set android:exported=false for sensitive providers. Validate file paths,
disallow “../” traversal. Key Questions: Content provider exported hai? Kya
sensitive functions (openFile, query) unprotected hai? Kya path traversal via
malicious intents possible hai? 6. DIVA App – Hands-on Walkthrough for Labs
Kahaan Add Karein: New “Practical Labs” section banayein, jahan sab common
vulnerable apps ki step-by-step solutions ho. Lab Challenge Example: DIVA –
Insecure Logging Problem: App sensitive info logcat mein print kar rahi hai.
Step-by-Step Solution: Install DIVA APK on emulator: bash adb install
diva-beta.apk Challenge open karein: "Insecure Logging" adb shell use karo: bash
adb shell logcat | grep CreditCard # Find card number in logs When/Why/How:
Kab?: Jab logging statements confidential data print karte hain. Kyun?:
Attackers other apps se logcat access karke info chura sakte hain. Kaise test
karein?: Logcat monitor karo, challange complete hone pe check karo.
