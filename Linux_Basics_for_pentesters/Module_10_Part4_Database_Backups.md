# **Module 10: Backup, Restore & Version Control (Part 4)** ğŸ’¾ğŸ”„

---

## **Topic 4: Database Backups (mysqldump) & Point-in-Time Recovery** ğŸ—„ï¸â°

---

### **1ï¸âƒ£ Topic Summary (1-2 lines)**

mysqldump MySQL/MariaDB databases ka logical backup tool hai jo SQL format mein backup banata hai, aur binary logs se point-in-time recovery possible hai - kisi bhi specific moment tak database restore kar sakte ho.

---

### **2ï¸âƒ£ Detailed Explanation with Analogy** ğŸ§ 

**Kya hai Database Backup?**

Database backup do types ke hote hain:

1. **Logical Backup (mysqldump)** - SQL statements ki form mein backup (human-readable)
2. **Physical Backup** - Raw database files ka backup (faster but complex)
3. **Point-in-Time Recovery (PITR)** - Binary logs use karke specific time tak restore karna

**mysqldump** - MySQL ka built-in tool jo database ko SQL dump file mein export karta hai. Ye file human-readable hoti hai aur kisi bhi MySQL server par import ho sakti hai.

**Binary Logs** - MySQL har transaction record karta hai binary log files mein. Inka use point-in-time recovery ke liye hota hai.

**Analogy:**

- **mysqldump** = Ek **recipe book** banana - har dish (table) ki complete recipe (SQL) likhi hui. Kisi bhi kitchen (server) mein ye recipe use kar sakte ho
- **Binary Logs** = Ek **video recording** - har action record hai. Kisi bhi moment tak rewind kar sakte ho
- **Point-in-Time Recovery** = **Time travel** - "Kal 3:45 PM tak ka database chahiye" - binary logs se exact us time tak restore!

---

### **3ï¸âƒ£ Why is this Important?** ğŸ¯

**Sysadmin Perspective:**
- Data loss se protection
- Accidental DELETE/DROP recovery
- Database migration between servers
- Development/staging environment setup
- Disaster recovery
- Compliance requirements (data retention)

**Pentester Perspective:**
- Database dumps mein sensitive data
- Backup files often weak permissions
- mysqldump files mein credentials
- Old backups mein deleted data
- Binary logs mein query history
- Backup scripts analyze karna

---

### **4ï¸âƒ£ Real-World Use Cases** ğŸ’¼

**Admin Use Cases:**
1. Daily automated database backups
2. Before schema changes/migrations
3. Cloning production to staging
4. Disaster recovery testing
5. Point-in-time recovery after accidental data deletion

**Pentester Use Cases:**
1. Database dump files mein sensitive data
2. Backup directories mein SQL files
3. mysqldump commands mein credentials
4. Binary logs analyze karna
5. Old backups mein deleted records

---

### **5ï¸âƒ£ Consequences of Not Knowing** âš ï¸

**Admin Problems:**
- âŒ Data loss permanent
- âŒ No recovery from accidental deletions
- âŒ Database corruption = complete loss
- âŒ Migration difficult
- âŒ Compliance violations

**Pentester Problems:**
- âŒ Database backup files miss karna
- âŒ Sensitive data in dumps overlook karna
- âŒ Credentials in backup scripts miss
- âŒ Binary log analysis skip karna
- âŒ Easy data access miss karna

---

### **6ï¸âƒ£ Syntax & Command Structure** ğŸ“

#### **mysqldump Syntax:**
```bash
mysqldump [options] database_name > backup.sql

Common Options:
-u username         # MySQL username
-p                  # Prompt for password
-h hostname         # MySQL host
--all-databases     # Backup all databases
--databases db1 db2 # Backup specific databases
--single-transaction # Consistent backup (InnoDB)
--routines          # Include stored procedures
--triggers          # Include triggers
--events            # Include events
--master-data=2     # Include binary log position
```

#### **Restore Syntax:**
```bash
mysql [options] database_name < backup.sql

# Or
mysql -u root -p -e "source /path/to/backup.sql"
```

#### **Binary Log Commands:**
```bash
mysqlbinlog binlog_file           # View binary log
mysqlbinlog --start-datetime="..." # Filter by time
mysqlbinlog --stop-datetime="..."  # Stop at time
```

---

### **7ï¸âƒ£ Detailed Examples with Explanation Tables** ğŸ’»

#### **Example 1: Basic Database Backup**

```bash
mysqldump -u root -p database_name > backup.sql
```

| Part | Explanation |
|------|-------------|
| `mysqldump` | Backup command |
| `-u root` | Username |
| `-p` | Prompt for password |
| `database_name` | Database to backup |
| `> backup.sql` | Output file |

**Prompt:**
```
Enter password: ****
```

**Result:** `backup.sql` file created with all tables.

---

#### **Example 2: Backup All Databases**

```bash
mysqldump -u root -p --all-databases > all_databases.sql
```

| Part | Explanation |
|------|-------------|
| `--all-databases` | Backup all databases |

**Use Case:** Complete MySQL server backup.

---

#### **Example 3: Backup with Compression**

```bash
mysqldump -u root -p database_name | gzip > backup.sql.gz
```

| Part | Explanation |
|------|-------------|
| `\| gzip` | Compress output |
| `> backup.sql.gz` | Compressed file |

**Result:** Much smaller file size (10x compression typical).

---

#### **Example 4: Consistent Backup (InnoDB)**

```bash
mysqldump -u root -p --single-transaction --routines --triggers database_name > backup.sql
```

| Part | Explanation |
|------|-------------|
| `--single-transaction` | Consistent snapshot (no table locks) |
| `--routines` | Include stored procedures/functions |
| `--triggers` | Include triggers |

**Use Case:** Production database backup without downtime.

---

#### **Example 5: Backup Specific Tables**

```bash
mysqldump -u root -p database_name table1 table2 > tables_backup.sql
```

| Part | Explanation |
|------|-------------|
| `table1 table2` | Specific tables to backup |

**Use Case:** Backup only important tables.

---

#### **Example 6: Restore Database**

```bash
mysql -u root -p database_name < backup.sql
```

| Part | Explanation |
|------|-------------|
| `mysql` | MySQL client |
| `< backup.sql` | Input from file |

**Steps:**
```bash
# Create database if doesn't exist
mysql -u root -p -e "CREATE DATABASE IF NOT EXISTS database_name;"

# Restore
mysql -u root -p database_name < backup.sql
```

---

#### **Example 7: Backup with Binary Log Position**

```bash
mysqldump -u root -p --single-transaction --master-data=2 --all-databases > backup.sql
```

| Part | Explanation |
|------|-------------|
| `--master-data=2` | Include binary log position as comment |

**In backup.sql:**
```sql
-- CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000123', MASTER_LOG_POS=456789;
```

**Use Case:** Point-in-time recovery starting point.

---

#### **Example 8: Enable Binary Logging**

```bash
# Edit MySQL config
sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf
```

**Add:**
```ini
[mysqld]
log_bin = /var/log/mysql/mysql-bin.log
expire_logs_days = 7
max_binlog_size = 100M
```

```bash
# Restart MySQL
sudo systemctl restart mysql

# Verify
mysql -u root -p -e "SHOW VARIABLES LIKE 'log_bin';"
```

**Output:**
```
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | ON    |
+---------------+-------+
```

---

#### **Example 9: View Binary Logs**

```bash
# List binary logs
mysql -u root -p -e "SHOW BINARY LOGS;"
```

**Output:**
```
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000001 | 177       |
| mysql-bin.000002 | 1234567   |
| mysql-bin.000003 | 456789    |
+------------------+-----------+
```

```bash
# View binary log content
mysqlbinlog /var/log/mysql/mysql-bin.000003
```

---

#### **Example 10: Point-in-Time Recovery**

**Scenario:** Database backup at 2 AM, accidental DELETE at 3:45 PM, need to recover till 3:44 PM.

```bash
# Step 1: Restore full backup (2 AM)
mysql -u root -p database_name < backup_2am.sql

# Step 2: Apply binary logs till 3:44 PM
mysqlbinlog --start-datetime="2024-01-15 02:00:00" \
            --stop-datetime="2024-01-15 15:44:00" \
            /var/log/mysql/mysql-bin.* | mysql -u root -p database_name

# Database now at 3:44 PM state!
```

---

### **8ï¸âƒ£ Common Mistakes & How to Avoid** âŒâ¡ï¸âœ…

| Mistake | Problem | Solution |
|---------|---------|----------|
| Password in command | Visible in process list | Use `.my.cnf` or prompt with `-p` |
| No `--single-transaction` | Table locks, downtime | Always use for InnoDB |
| Forgetting to backup routines | Stored procedures lost | Add `--routines --triggers` |
| No compression | Large backup files | Pipe through `gzip` |
| Backup to same server | Server failure = no backup | Backup to remote server |
| No binary logs | No point-in-time recovery | Enable binary logging |
| Not testing restore | Backup may be corrupt | Regular restore testing |
| Hardcoded passwords | Security risk | Use config files |

---

### **9ï¸âƒ£ Best Practices & Pro Tips** â­

**Admin Best Practices:**
1. âœ… **Automated Backups**: Daily cron jobs
2. âœ… **Compression**: Always compress backups
3. âœ… **Remote Storage**: Backup to different server
4. âœ… **Binary Logs**: Enable for point-in-time recovery
5. âœ… **Test Restores**: Monthly restore testing
6. âœ… **Retention Policy**: Keep 7 daily, 4 weekly, 3 monthly
7. âœ… **Secure Credentials**: Use `.my.cnf` file
8. âœ… **Monitor**: Alert on backup failures

**Pentester Pro Tips:**
1. ğŸ” **Find Dumps**: `/backup/`, `/var/backups/`, `/tmp/`
2. ğŸ” **Check Permissions**: `find / -name "*.sql" -readable 2>/dev/null`
3. ğŸ” **Backup Scripts**: Often contain credentials
4. ğŸ” **Binary Logs**: Query history analysis
5. ğŸ” **Old Backups**: Deleted data still present
6. ğŸ” **Compressed Files**: `*.sql.gz` files
7. ğŸ” **Cron Jobs**: Backup timing patterns
8. ğŸ” **Web Accessible**: Check for exposed SQL files

---

### **ğŸ”Ÿ Real-World Scenarios** ğŸŒ

#### **Scenario 1: Automated Daily Backup (Admin)**

**Situation:** Production database ka daily automated backup with retention.

**Solution:**
```bash
# Create backup script
sudo nano /usr/local/bin/mysql_backup.sh
```

**Script:**
```bash
#!/bin/bash

# Configuration
BACKUP_DIR="/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)
MYSQL_USER="backup_user"
MYSQL_PASS="SecurePassword123"
RETENTION_DAYS=7

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Backup all databases
mysqldump -u "$MYSQL_USER" -p"$MYSQL_PASS" \
    --single-transaction \
    --routines \
    --triggers \
    --events \
    --all-databases | gzip > "$BACKUP_DIR/all_databases_${DATE}.sql.gz"

# Check if backup successful
if [ $? -eq 0 ]; then
    echo "Backup successful: all_databases_${DATE}.sql.gz" | logger -t mysql-backup
    
    # Delete old backups
    find "$BACKUP_DIR" -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete
else
    echo "Backup FAILED!" | logger -t mysql-backup
    exit 1
fi
```

```bash
# Make executable
sudo chmod 700 /usr/local/bin/mysql_backup.sh

# Add to cron (daily at 2 AM)
echo "0 2 * * * /usr/local/bin/mysql_backup.sh" | sudo crontab -
```

**Result:** Daily backups with 7-day retention!

---

#### **Scenario 2: Point-in-Time Recovery (Admin)**

**Situation:** User ne accidentally 3:45 PM ko important data delete kar diya. Last backup 2 AM ki hai.

**Solution:**
```bash
# Step 1: Check binary log position from backup
zcat /backup/mysql/all_databases_20240115_020000.sql.gz | head -30 | grep "MASTER_LOG"
# -- MASTER_LOG_FILE='mysql-bin.000045', MASTER_LOG_POS=12345;

# Step 2: Create recovery database
mysql -u root -p -e "CREATE DATABASE recovery_db;"

# Step 3: Restore full backup
zcat /backup/mysql/all_databases_20240115_020000.sql.gz | mysql -u root -p recovery_db

# Step 4: Apply binary logs till 3:44 PM (1 minute before DELETE)
mysqlbinlog --start-position=12345 \
            --stop-datetime="2024-01-15 15:44:00" \
            /var/log/mysql/mysql-bin.000045 \
            /var/log/mysql/mysql-bin.000046 | mysql -u root -p recovery_db

# Step 5: Verify data
mysql -u root -p recovery_db -e "SELECT COUNT(*) FROM important_table;"

# Step 6: If OK, replace production
mysql -u root -p -e "DROP DATABASE production_db;"
mysql -u root -p -e "CREATE DATABASE production_db;"
mysqldump -u root -p recovery_db | mysql -u root -p production_db
```

**Result:** Data recovered till 3:44 PM, DELETE undone!

---

#### **Scenario 3: Database Migration (Admin)**

**Situation:** Production database ko new server par migrate karna hai.

**Solution:**
```bash
# On old server
mysqldump -u root -p --single-transaction --routines --triggers \
    --all-databases | gzip > /tmp/migration.sql.gz

# Transfer to new server
scp /tmp/migration.sql.gz user@new-server:/tmp/

# On new server
zcat /tmp/migration.sql.gz | mysql -u root -p

# Verify
mysql -u root -p -e "SHOW DATABASES;"
```

**Result:** Complete database migrated!

---

#### **Scenario 4: Finding Database Credentials (Pentester)**

**Situation:** Target server pe database backup files accessible hain.

**Attack:**
```bash
# Find SQL dump files
find / -name "*.sql" -o -name "*.sql.gz" 2>/dev/null

# Found: /var/backups/mysql/backup.sql.gz

# Extract and analyze
zcat /var/backups/mysql/backup.sql.gz > /tmp/backup.sql

# Search for sensitive data
grep -i "password\|secret\|api_key\|token" /tmp/backup.sql | head -20

# Found in users table
# INSERT INTO `users` VALUES (1,'admin','admin@site.com','$2y$10$hash...','2024-01-15');

# Extract password hashes
grep "INSERT INTO \`users\`" /tmp/backup.sql > /tmp/users.txt

# Also check for application configs in database
grep -i "wp_options\|config\|settings" /tmp/backup.sql
```

**Finding:** User password hashes + application secrets!

---

#### **Scenario 5: Backup Script Credential Extraction (Pentester)**

**Situation:** Backup scripts mein credentials search karna.

**Attack:**
```bash
# Find backup scripts
find / -name "*backup*.sh" 2>/dev/null

# Found: /root/db_backup.sh
cat /root/db_backup.sh
```

**Script content:**
```bash
#!/bin/bash
DB_USER="root"
DB_PASS="SuperSecret123"
mysqldump -u $DB_USER -p$DB_PASS --all-databases > /backup/db.sql
```

**Finding:** Root database password!

```bash
# Also check MySQL config files
cat ~/.my.cnf
```

**Content:**
```ini
[client]
user=root
password=SuperSecret123
```

**Impact:** Full database access!

---

### **1ï¸âƒ£1ï¸âƒ£ Checklist for Implementation** âœ…

**Admin Checklist:**
- [ ] mysqldump installed and tested
- [ ] Automated backup script created
- [ ] Backup schedule configured (cron)
- [ ] Compression enabled
- [ ] Remote backup location configured
- [ ] Binary logging enabled
- [ ] Retention policy implemented
- [ ] Backup monitoring setup
- [ ] Test restore performed
- [ ] Point-in-time recovery tested

**Pentester Checklist:**
- [ ] Database backup locations enumerated
- [ ] SQL dump files searched
- [ ] Backup file permissions checked
- [ ] Backup scripts analyzed for credentials
- [ ] MySQL config files checked
- [ ] Binary logs location identified
- [ ] Old backups checked for deleted data
- [ ] Compressed backups extracted
- [ ] Sensitive data in dumps documented
- [ ] Findings reported with remediation

---

### **1ï¸âƒ£2ï¸âƒ£ Frequently Asked Questions (FAQs)** â“

**Q1: mysqldump vs physical backup - kya farak hai?**
**A:** 
- **mysqldump**: Logical backup (SQL), portable, slower, human-readable
- **Physical**: Raw files, faster, less portable, requires same MySQL version

**Q2: Backup ke dauran database lock hota hai?**
**A:** InnoDB tables ke liye `--single-transaction` use karein - no locks, no downtime.

**Q3: Backup file kitni badi hogi?**
**A:** Typically database size ka 50-70% (with compression). 10GB database = ~5-7GB compressed backup.

**Q4: Point-in-time recovery ke liye kya chahiye?**
**A:** 
1. Full backup with binary log position
2. Binary logs enabled
3. Binary log files preserved

**Q5: Kya password command line mein dena safe hai?**
**A:** NO! Use `.my.cnf` file:
```bash
# ~/.my.cnf
[client]
user=backup_user
password=SecurePassword
```
```bash
chmod 600 ~/.my.cnf
mysqldump --defaults-file=~/.my.cnf database_name > backup.sql
```

**Q6: Binary logs kitni space lete hain?**
**A:** Depends on activity. High-traffic site: 1-10 GB/day. Set `expire_logs_days=7` for auto-cleanup.

**Q7: Backup restore kitna time leta hai?**
**A:** Roughly: 1GB = 5-10 minutes (depends on server). 10GB database = 1-2 hours.

**Q8: Kya specific time se pehle ka data restore kar sakte hain?**
**A:** Haan! `mysqlbinlog --stop-datetime="2024-01-15 15:44:00"` use karein.

---

### **1ï¸âƒ£3ï¸âƒ£ Practice Tasks with Expected Output** ğŸ¯

#### **Task 1: Basic Database Backup**
```bash
# Create test database
mysql -u root -p -e "CREATE DATABASE test_db;"
mysql -u root -p test_db -e "CREATE TABLE users (id INT, name VARCHAR(50));"
mysql -u root -p test_db -e "INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');"

# Backup
mysqldump -u root -p test_db > test_backup.sql

# Verify
ls -lh test_backup.sql
```

**Expected:** SQL file created with table structure and data.

---

#### **Task 2: Backup and Restore**
```bash
# Backup
mysqldump -u root -p test_db > test_backup.sql

# Drop database
mysql -u root -p -e "DROP DATABASE test_db;"

# Restore
mysql -u root -p -e "CREATE DATABASE test_db;"
mysql -u root -p test_db < test_backup.sql

# Verify
mysql -u root -p test_db -e "SELECT * FROM users;"
```

**Expected Output:**
```
+------+-------+
| id   | name  |
+------+-------+
|    1 | Alice |
|    2 | Bob   |
+------+-------+
```

---

#### **Task 3: Compressed Backup**
```bash
# Compressed backup
mysqldump -u root -p test_db | gzip > test_backup.sql.gz

# Compare sizes
ls -lh test_backup.sql test_backup.sql.gz

# Restore from compressed
zcat test_backup.sql.gz | mysql -u root -p test_db
```

---

#### **Task 4: Enable and Check Binary Logs**
```bash
# Check if enabled
mysql -u root -p -e "SHOW VARIABLES LIKE 'log_bin';"

# If OFF, enable in config
sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf
# Add: log_bin = /var/log/mysql/mysql-bin.log

# Restart
sudo systemctl restart mysql

# Verify
mysql -u root -p -e "SHOW BINARY LOGS;"
```

---

### **1ï¸âƒ£4ï¸âƒ£ Advanced Information & Edge Cases** ğŸš€

#### **Advanced Technique 1: Parallel Backup (Multiple Databases)**

```bash
#!/bin/bash
# Backup multiple databases in parallel
for db in db1 db2 db3; do
    mysqldump -u root -p"$PASS" "$db" | gzip > "${db}.sql.gz" &
done
wait
```

**Result:** Faster backups for multiple databases.

---

#### **Advanced Technique 2: Incremental Backup with Binary Logs**

```bash
# Full backup weekly
mysqldump --single-transaction --master-data=2 --all-databases > full_backup.sql

# Daily: Just backup binary logs
cp /var/log/mysql/mysql-bin.* /backup/binlogs/

# Restore: Full backup + all binary logs
```

---

#### **Advanced Technique 3: Selective Table Backup**

```bash
# Backup only tables matching pattern
mysqldump -u root -p database_name \
    $(mysql -u root -p -Nse "SHOW TABLES LIKE 'user_%'" database_name) \
    > user_tables.sql
```

---

#### **Advanced Technique 4: Backup with Encryption**

```bash
# Encrypted backup
mysqldump -u root -p database_name | \
    openssl enc -aes-256-cbc -e -out backup.sql.enc

# Decrypt and restore
openssl enc -aes-256-cbc -d -in backup.sql.enc | \
    mysql -u root -p database_name
```

---

#### **Edge Case 1: Large Database Backup**

```bash
# For very large databases (100GB+)
# Use mydumper (parallel backup tool)
sudo apt install mydumper

mydumper -u root -p password -B database_name -o /backup/mydumper/

# Restore
myloader -u root -p password -d /backup/mydumper/ -B database_name
```

---

#### **Edge Case 2: Backup Specific Rows**

```bash
# Backup only recent data
mysqldump -u root -p database_name table_name \
    --where="created_at >= '2024-01-01'" > recent_data.sql
```

---

### **1ï¸âƒ£5ï¸âƒ£ Final Summary & Key Takeaways** ğŸ“Œ

**Key Concepts:**
1. **mysqldump** - Logical database backup tool
2. **Binary Logs** - Transaction history for PITR
3. **Point-in-Time Recovery** - Restore to specific moment
4. **Compression** - Reduce backup size
5. **Automation** - Cron-based scheduled backups

**Critical Commands:**
```bash
# Backup
mysqldump -u root -p --single-transaction database_name | gzip > backup.sql.gz

# Restore
zcat backup.sql.gz | mysql -u root -p database_name

# Point-in-Time Recovery
mysqlbinlog --stop-datetime="2024-01-15 15:44:00" mysql-bin.* | mysql -u root -p
```

**Admin Takeaways:**
- âœ… Daily automated backups essential
- âœ… Always use `--single-transaction` for InnoDB
- âœ… Compress backups to save space
- âœ… Enable binary logging for PITR
- âœ… Test restore procedures regularly
- âœ… Store backups on separate server
- âœ… Implement retention policy
- âœ… Monitor backup success/failure

**Pentester Takeaways:**
- ğŸ” Search for SQL dump files
- ğŸ” Check backup scripts for credentials
- ğŸ” Analyze dumps for sensitive data
- ğŸ” Old backups contain deleted data
- ğŸ” Binary logs have query history
- ğŸ” Check `.my.cnf` for credentials
- ğŸ” Weak permissions on backup files
- ğŸ” Web-accessible SQL files

**Remember:**
- Never put passwords in command line
- Always compress backups
- Test restore regularly
- Binary logs = point-in-time recovery
- Backup to separate server/disk

---

**Module 10 Complete! ğŸ‰**

**Topics Covered:**
1. âœ… System Snapshots with Timeshift
2. âœ… Configuration Versioning with etckeeper
3. âœ… File-level Backups (rsync & rsnapshot)
4. âœ… Database Backups (mysqldump) & PITR

**Next Module:** Advanced Logging & Auditing ğŸ“Š

---

**Happy Database Backing Up! ğŸ—„ï¸â°**
